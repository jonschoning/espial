{
  "version": 3,
  "sources": ["../output/Web.DOM.ParentNode/foreign.js", "../.spago/p/web-dom-6.0.0/src/Web/DOM/ParentNode.purs", "../output/Web.Event.EventTarget/foreign.js", "../.spago/p/web-html-4.1.0/src/Web/HTML/Event/EventTypes.purs", "../.spago/p/halogen-7.0.0/src/Halogen/Aff/Util.purs", "../.spago/p/fork-6.0.0/src/Control/Monad/Fork/Class.purs", "../.spago/p/ordered-collections-3.1.1/src/Data/Map/Internal.purs", "../output/Effect.Console/foreign.js", "../.spago/p/exists-6.0.0/src/Data/Exists.purs", "../.spago/p/free-7.1.0/src/Data/Coyoneda.purs", "../.spago/p/halogen-7.0.0/src/Halogen/Data/OrdBox.purs", "../.spago/p/halogen-7.0.0/src/Halogen/Data/Slot.purs", "../.spago/p/dom-indexed-12.0.0/src/DOM/HTML/Indexed/AutocompleteType.purs", "../.spago/p/dom-indexed-12.0.0/src/DOM/HTML/Indexed/ButtonType.purs", "../.spago/p/dom-indexed-12.0.0/src/DOM/HTML/Indexed/InputType.purs", "../.spago/p/halogen-7.0.0/src/Halogen/Query/Input.purs", "../.spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/Machine.purs", "../.spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/Types.purs", "../output/Halogen.VDom.Util/foreign.js", "../.spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/Util.purs", "../output/Web.DOM.Element/foreign.js", "../.spago/p/web-dom-6.0.0/src/Web/DOM/Element.purs", "../.spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/DOM.purs", "../.spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/DOM/Prop.purs", "../.spago/p/halogen-7.0.0/src/Halogen/HTML/Core.purs", "../.spago/p/freeap-7.0.0/src/Control/Applicative/Free.purs", "../.spago/p/catenable-lists-7.0.0/src/Data/CatQueue.purs", "../.spago/p/catenable-lists-7.0.0/src/Data/CatList.purs", "../.spago/p/free-7.1.0/src/Control/Monad/Free.purs", "../.spago/p/aff-7.1.0/src/Effect/Aff/Class.purs", "../.spago/p/halogen-7.0.0/src/Halogen/Query/ChildQuery.purs", "../output/Unsafe.Reference/foreign.js", "../.spago/p/unsafe-reference-5.0.0/src/Unsafe/Reference.purs", "../.spago/p/halogen-subscriptions-2.0.0/src/Halogen/Subscription.purs", "../.spago/p/halogen-7.0.0/src/Halogen/Query/HalogenM.purs", "../.spago/p/halogen-7.0.0/src/Halogen/Query/HalogenQ.purs", "../.spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/Thunk.purs", "../.spago/p/halogen-7.0.0/src/Halogen/Component.purs", "../.spago/p/halogen-7.0.0/src/Halogen/HTML/Elements.purs", "../.spago/p/halogen-7.0.0/src/Halogen/HTML/Properties.purs", "../.spago/p/halogen-7.0.0/src/Halogen/HTML.purs", "../.spago/p/halogen-7.0.0/src/Halogen/Query.purs", "../.spago/p/halogen-7.0.0/src/Halogen/Aff/Driver/State.purs", "../.spago/p/halogen-7.0.0/src/Halogen/Aff/Driver/Eval.purs", "../.spago/p/halogen-7.0.0/src/Halogen/Aff/Driver.purs", "../output/Web.DOM.Node/foreign.js", "../.spago/p/web-dom-6.0.0/src/Web/DOM/Node.purs", "../.spago/p/halogen-7.0.0/src/Halogen/VDom/Driver.purs", "../src/Core/ViewRendered.purs", "../output/Data.String.CodePoints/foreign.js", "../.spago/p/strings-6.0.1/src/Data/String/CodePoints.purs", "../output/Web.DOM.Document/foreign.js", "../src/Core/Util.purs", "../.spago/p/profunctor-lenses-8.0.0/src/Data/Lens/Internal/Forget.purs", "../.spago/p/profunctor-6.0.0/src/Data/Profunctor/Strong.purs", "../.spago/p/profunctor-lenses-8.0.0/src/Data/Lens/Getter.purs", "../.spago/p/profunctor-lenses-8.0.0/src/Data/Lens/Lens.purs", "../.spago/p/profunctor-lenses-8.0.0/src/Data/Lens/Setter.purs", "../.spago/p/web-uievents-5.0.0/src/Web/UIEvent/MouseEvent/EventTypes.purs", "../.spago/p/halogen-7.0.0/src/Halogen/HTML/Events.purs"],
  "sourcesContent": ["var getEffProp = function (name) {\n  return function (node) {\n    return function () {\n      return node[name];\n    };\n  };\n};\n\nexport const children = getEffProp(\"children\");\nexport const _firstElementChild = getEffProp(\"firstElementChild\");\nexport const _lastElementChild = getEffProp(\"lastElementChild\");\nexport const childElementCount = getEffProp(\"childElementCount\");\n\nexport function _querySelector(selector) {\n  return function (node) {\n    return function () {\n      return node.querySelector(selector);\n    };\n  };\n}\n\nexport function querySelectorAll(selector) {\n  return function (node) {\n    return function () {\n      return node.querySelectorAll(selector);\n    };\n  };\n}\n", "module Web.DOM.ParentNode\n  ( ParentNode\n  , children\n  , firstElementChild\n  , lastElementChild\n  , childElementCount\n  , QuerySelector(..)\n  , querySelector\n  , querySelectorAll\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Newtype (class Newtype)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Web.DOM.Internal.Types (Element)\nimport Web.DOM.HTMLCollection (HTMLCollection)\nimport Web.DOM.NodeList (NodeList)\n\nforeign import data ParentNode :: Type\n\n-- | The child elements for the node.\nforeign import children :: ParentNode -> Effect HTMLCollection\n\n-- | The first child that is an element, or Nothing if no such element exists.\nfirstElementChild :: ParentNode -> Effect (Maybe Element)\nfirstElementChild = map toMaybe <<< _firstElementChild\n\nforeign import _firstElementChild :: ParentNode -> Effect (Nullable Element)\n\n-- | The last child that is an element, or Nothing if no such element exists.\nlastElementChild :: ParentNode -> Effect (Maybe Element)\nlastElementChild = map toMaybe <<< _lastElementChild\n\nforeign import _lastElementChild :: ParentNode -> Effect (Nullable Element)\n\n-- | The number of child elements.\nforeign import childElementCount :: ParentNode -> Effect Int\n\nnewtype QuerySelector = QuerySelector String\n\nderive newtype instance eqQuerySelector :: Eq QuerySelector\nderive newtype instance ordQuerySelector :: Ord QuerySelector\nderive instance newtypeQuerySelector :: Newtype QuerySelector _\n\n-- | Finds the first child that is an element that matches the selector(s), or\n-- | Nothing if no such element exists.\nquerySelector :: QuerySelector -> ParentNode -> Effect (Maybe Element)\nquerySelector qs = map toMaybe <<< _querySelector qs\n\nforeign import _querySelector :: QuerySelector -> ParentNode -> Effect (Nullable Element)\n\n-- | Finds all the child elements that matches the selector(s).\nforeign import querySelectorAll :: QuerySelector -> ParentNode -> Effect NodeList\n", "export function eventListener(fn) {\n  return function () {\n    return function (event) {\n      return fn(event)();\n    };\n  };\n}\n\nexport function addEventListenerWithOptions(type) {\n  return function (listener) {\n    return function (options) {\n      return function (target) {\n        return function () {\n          return target.addEventListener(type, listener, options);\n        };\n      };\n    };\n  };\n}\n\nexport function addEventListener(type) {\n  return function (listener) {\n    return function (useCapture) {\n      return function (target) {\n        return function () {\n          return target.addEventListener(type, listener, useCapture);\n        };\n      };\n    };\n  };\n}\n\nexport function removeEventListener(type) {\n  return function (listener) {\n    return function (useCapture) {\n      return function (target) {\n        return function () {\n          return target.removeEventListener(type, listener, useCapture);\n        };\n      };\n    };\n  };\n}\n\nexport function dispatchEvent(event) {\n  return function (target) {\n    return function () {\n      return target.dispatchEvent(event);\n    };\n  };\n}\n", "module Web.HTML.Event.EventTypes where\n\nimport Web.Event.Event (EventType(..))\n\nabort :: EventType\nabort = EventType \"abort\"\n\nafterprint :: EventType\nafterprint = EventType \"afterprint\"\n\nafterscriptexecute :: EventType\nafterscriptexecute = EventType \"afterscriptexecute\"\n\nbeforeprint :: EventType\nbeforeprint = EventType \"beforeprint\"\n\nbeforescriptexecute :: EventType\nbeforescriptexecute = EventType \"beforescriptexecute\"\n\nblur :: EventType\nblur = EventType \"blur\"\n\ncancel :: EventType\ncancel = EventType \"cancel\"\n\nchange :: EventType\nchange = EventType \"change\"\n\nclick :: EventType\nclick = EventType \"click\"\n\nclose :: EventType\nclose = EventType \"close\"\n\ncopy :: EventType\ncopy = EventType \"copy\"\n\ncut :: EventType\ncut = EventType \"cut\"\n\ndomcontentloaded :: EventType\ndomcontentloaded = EventType \"DOMContentLoaded\"\n\nerror :: EventType\nerror = EventType \"error\"\n\nfocus :: EventType\nfocus = EventType \"focus\"\n\ninput :: EventType\ninput = EventType \"input\"\n\ninvalid :: EventType\ninvalid = EventType \"invalid\"\n\nlanguagechange :: EventType\nlanguagechange = EventType \"languagechange\"\n\nload :: EventType\nload = EventType \"load\"\n\nloadend :: EventType\nloadend = EventType \"loadend\"\n\nloadstart :: EventType\nloadstart = EventType \"loadstart\"\n\nmessage :: EventType\nmessage = EventType \"message\"\n\noffline :: EventType\noffline = EventType \"offline\"\n\nonline :: EventType\nonline = EventType \"online\"\n\npaste :: EventType\npaste = EventType \"paste\"\n\nprogress :: EventType\nprogress = EventType \"progress\"\n\nreadystatechange :: EventType\nreadystatechange = EventType \"readystatechange\"\n\nreset :: EventType\nreset = EventType \"reset\"\n\nselect :: EventType\nselect = EventType \"select\"\n\nstorage :: EventType\nstorage = EventType \"storage\"\n\nsubmit :: EventType\nsubmit = EventType \"submit\"\n\ntoggle :: EventType\ntoggle = EventType \"toggle\"\n\nunload :: EventType\nunload = EventType \"unload\"\n", "module Halogen.Aff.Util\n  ( awaitLoad\n  , awaitBody\n  , selectElement\n  , runHalogenAff\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Error.Class (throwError)\nimport Data.Either (Either(..), either)\nimport Data.Maybe (Maybe, maybe)\nimport Effect (Effect)\nimport Effect.Aff (Aff, effectCanceler, makeAff, nonCanceler, runAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Exception (throwException, error)\nimport Web.DOM.ParentNode (QuerySelector(..), querySelector)\nimport Web.Event.EventTarget (addEventListener, eventListener, removeEventListener)\nimport Web.HTML (window)\nimport Web.HTML.Event.EventTypes as ET\nimport Web.HTML.HTMLDocument (readyState)\nimport Web.HTML.HTMLDocument as HTMLDocument\nimport Web.HTML.HTMLDocument.ReadyState (ReadyState(..))\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLElement as HTMLElement\nimport Web.HTML.Window as Window\n\n-- | Waits for the document to load.\nawaitLoad :: Aff Unit\nawaitLoad = makeAff \\callback -> do\n  rs <- readyState =<< Window.document =<< window\n  case rs of\n    Loading -> do\n      et <- Window.toEventTarget <$> window\n      listener <- eventListener (\\_ -> callback (Right unit))\n      addEventListener ET.domcontentloaded listener false et\n      pure $ effectCanceler (removeEventListener ET.domcontentloaded listener false et)\n    _ -> do\n      callback (Right unit)\n      pure nonCanceler\n\n-- | Waits for the document to load and then finds the `body` element.\nawaitBody :: Aff HTMLElement\nawaitBody = do\n  awaitLoad\n  body <- selectElement (QuerySelector \"body\")\n  maybe (throwError (error \"Could not find body\")) pure body\n\n-- | Tries to find an element in the document.\nselectElement :: QuerySelector -> Aff (Maybe HTMLElement)\nselectElement query = do\n  mel <- liftEffect do\n    (querySelector query <<< HTMLDocument.toParentNode <=< Window.document) =<< window\n  pure $ HTMLElement.fromElement =<< mel\n\n-- | Runs an `Aff` value of the type commonly used by Halogen components. Any\n-- | unhandled errors will be re-thrown as exceptions.\nrunHalogenAff :: forall x. Aff x -> Effect Unit\nrunHalogenAff = runAff_ (either throwException (const (pure unit)))\n", "module Control.Monad.Fork.Class where\n\nimport Prelude hiding (join)\n\nimport Effect.Aff as Aff\nimport Control.Monad.Error.Class (class MonadThrow, class MonadError)\nimport Control.Monad.Reader.Trans (ReaderT(..), runReaderT)\nimport Control.Monad.Trans.Class (lift)\n\n-- | Represents Monads which can be forked asynchronously.\n-- |\n-- | Laws:\n-- |\n-- | ```purescript\n-- | -- Unjoined suspension is a no-op\n-- | suspend a1 *> suspend a2 = suspend a2\n-- |\n-- | -- Suspend/join is identity\n-- | suspend >=> join = id\n-- |\n-- | -- Fork/join is identity\n-- | fork >=> join = id\n-- |\n-- | -- Join is idempotent\n-- | join t *> join t = join t\n-- | ```\nclass (Monad m, Functor f) <= MonadFork f m | m -> f where\n  suspend :: forall a. m a -> m (f a)\n  fork :: forall a. m a -> m (f a)\n  join :: forall a. f a -> m a\n\ninstance monadForkAff :: MonadFork Aff.Fiber Aff.Aff where\n  suspend = Aff.suspendAff\n  fork = Aff.forkAff\n  join = Aff.joinFiber\n\ninstance monadForkReaderT :: MonadFork f m => MonadFork f (ReaderT r m) where\n  suspend (ReaderT ma) = ReaderT (suspend <<< ma)\n  fork (ReaderT ma) = ReaderT (fork <<< ma)\n  join = lift <<< join\n\n-- | Represents Monads which can be killed after being forked.\n-- |\n-- | Laws:\n-- |\n-- | ```purescript\n-- | -- Killed suspension is an exception\n-- | suspend a >>= \\f -> kill e f *> join f = throwError e\n-- |\n-- | -- Suspend/kill is unit\n-- | suspend a >>= kill e = pure unit\n-- | ```\nclass (MonadFork f m, MonadThrow e m) <= MonadKill e f m | m -> e f where\n  kill :: forall a. e -> f a -> m Unit\n\ninstance monadKillAff :: MonadKill Aff.Error Aff.Fiber Aff.Aff where\n  kill = Aff.killFiber\n\ninstance monadKillReaderT :: MonadKill e f m => MonadKill e f (ReaderT r m) where\n  kill e = lift <<< kill e\n\ndata BracketCondition e a\n  = Completed a\n  | Failed e\n  | Killed e\n\n-- | Represents Monads which support cleanup in the presence of async\n-- | exceptions.\n-- |\n-- | Laws:\n-- | ```purescript\n-- | bracket a k \\_ -> pure r\n-- |   = uninterruptible (a >>= k (Completed r))\n-- |\n-- | -- Release failed\n-- | bracket a k \\_ -> throwError e\n-- |   = uninterruptible (a >>= k (Failed e) *> throwError e)\n-- |\n-- | -- Release killed\n-- | fork (bracket a k \\_ -> never) >>= \\f -> kill e f *> void (try (join f))\n-- |   = uninterruptible (a >>= k (Killed e))\n-- | ```\nclass (MonadKill e f m, MonadError e m) <= MonadBracket e f m | m -> e f where\n  bracket :: forall r a. m r -> (BracketCondition e a -> r -> m Unit) -> (r -> m a) -> m a\n  uninterruptible :: forall a. m a -> m a\n  never :: forall a. m a\n\ninstance monadBracketAff :: MonadBracket Aff.Error Aff.Fiber Aff.Aff where\n  bracket acquire release run =\n    Aff.generalBracket acquire\n      { completed: release <<< Completed\n      , failed: release <<< Failed\n      , killed: release <<< Killed\n      }\n      run\n  uninterruptible = Aff.invincible\n  never = Aff.never\n\ninstance monadBracketReaderT :: MonadBracket e f m => MonadBracket e f (ReaderT r m) where\n  bracket (ReaderT acquire) release run = ReaderT \\r ->\n    bracket (acquire r)\n      (\\c a -> runReaderT (release c a) r)\n      (\\a -> runReaderT (run a) r)\n  uninterruptible k = ReaderT \\r ->\n    uninterruptible (runReaderT k r)\n  never = lift never\n", "-- | This module defines a type of maps as height-balanced (AVL) binary trees.\n-- | Efficient set operations are implemented in terms of\n-- | <https://www.cs.cmu.edu/~guyb/papers/BFS16.pdf>\n\nmodule Data.Map.Internal\n  ( Map(..)\n  , showTree\n  , empty\n  , isEmpty\n  , singleton\n  , checkValid\n  , insert\n  , insertWith\n  , lookup\n  , lookupLE\n  , lookupLT\n  , lookupGE\n  , lookupGT\n  , findMin\n  , findMax\n  , foldSubmap\n  , submap\n  , fromFoldable\n  , fromFoldableWith\n  , fromFoldableWithIndex\n  , toUnfoldable\n  , toUnfoldableUnordered\n  , delete\n  , pop\n  , member\n  , alter\n  , update\n  , keys\n  , values\n  , union\n  , unionWith\n  , unions\n  , intersection\n  , intersectionWith\n  , difference\n  , isSubmap\n  , size\n  , filterWithKey\n  , filterKeys\n  , filter\n  , mapMaybeWithKey\n  , mapMaybe\n  , catMaybes\n  , MapIter\n  , MapIterStep(..)\n  , toMapIter\n  , stepAsc\n  , stepAscCps\n  , stepDesc\n  , stepDescCps\n  , stepUnordered\n  , stepUnorderedCps\n  , unsafeNode\n  , unsafeBalancedNode\n  , unsafeJoinNodes\n  , unsafeSplit\n  , Split(..)\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Plus (class Plus)\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable, foldl, foldr)\nimport Data.FoldableWithIndex (class FoldableWithIndex, foldlWithIndex, foldrWithIndex)\nimport Data.Function.Uncurried (Fn2, Fn3, Fn4, Fn7, mkFn2, mkFn3, mkFn4, mkFn7, runFn2, runFn3, runFn4, runFn7)\nimport Data.FunctorWithIndex (class FunctorWithIndex)\nimport Data.List (List(..), (:))\nimport Data.Maybe (Maybe(..))\nimport Data.Ord (class Ord1, abs)\nimport Data.Traversable (traverse, class Traversable)\nimport Data.TraversableWithIndex (class TraversableWithIndex)\nimport Data.Tuple (Tuple(Tuple))\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Prim.TypeError (class Warn, Text)\n\n-- | `Map k v` represents maps from keys of type `k` to values of type `v`.\ndata Map k v = Leaf | Node Int Int k v (Map k v) (Map k v)\n\ntype role Map nominal representational\n\ninstance eq1Map :: Eq k => Eq1 (Map k) where\n  eq1 = eq\n\ninstance eqMap :: (Eq k, Eq v) => Eq (Map k v) where\n  eq xs ys = case xs of\n    Leaf ->\n      case ys of\n        Leaf -> true\n        _ -> false\n    Node _ s1 _ _ _ _ ->\n      case ys of\n        Node _ s2 _ _ _ _\n          | s1 == s2 ->\n              toMapIter xs == toMapIter ys\n        _ ->\n          false\n\ninstance ord1Map :: Ord k => Ord1 (Map k) where\n  compare1 = compare\n\ninstance ordMap :: (Ord k, Ord v) => Ord (Map k v) where\n  compare xs ys = case xs of\n    Leaf ->\n      case ys of\n        Leaf -> EQ\n        _ -> LT\n    _ ->\n      case ys of\n        Leaf -> GT\n        _ -> compare (toMapIter xs) (toMapIter ys)\n\ninstance showMap :: (Show k, Show v) => Show (Map k v) where\n  show as = \"(fromFoldable \" <> show (toUnfoldable as :: Array _) <> \")\"\n\ninstance semigroupMap ::\n  ( Warn (Text \"Data.Map's `Semigroup` instance is now unbiased and differs from the left-biased instance defined in PureScript releases <= 0.13.x.\")\n  , Ord k\n  , Semigroup v\n  ) => Semigroup (Map k v) where\n  append = unionWith append\n\ninstance monoidSemigroupMap ::\n  ( Warn (Text \"Data.Map's `Semigroup` instance is now unbiased and differs from the left-biased instance defined in PureScript releases <= 0.13.x.\")\n  , Ord k\n  , Semigroup v\n  ) => Monoid (Map k v) where\n  mempty = empty\n\ninstance altMap :: Ord k => Alt (Map k) where\n  alt = union\n\ninstance plusMap :: Ord k => Plus (Map k) where\n  empty = empty\n\ninstance functorMap :: Functor (Map k) where\n  map f = go\n    where\n    go = case _ of\n      Leaf -> Leaf\n      Node h s k v l r ->\n        Node h s k (f v) (go l) (go r)\n\ninstance functorWithIndexMap :: FunctorWithIndex k (Map k) where\n  mapWithIndex f = go\n    where\n    go = case _ of\n      Leaf -> Leaf\n      Node h s k v l r ->\n        Node h s k (f k v) (go l) (go r)\n\ninstance applyMap :: Ord k => Apply (Map k) where\n  apply = intersectionWith identity\n\ninstance bindMap :: Ord k => Bind (Map k) where\n  bind m f = mapMaybeWithKey (\\k -> lookup k <<< f) m\n\ninstance foldableMap :: Foldable (Map k) where\n  foldr f z = \\m -> runFn2 go m z\n    where\n    go = mkFn2 \\m' z' -> case m' of\n      Leaf -> z'\n      Node _ _ _ v l r ->\n        runFn2 go l (f v (runFn2 go r z'))\n  foldl f z = \\m -> runFn2 go z m\n    where\n    go = mkFn2 \\z' m' -> case m' of\n      Leaf -> z'\n      Node _ _ _ v l r ->\n        runFn2 go (f (runFn2 go z' l) v) r\n  foldMap f = go\n    where\n    go = case _ of\n      Leaf -> mempty\n      Node _ _ _ v l r ->\n        go l <> f v <> go r\n\ninstance foldableWithIndexMap :: FoldableWithIndex k (Map k) where\n  foldrWithIndex f z = \\m -> runFn2 go m z\n    where\n    go = mkFn2 \\m' z' -> case m' of\n      Leaf -> z'\n      Node _ _ k v l r ->\n        runFn2 go l (f k v (runFn2 go r z'))\n  foldlWithIndex f z = \\m -> runFn2 go z m\n    where\n    go = mkFn2 \\z' m' -> case m' of\n      Leaf -> z'\n      Node _ _ k v l r ->\n        runFn2 go (f k (runFn2 go z' l) v) r\n  foldMapWithIndex f = go\n    where\n    go = case _ of\n      Leaf -> mempty\n      Node _ _ k v l r ->\n        go l <> f k v <> go r\n\ninstance traversableMap :: Traversable (Map k) where\n  traverse f = go\n    where\n    go = case _ of\n      Leaf -> pure Leaf\n      Node h s k v l r ->\n        (\\l' v' r' -> Node h s k v' l' r')\n          <$> go l\n          <*> f v\n          <*> go r\n  sequence = traverse identity\n\ninstance traversableWithIndexMap :: TraversableWithIndex k (Map k) where\n  traverseWithIndex f = go\n    where\n    go = case _ of\n      Leaf -> pure Leaf\n      Node h s k v l r ->\n        (\\l' v' r' -> Node h s k v' l' r')\n          <$> go l\n          <*> f k v\n          <*> go r\n\n-- | Render a `Map` as a `String`\nshowTree :: forall k v. Show k => Show v => Map k v -> String\nshowTree = go \"\"\n  where\n  go ind = case _ of\n    Leaf -> ind <> \"Leaf\"\n    Node h _ k v l r ->\n      (ind <> \"[\" <> show h  <> \"] \" <> show k <> \" => \" <> show v <> \"\\n\")\n        <> (go (ind <> \"    \") l <> \"\\n\")\n        <> (go (ind <> \"    \") r)\n\n-- | An empty map\nempty :: forall k v. Map k v\nempty = Leaf\n\n-- | Test if a map is empty\nisEmpty :: forall k v. Map k v -> Boolean\nisEmpty Leaf = true\nisEmpty _ = false\n\n-- | Create a map with one key/value pair\nsingleton :: forall k v. k -> v -> Map k v\nsingleton k v = Node 1 1 k v Leaf Leaf\n\n-- | Check whether the underlying tree satisfies the height, size, and ordering invariants.\n-- |\n-- | This function is provided for internal use.\ncheckValid :: forall k v. Ord k => Map k v -> Boolean\ncheckValid = go\n  where\n  go = case _ of\n    Leaf -> true\n    Node h s k _ l r ->\n      case l of\n        Leaf ->\n          case r of\n            Leaf ->\n              true\n            Node rh rs rk _ _ _ ->\n              h == 2 && rh == 1 && s > rs && rk > k && go r\n        Node lh ls lk _ _ _ ->\n          case r of\n            Leaf ->\n              h == 2 && lh == 1 && s > ls && lk < k && go l\n            Node rh rs rk _ _ _ ->\n              h > rh && rk > k && h > lh && lk < k && abs (rh - lh) < 2 && rs + ls + 1 == s && go l && go r\n\n-- | Look up a value for the specified key\nlookup :: forall k v. Ord k => k -> Map k v -> Maybe v\nlookup k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT -> go ml\n        GT -> go mr\n        EQ -> Just mv\n\n-- | Look up a value for the specified key, or the greatest one less than it\nlookupLE :: forall k v. Ord k => k -> Map k v -> Maybe { key :: k, value :: v }\nlookupLE k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT -> go ml\n        GT ->\n          case go mr of\n            Nothing -> Just { key: mk, value: mv }\n            other -> other\n        EQ ->\n          Just { key: mk, value: mv }\n\n-- | Look up a value for the greatest key less than the specified key\nlookupLT :: forall k v. Ord k => k -> Map k v -> Maybe { key :: k, value :: v }\nlookupLT k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT -> go ml\n        GT ->\n          case go mr of\n            Nothing -> Just { key: mk, value: mv }\n            other -> other\n        EQ ->\n          findMax ml\n\n-- | Look up a value for the specified key, or the least one greater than it\nlookupGE :: forall k v. Ord k => k -> Map k v -> Maybe { key :: k, value :: v }\nlookupGE k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT ->\n          case go ml of\n            Nothing -> Just { key: mk, value: mv }\n            other -> other\n        GT -> go mr\n        EQ -> Just { key: mk, value: mv }\n\n-- | Look up a value for the least key greater than the specified key\nlookupGT :: forall k v. Ord k => k -> Map k v -> Maybe { key :: k, value :: v }\nlookupGT k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT ->\n          case go ml of\n            Nothing -> Just { key: mk, value: mv }\n            other -> other\n        GT -> go mr\n        EQ -> findMin mr\n\n-- | Returns the pair with the greatest key\nfindMax :: forall k v. Map k v -> Maybe { key :: k, value :: v }\nfindMax = case _ of\n  Leaf -> Nothing\n  Node _ _ k v  _ r ->\n    case r of\n      Leaf -> Just { key: k, value: v }\n      _ -> findMax r\n\n-- | Returns the pair with the least key\nfindMin :: forall k v. Map k v -> Maybe { key :: k, value :: v }\nfindMin = case _ of\n  Leaf -> Nothing\n  Node _ _ k v l _ ->\n    case l of\n      Leaf -> Just { key: k, value: v }\n      _ -> findMin l\n\n-- | Fold over the entries of a given map where the key is between a lower and\n-- | an upper bound. Passing `Nothing` as either the lower or upper bound\n-- | argument means that the fold has no lower or upper bound, i.e. the fold\n-- | starts from (or ends with) the smallest (or largest) key in the map.\n-- |\n-- | ```purescript\n-- | foldSubmap (Just 1) (Just 2) (\\_ v -> [v])\n-- |  (fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\", Tuple 3 \"three\"])\n-- |  == [\"one\", \"two\"]\n-- |\n-- | foldSubmap Nothing (Just 2) (\\_ v -> [v])\n-- |  (fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\", Tuple 3 \"three\"])\n-- |  == [\"zero\", \"one\", \"two\"]\n-- | ```\nfoldSubmap :: forall k v m. Ord k => Monoid m => Maybe k -> Maybe k -> (k -> v -> m) -> Map k v -> m\nfoldSubmap = foldSubmapBy (<>) mempty\n\nfoldSubmapBy :: forall k v m. Ord k => (m -> m -> m) -> m -> Maybe k -> Maybe k -> (k -> v -> m) -> Map k v -> m\nfoldSubmapBy appendFn memptyValue kmin kmax f =\n  let\n    tooSmall =\n      case kmin of\n        Just kmin' ->\n          \\k -> k < kmin'\n        Nothing ->\n          const false\n\n    tooLarge =\n      case kmax of\n        Just kmax' ->\n          \\k -> k > kmax'\n        Nothing ->\n          const false\n\n    inBounds =\n      case kmin, kmax of\n        Just kmin', Just kmax' ->\n          \\k -> kmin' <= k && k <= kmax'\n        Just kmin', Nothing ->\n          \\k -> kmin' <= k\n        Nothing, Just kmax' ->\n          \\k -> k <= kmax'\n        Nothing, Nothing ->\n          const true\n\n    go = case _ of\n      Leaf ->\n        memptyValue\n      Node _ _ k v left right ->\n                    (if tooSmall k then memptyValue else go left)\n        `appendFn` (if inBounds k then f k v else memptyValue)\n        `appendFn` (if tooLarge k then memptyValue else go right)\n  in\n    go\n\n-- | Returns a new map containing all entries of the given map which lie\n-- | between a given lower and upper bound, treating `Nothing` as no bound i.e.\n-- | including the smallest (or largest) key in the map, no matter how small\n-- | (or large) it is. For example:\n-- |\n-- | ```purescript\n-- | submap (Just 1) (Just 2)\n-- |   (fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\", Tuple 3 \"three\"])\n-- |   == fromFoldable [Tuple 1 \"one\", Tuple 2 \"two\"]\n-- |\n-- | submap Nothing (Just 2)\n-- |   (fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\", Tuple 3 \"three\"])\n-- |   == fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\"]\n-- | ```\n-- |\n-- | The function is entirely specified by the following\n-- | property:\n-- |\n-- | ```purescript\n-- | Given any m :: Map k v, mmin :: Maybe k, mmax :: Maybe k, key :: k,\n-- |   let m' = submap mmin mmax m in\n-- |     if (maybe true (\\min -> min <= key) mmin &&\n-- |         maybe true (\\max -> max >= key) mmax)\n-- |       then lookup key m == lookup key m'\n-- |       else not (member key m')\n-- | ```\nsubmap :: forall k v. Ord k => Maybe k -> Maybe k -> Map k v -> Map k v\nsubmap kmin kmax = foldSubmapBy union empty kmin kmax singleton\n\n-- | Test if a key is a member of a map\nmember :: forall k v. Ord k => k -> Map k v -> Boolean\nmember k = go\n  where\n  go = case _ of\n    Leaf -> false\n    Node _ _ mk _ ml mr ->\n      case compare k mk of\n        LT -> go ml\n        GT -> go mr\n        EQ -> true\n\n-- | Insert or replace a key/value pair in a map\ninsert :: forall k v. Ord k => k -> v -> Map k v -> Map k v\ninsert k v = go\n  where\n  go = case _ of\n    Leaf -> singleton k v\n    Node mh ms mk mv ml mr ->\n      case compare k mk of\n        LT -> runFn4 unsafeBalancedNode mk mv (go ml) mr\n        GT -> runFn4 unsafeBalancedNode mk mv ml (go mr)\n        EQ -> Node mh ms k v ml mr\n\n-- | Inserts or updates a value with the given function.\n-- |\n-- | The combining function is called with the existing value as the first\n-- | argument and the new value as the second argument.\ninsertWith :: forall k v. Ord k => (v -> v -> v) -> k -> v -> Map k v -> Map k v\ninsertWith app k v = go\n  where\n  go = case _ of\n    Leaf -> singleton k v\n    Node mh ms mk mv ml mr ->\n      case compare k mk of\n        LT -> runFn4 unsafeBalancedNode mk mv (go ml) mr\n        GT -> runFn4 unsafeBalancedNode mk mv ml (go mr)\n        EQ -> Node mh ms k (app mv v) ml mr\n\n-- | Delete a key and its corresponding value from a map.\ndelete :: forall k v. Ord k => k -> Map k v -> Map k v\ndelete k = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT -> runFn4 unsafeBalancedNode mk mv (go ml) mr\n        GT -> runFn4 unsafeBalancedNode mk mv ml (go mr)\n        EQ -> runFn2 unsafeJoinNodes ml mr\n\n-- | Delete a key and its corresponding value from a map, returning the value\n-- | as well as the subsequent map.\npop :: forall k v. Ord k => k -> Map k v -> Maybe (Tuple v (Map k v))\npop k m = do\n  let (Split x l r) = runFn3 unsafeSplit compare k m\n  map (\\a -> Tuple a (runFn2 unsafeJoinNodes l r)) x\n\n-- | Insert the value, delete a value, or update a value for a key in a map\nalter :: forall k v. Ord k => (Maybe v -> Maybe v) -> k -> Map k v -> Map k v\nalter f k m = do\n  let Split v l r = runFn3 unsafeSplit compare k m\n  case f v of\n    Nothing ->\n      runFn2 unsafeJoinNodes l r\n    Just v' ->\n      runFn4 unsafeBalancedNode k v' l r\n\n-- | Update or delete the value for a key in a map\nupdate :: forall k v. Ord k => (v -> Maybe v) -> k -> Map k v -> Map k v\nupdate f k = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node mh ms mk mv ml mr ->\n      case compare k mk of\n        LT -> runFn4 unsafeBalancedNode mk mv (go ml) mr\n        GT -> runFn4 unsafeBalancedNode mk mv ml (go mr)\n        EQ ->\n          case f mv of\n            Nothing ->\n              runFn2 unsafeJoinNodes ml mr\n            Just mv' ->\n              Node mh ms mk mv' ml mr\n\n-- | Convert any foldable collection of key/value pairs to a map.\n-- | On key collision, later values take precedence over earlier ones.\nfromFoldable :: forall f k v. Ord k => Foldable f => f (Tuple k v) -> Map k v\nfromFoldable = foldl (\\m (Tuple k v) -> insert k v m) empty\n\n-- | Convert any foldable collection of key/value pairs to a map.\n-- | On key collision, the values are configurably combined.\nfromFoldableWith :: forall f k v. Ord k => Foldable f => (v -> v -> v) -> f (Tuple k v) -> Map k v\nfromFoldableWith f = foldl (\\m (Tuple k v) -> f' k v m) empty\n  where\n  f' = insertWith (flip f)\n\n-- | Convert any indexed foldable collection into a map.\nfromFoldableWithIndex :: forall f k v. Ord k => FoldableWithIndex k f => f v -> Map k v\nfromFoldableWithIndex = foldlWithIndex (\\k m v -> insert k v m) empty\n\n-- | Convert a map to an unfoldable structure of key/value pairs where the keys are in ascending order\ntoUnfoldable :: forall f k v. Unfoldable f => Map k v -> f (Tuple k v)\ntoUnfoldable = unfoldr stepUnfoldr <<< toMapIter\n\n-- | Convert a map to an unfoldable structure of key/value pairs\n-- |\n-- | While this traversal is up to 10% faster in benchmarks than `toUnfoldable`,\n-- | it leaks the underlying map stucture, making it only suitable for applications\n-- | where order is irrelevant.\n-- |\n-- | If you are unsure, use `toUnfoldable`\ntoUnfoldableUnordered :: forall f k v. Unfoldable f => Map k v -> f (Tuple k v)\ntoUnfoldableUnordered = unfoldr stepUnfoldrUnordered <<< toMapIter\n\n-- | Get a list of the keys contained in a map\nkeys :: forall k v. Map k v -> List k\nkeys = foldrWithIndex (\\k _ acc -> k : acc) Nil\n\n-- | Get a list of the values contained in a map\nvalues :: forall k v. Map k v -> List v\nvalues = foldr Cons Nil\n\n-- | Compute the union of two maps, using the specified function\n-- | to combine values for duplicate keys.\nunionWith :: forall k v. Ord k => (v -> v -> v) -> Map k v -> Map k v -> Map k v\nunionWith app m1 m2 = runFn4 unsafeUnionWith compare app m1 m2\n\n-- | Compute the union of two maps, preferring values from the first map in the case\n-- | of duplicate keys\nunion :: forall k v. Ord k => Map k v -> Map k v -> Map k v\nunion = unionWith const\n\n-- | Compute the union of a collection of maps\nunions :: forall k v f. Ord k => Foldable f => f (Map k v) -> Map k v\nunions = foldl union empty\n\n-- | Compute the intersection of two maps, using the specified function\n-- | to combine values for duplicate keys.\nintersectionWith :: forall k a b c. Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c\nintersectionWith app m1 m2 = runFn4 unsafeIntersectionWith compare app m1 m2\n\n-- | Compute the intersection of two maps, preferring values from the first map in the case\n-- | of duplicate keys.\nintersection :: forall k a b. Ord k => Map k a -> Map k b -> Map k a\nintersection = intersectionWith const\n\n-- | Difference of two maps. Return elements of the first map where\n-- | the keys do not exist in the second map.\ndifference :: forall k v w. Ord k => Map k v -> Map k w -> Map k v\ndifference m1 m2 = runFn3 unsafeDifference compare m1 m2\n\n-- | Test whether one map contains all of the keys and values contained in another map\nisSubmap :: forall k v. Ord k => Eq v => Map k v -> Map k v -> Boolean\nisSubmap = go\n  where\n  go m1 m2 = case m1 of\n    Leaf -> true\n    Node _ _ k v l r ->\n      case lookup k m2 of\n        Nothing -> false\n        Just v' ->\n          v == v' && go l m2 && go r m2\n\n-- | Calculate the number of key/value pairs in a map\nsize :: forall k v. Map k v -> Int\nsize = case _ of\n  Leaf -> 0\n  Node _ s _ _ _ _ -> s\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | fails to hold.\nfilterWithKey :: forall k v. Ord k => (k -> v -> Boolean) -> Map k v -> Map k v\nfilterWithKey f = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node _ _ k v l r\n      | f k v ->\n          runFn4 unsafeBalancedNode k v (go l) (go r)\n      | otherwise ->\n          runFn2 unsafeJoinNodes (go l) (go r)\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | on the key fails to hold.\nfilterKeys :: forall k. Ord k => (k -> Boolean) -> Map k ~> Map k\nfilterKeys f = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node _ _ k v l r\n      | f k ->\n          runFn4 unsafeBalancedNode k v (go l) (go r)\n      | otherwise ->\n          runFn2 unsafeJoinNodes (go l) (go r)\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | on the value fails to hold.\nfilter :: forall k v. Ord k => (v -> Boolean) -> Map k v -> Map k v\nfilter = filterWithKey <<< const\n\n-- | Applies a function to each key/value pair in a map, discarding entries\n-- | where the function returns `Nothing`.\nmapMaybeWithKey :: forall k a b. Ord k => (k -> a -> Maybe b) -> Map k a -> Map k b\nmapMaybeWithKey f = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node _ _ k v l r ->\n      case f k v of\n        Just v' ->\n          runFn4 unsafeBalancedNode k v' (go l) (go r)\n        Nothing ->\n          runFn2 unsafeJoinNodes (go l) (go r)\n\n-- | Applies a function to each value in a map, discarding entries where the\n-- | function returns `Nothing`.\nmapMaybe :: forall k a b. Ord k => (a -> Maybe b) -> Map k a -> Map k b\nmapMaybe = mapMaybeWithKey <<< const\n\n-- | Filter a map of optional values, keeping only the key/value pairs which\n-- | contain a value, creating a new map.\ncatMaybes :: forall k v. Ord k => Map k (Maybe v) -> Map k v\ncatMaybes = mapMaybe identity\n\n-- | Low-level Node constructor which maintains the height and size invariants\n-- | This is unsafe because it assumes the child Maps are ordered and balanced.\nunsafeNode :: forall k v. Fn4 k v (Map k v) (Map k v) (Map k v)\nunsafeNode = mkFn4 \\k v l r -> case l of\n  Leaf ->\n    case r of\n      Leaf ->\n        Node 1 1 k v l r\n      Node h2 s2 _ _ _ _ ->\n        Node (1 + h2) (1 + s2) k v l r\n  Node h1 s1 _ _ _ _ ->\n    case r of\n      Leaf ->\n        Node (1 + h1) (1 + s1) k v l r\n      Node h2 s2 _ _ _ _ ->\n        Node (1 + if h1 > h2 then h1 else h2) (1 + s1 + s2) k v l r\n\n-- | Low-level Node constructor which maintains the balance invariants.\n-- | This is unsafe because it assumes the child Maps are ordered.\nunsafeBalancedNode :: forall k v. Fn4 k v (Map k v) (Map k v) (Map k v)\nunsafeBalancedNode = mkFn4 \\k v l r -> case l of\n  Leaf ->\n    case r of\n      Leaf ->\n        singleton k v\n      Node rh _ rk rv rl rr\n        | rh > 1 ->\n            runFn7 rotateLeft k v l rk rv rl rr\n      _ ->\n        runFn4 unsafeNode k v l r\n  Node lh _ lk lv ll lr ->\n    case r of\n      Node rh _ rk rv rl rr\n        | rh > lh + 1 ->\n            runFn7 rotateLeft k v l rk rv rl rr\n        | lh > rh + 1 ->\n            runFn7 rotateRight k v lk lv ll lr r\n      Leaf\n        | lh > 1 ->\n            runFn7 rotateRight k v lk lv ll lr r\n      _ ->\n        runFn4 unsafeNode k v l r\n  where\n  rotateLeft :: Fn7 k v (Map k v) k v (Map k v) (Map k v) (Map k v)\n  rotateLeft = mkFn7 \\k v l rk rv rl rr -> case rl of\n    Node lh _ lk lv ll lr\n      | lh > height rr ->\n          runFn4 unsafeNode lk lv (runFn4 unsafeNode k v l ll) (runFn4 unsafeNode rk rv lr rr)\n    _ ->\n      runFn4 unsafeNode rk rv (runFn4 unsafeNode k v l rl) rr\n\n  rotateRight :: Fn7 k v k v (Map k v) (Map k v) (Map k v) (Map k v)\n  rotateRight = mkFn7 \\k v lk lv ll lr r -> case lr of\n    Node rh _ rk rv rl rr\n      | height ll <= rh ->\n          runFn4 unsafeNode rk rv (runFn4 unsafeNode lk lv ll rl) (runFn4 unsafeNode k v rr r)\n    _ ->\n      runFn4 unsafeNode lk lv ll (runFn4 unsafeNode k v lr r)\n\n  height :: Map k v -> Int\n  height = case _ of\n    Leaf -> 0\n    Node h _ _ _ _ _ -> h\n\n-- | Low-level Node constructor from two Maps.\n-- | This is unsafe because it assumes the child Maps are ordered.\nunsafeJoinNodes :: forall k v. Fn2 (Map k v) (Map k v) (Map k v)\nunsafeJoinNodes = mkFn2 case _, _ of\n  Leaf, b -> b\n  Node _ _ lk lv ll lr, r -> do\n    let (SplitLast k v l) = runFn4 unsafeSplitLast lk lv ll lr\n    runFn4 unsafeBalancedNode k v l r\n\ndata SplitLast k v = SplitLast k v (Map k v)\n\n-- | Reassociates a node by moving the last node to the top.\n-- | This is unsafe because it assumes the key and child Maps are from\n-- | a balanced node.\nunsafeSplitLast :: forall k v. Fn4 k v (Map k v) (Map k v) (SplitLast k v)\nunsafeSplitLast = mkFn4 \\k v l r -> case r of\n  Leaf -> SplitLast k v l\n  Node _ _ rk rv rl rr -> do\n    let (SplitLast k' v' t') = runFn4 unsafeSplitLast rk rv rl rr\n    SplitLast k' v' (runFn4 unsafeBalancedNode k v l t')\n\ndata Split k v = Split (Maybe v) (Map k v) (Map k v)\n\n-- | Reassocates a Map so the given key is at the top.\n-- | This is unsafe because it assumes the ordering function is appropriate.\nunsafeSplit :: forall k v. Fn3 (k -> k -> Ordering) k (Map k v) (Split k v)\nunsafeSplit = mkFn3 \\comp k m -> case m of\n  Leaf ->\n    Split Nothing Leaf Leaf\n  Node _ _ mk mv ml mr ->\n    case comp k mk of\n      LT -> do\n        let (Split b ll lr) = runFn3 unsafeSplit comp k ml\n        Split b ll (runFn4 unsafeBalancedNode mk mv lr mr)\n      GT -> do\n        let (Split b rl rr) = runFn3 unsafeSplit comp k mr\n        Split b (runFn4 unsafeBalancedNode mk mv ml rl) rr\n      EQ ->\n        Split (Just mv) ml mr\n\n-- | Low-level unionWith implementation.\n-- | This is unsafe because it assumes the ordering function is appropriate.\nunsafeUnionWith :: forall k v. Fn4 (k -> k -> Ordering) (v -> v -> v) (Map k v) (Map k v) (Map k v)\nunsafeUnionWith = mkFn4 \\comp app l r -> case l, r of\n  Leaf, _ -> r\n  _, Leaf -> l\n  _, Node _ _ rk rv rl rr -> do\n    let (Split lv ll lr) = runFn3 unsafeSplit comp rk l\n    let l' = runFn4 unsafeUnionWith comp app ll rl\n    let r' = runFn4 unsafeUnionWith comp app lr rr\n    case lv of\n      Just lv' ->\n        runFn4 unsafeBalancedNode rk (app lv' rv) l' r'\n      Nothing ->\n        runFn4 unsafeBalancedNode rk rv l' r'\n\n-- | Low-level intersectionWith implementation.\n-- | This is unsafe because it assumes the ordering function is appropriate.\nunsafeIntersectionWith :: forall k a b c. Fn4 (k -> k -> Ordering) (a -> b -> c) (Map k a) (Map k b) (Map k c)\nunsafeIntersectionWith = mkFn4 \\comp app l r -> case l, r of\n  Leaf, _ -> Leaf\n  _, Leaf -> Leaf\n  _, Node _ _ rk rv rl rr -> do\n    let (Split lv ll lr) = runFn3 unsafeSplit comp rk l\n    let l' = runFn4 unsafeIntersectionWith comp app ll rl\n    let r' = runFn4 unsafeIntersectionWith comp app lr rr\n    case lv of\n      Just lv' ->\n        runFn4 unsafeBalancedNode rk (app lv' rv) l' r'\n      Nothing ->\n        runFn2 unsafeJoinNodes l' r'\n\n-- | Low-level difference implementation.\n-- | This is unsafe because it assumes the ordering function is appropriate.\nunsafeDifference :: forall k v w. Fn3 (k -> k -> Ordering) (Map k v) (Map k w) (Map k v)\nunsafeDifference = mkFn3 \\comp l r -> case l, r of\n  Leaf, _ -> Leaf\n  _, Leaf -> l\n  _, Node _ _ rk _ rl rr -> do\n    let (Split _ ll lr) = runFn3 unsafeSplit comp rk l\n    let l' = runFn3 unsafeDifference comp ll rl\n    let r' = runFn3 unsafeDifference comp lr rr\n    runFn2 unsafeJoinNodes l' r'\n\ndata MapIterStep k v\n  = IterDone\n  | IterNext k v (MapIter k v)\n\n-- | Low-level iteration state for a `Map`. Must be consumed using\n-- | an appropriate stepper.\ndata MapIter k v\n  = IterLeaf\n  | IterEmit k v (MapIter k v)\n  | IterNode (Map k v) (MapIter k v)\n\ninstance (Eq k, Eq v) => Eq (MapIter k v) where\n  eq = go\n    where\n    go a b = case stepAsc a of\n      IterNext k1 v1 a' ->\n        case stepAsc b of\n          IterNext k2 v2 b'\n            | k1 == k2 && v1 == v2 ->\n                go a' b'\n          _ ->\n            false\n      IterDone ->\n        true\n\ninstance (Ord k, Ord v) => Ord (MapIter k v) where\n  compare = go\n    where\n    go a b = case stepAsc a, stepAsc b of\n      IterNext k1 v1 a', IterNext k2 v2 b' ->\n        case compare k1 k2 of\n          EQ ->\n            case compare v1 v2 of\n              EQ ->\n                go a' b'\n              other ->\n                other\n          other ->\n            other\n      IterDone, b'->\n        case b' of\n          IterDone ->\n            EQ\n          _ ->\n            LT\n      _, IterDone ->\n        GT\n\n-- | Converts a Map to a MapIter for iteration using a MapStepper.\ntoMapIter :: forall k v. Map k v -> MapIter k v\ntoMapIter = flip IterNode IterLeaf\n\ntype MapStepper k v = MapIter k v -> MapIterStep k v\n\ntype MapStepperCps k v = forall r. (Fn3 k v (MapIter k v) r) -> (Unit -> r) -> MapIter k v -> r\n\n-- | Steps a `MapIter` in ascending order.\nstepAsc :: forall k v. MapStepper k v\nstepAsc = stepAscCps (mkFn3 \\k v next -> IterNext k v next) (const IterDone)\n\n-- | Steps a `MapIter` in descending order.\nstepDesc :: forall k v. MapStepper k v\nstepDesc = stepDescCps (mkFn3 \\k v next -> IterNext k v next) (const IterDone)\n\n-- | Steps a `MapIter` in arbitrary order.\nstepUnordered :: forall k v. MapStepper k v\nstepUnordered = stepUnorderedCps (mkFn3 \\k v next -> IterNext k v next) (const IterDone)\n\n-- | Steps a `MapIter` in ascending order with a CPS encoding.\nstepAscCps :: forall k v. MapStepperCps k v\nstepAscCps = stepWith iterMapL\n\n-- | Steps a `MapIter` in descending order with a CPS encoding.\nstepDescCps :: forall k v. MapStepperCps k v\nstepDescCps = stepWith iterMapR\n\n-- | Steps a `MapIter` in arbitrary order with a CPS encoding.\nstepUnorderedCps :: forall k v. MapStepperCps k v\nstepUnorderedCps = stepWith iterMapU\n\nstepUnfoldr :: forall k v. MapIter k v -> Maybe (Tuple (Tuple k v) (MapIter k v))\nstepUnfoldr = stepAscCps step (\\_ -> Nothing)\n  where\n  step = mkFn3 \\k v next ->\n    Just (Tuple (Tuple k v) next)\n\nstepUnfoldrUnordered :: forall k v. MapIter k v -> Maybe (Tuple (Tuple k v) (MapIter k v))\nstepUnfoldrUnordered = stepUnorderedCps step (\\_ -> Nothing)\n  where\n  step = mkFn3 \\k v next ->\n    Just (Tuple (Tuple k v) next)\n\nstepWith :: forall k v r. (MapIter k v -> Map k v -> MapIter k v) -> (Fn3 k v (MapIter k v) r) -> (Unit -> r) -> MapIter k v -> r\nstepWith f next done = go\n  where\n  go = case _ of\n    IterLeaf ->\n      done unit\n    IterEmit k v iter ->\n      runFn3 next k v iter\n    IterNode m iter ->\n      go (f iter m)\n\niterMapL :: forall k v. MapIter k v -> Map k v -> MapIter k v\niterMapL = go\n  where\n  go iter = case _ of\n    Leaf -> iter\n    Node _ _ k v l r ->\n      case r of\n        Leaf ->\n          go (IterEmit k v iter) l\n        _ ->\n          go (IterEmit k v (IterNode r iter)) l\n\niterMapR :: forall k v. MapIter k v -> Map k v -> MapIter k v\niterMapR = go\n  where\n  go iter = case _ of\n    Leaf -> iter\n    Node _ _ k v l r ->\n      case r of\n        Leaf ->\n          go (IterEmit k v iter) l\n        _ ->\n          go (IterEmit k v (IterNode l iter)) r\n\niterMapU :: forall k v. MapIter k v -> Map k v -> MapIter k v\niterMapU iter = case _ of\n  Leaf -> iter\n  Node _ _ k v l r ->\n    case l of\n      Leaf ->\n        case r of\n          Leaf ->\n            IterEmit k v iter\n          _ ->\n            IterEmit k v (IterNode r iter)\n      _ ->\n        case r of\n          Leaf ->\n            IterEmit k v (IterNode l iter)\n          _ ->\n            IterEmit k v (IterNode l (IterNode r iter))\n", "export const log = function (s) {\n  return function () {\n    console.log(s);\n  };\n};\n\nexport const warn = function (s) {\n  return function () {\n    console.warn(s);\n  };\n};\n\nexport const error = function (s) {\n  return function () {\n    console.error(s);\n  };\n};\n\nexport const info = function (s) {\n  return function () {\n    console.info(s);\n  };\n};\n\nexport const debug = function (s) {\n  return function () {\n    console.debug(s);\n  };\n};\n\nexport const time = function (s) {\n  return function () {\n    console.time(s);\n  };\n};\n\nexport const timeLog = function (s) {\n  return function () {\n    console.timeLog(s);\n  };\n};\n\nexport const timeEnd = function (s) {\n  return function () {\n    console.timeEnd(s);\n  };\n};\n\nexport const clear = function () {\n  console.clear();\n};\n\nexport const group = function (s) {\n  return function () {\n    console.group(s);\n  };\n};\n\nexport const groupCollapsed = function (s) {\n  return function () {\n    console.groupCollapsed(s);\n  };\n};\n\nexport const groupEnd = function () {\n  console.groupEnd();\n};\n", "module Data.Exists where\n\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | This type constructor can be used to existentially quantify over a type.\n-- |\n-- | Specifically, the type `Exists f` is isomorphic to the existential type `exists a. f a`.\n-- |\n-- | Existential types can be encoded using universal types (`forall`) for endofunctors in more general\n-- | categories. The benefit of this library is that, by using the FFI, we can create an efficient\n-- | representation of the existential by simply hiding type information.\n-- |\n-- | For example, consider the type `exists s. Tuple s (s -> Tuple s a)` which represents infinite streams\n-- | of elements of type `a`.\n-- |\n-- | This type can be constructed by creating a type constructor `StreamF` as follows:\n-- |\n-- | ```purescript\n-- | data StreamF a s = StreamF s (s -> Tuple s a)\n-- | ```\n-- |\n-- | We can then define the type of streams using `Exists`:\n-- |\n-- | ```purescript\n-- | type Stream a = Exists (StreamF a)\n-- | ```\nforeign import data Exists :: forall k. (k -> Type) -> Type\n\ntype role Exists representational\n\n-- | The `mkExists` function is used to introduce a value of type `Exists f`, by providing a value of\n-- | type `f a`, for some type `a` which will be hidden in the existentially-quantified type.\n-- |\n-- | For example, to create a value of type `Stream Number`, we might use `mkExists` as follows:\n-- |\n-- | ```purescript\n-- | nats :: Stream Number\n-- | nats = mkExists $ StreamF 0 (\\n -> Tuple (n + 1) n)\n-- | ```\nmkExists :: forall f a. f a -> Exists f\nmkExists = unsafeCoerce\n\n-- | The `runExists` function is used to eliminate a value of type `Exists f`. The rank 2 type ensures\n-- | that the existentially-quantified type does not escape its scope. Since the function is required\n-- | to work for _any_ type `a`, it will work for the existentially-quantified type.\n-- |\n-- | For example, we can write a function to obtain the head of a stream by using `runExists` as follows:\n-- |\n-- | ```purescript\n-- | head :: forall a. Stream a -> a\n-- | head = runExists head'\n-- |   where\n-- |   head' :: forall s. StreamF a s -> a\n-- |   head' (StreamF s f) = snd (f s)\n-- | ```\nrunExists :: forall f r. (forall a. f a -> r) -> Exists f -> r\nrunExists = unsafeCoerce\n", "module Data.Coyoneda\n  ( Coyoneda(..)\n  , CoyonedaF\n  , coyoneda\n  , unCoyoneda\n  , liftCoyoneda\n  , lowerCoyoneda\n  , hoistCoyoneda\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt, alt)\nimport Control.Alternative (class Alternative, class Plus, empty)\nimport Control.Comonad (class Comonad, extract)\nimport Control.Extend (class Extend, (<<=))\nimport Control.Monad.Trans.Class (class MonadTrans)\nimport Control.MonadPlus (class MonadPlus)\nimport Data.Distributive (class Distributive, collect)\nimport Data.Eq (class Eq1, eq1)\nimport Data.Exists (Exists, runExists, mkExists)\nimport Data.Foldable (class Foldable, foldMap, foldl, foldr)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Ord (class Ord1, compare1)\nimport Data.Semigroup.Foldable (class Foldable1, foldMap1, foldr1Default, foldl1Default)\nimport Data.Semigroup.Traversable (class Traversable1, sequence1, traverse1)\nimport Data.Traversable (class Traversable, traverse)\n\n-- | `Coyoneda` is encoded as an existential type using `Data.Exists`.\n-- |\n-- | This type constructor encodes the contents of the existential package.\ndata CoyonedaF f a i = CoyonedaF (i -> a) (f i)\n\n-- | The `Coyoneda` `Functor`.\n-- |\n-- | `Coyoneda f` is a `Functor` for any type constructor `f`. In fact,\n-- | it is the _free_ `Functor` for `f`, i.e. any natural transformation\n-- | `nat :: f ~> g`, can be factor through `liftCoyoneda`.  The natural\n-- | transformation from `Coyoneda f ~> g` is given by `lowerCoyoneda <<<\n-- | hoistCoyoneda nat`:\n-- | ```purescript\n-- | lowerCoyoneda <<< hoistCoyoneda nat <<< liftCoyoneda $ fi\n-- | = lowerCoyoneda (hoistCoyoneda nat (Coyoneda $ mkExists $ CoyonedaF identity fi))    (by definition of liftCoyoneda)\n-- | = lowerCoyoneda (coyoneda identity (nat fi))                                         (by definition of hoistCoyoneda)\n-- | = unCoyoneda map (coyoneda identity (nat fi))                                        (by definition of lowerCoyoneda)\n-- | = unCoyoneda map (Coyoneda $ mkExists $ CoyonedaF  identity (nat fi))                (by definition of coyoneda)\n-- | = map identity (nat fi)                                                              (by definition of unCoyoneda)\n-- | = nat fi                                                                       (since g is a Functor)\n-- | ```\nnewtype Coyoneda f a = Coyoneda (Exists (CoyonedaF f a))\n\ninstance eqCoyoneda :: (Functor f, Eq1 f, Eq a) => Eq (Coyoneda f a) where\n  eq x y = lowerCoyoneda x `eq1` lowerCoyoneda y\n\ninstance eq1Coyoneda :: (Functor f, Eq1 f) => Eq1 (Coyoneda f) where\n  eq1 = eq\n\ninstance ordCoyoneda :: (Functor f, Ord1 f, Ord a) => Ord (Coyoneda f a) where\n  compare x y = lowerCoyoneda x `compare1` lowerCoyoneda y\n\ninstance ord1Coyoneda :: (Functor f, Ord1 f) => Ord1 (Coyoneda f) where\n  compare1 = compare\n\ninstance functorCoyoneda :: Functor (Coyoneda f) where\n  map f (Coyoneda e) = runExists (\\(CoyonedaF k fi) -> coyoneda (f <<< k) fi) e\n\ninstance invatiantCoyoneda :: Invariant (Coyoneda f) where\n  imap = imapF\n\ninstance applyCoyoneda :: Apply f => Apply (Coyoneda f) where\n  apply f g = liftCoyoneda $ lowerCoyoneda f <*> lowerCoyoneda g\n\ninstance applicativeCoyoneda :: Applicative f => Applicative (Coyoneda f) where\n  pure = liftCoyoneda <<< pure\n\ninstance altCoyoneda :: Alt f => Alt (Coyoneda f) where\n  alt x y = liftCoyoneda $ alt (lowerCoyoneda x) (lowerCoyoneda y)\n\ninstance plusCoyoneda :: Plus f => Plus (Coyoneda f) where\n  empty = liftCoyoneda empty\n\ninstance alternativeCoyoneda :: Alternative f => Alternative (Coyoneda f)\n\ninstance bindCoyoneda :: Bind f => Bind (Coyoneda f) where\n  bind (Coyoneda e) f =\n    liftCoyoneda $\n      runExists (\\(CoyonedaF k fi) -> lowerCoyoneda <<< f <<< k =<< fi) e\n\n-- | When `f` is a Monad then it is a functor as well.  In this case\n-- | `liftCoyoneda` is not only a functor isomorphism but also a monad\n-- | isomorphism, i.e. the following law holds\n-- | ```purescript\n-- | liftCoyoneda fa >>= liftCoyoneda <<< g = liftCoyoneda $ fa >>= g\n-- | ```\ninstance monadCoyoneda :: Monad f => Monad (Coyoneda f)\n\ninstance monadTransCoyoneda :: MonadTrans Coyoneda where\n  lift = liftCoyoneda\n\ninstance monadPlusCoyoneda :: MonadPlus f => MonadPlus (Coyoneda f)\n\ninstance extendCoyoneda :: Extend w => Extend (Coyoneda w) where\n  extend f (Coyoneda e) =\n    runExists (\\(CoyonedaF k fi) -> liftCoyoneda $ f <<< coyoneda k <<= fi) e\n\n-- | As in the monad case: if `w` is a comonad, then it is a functor, thus\n-- | `liftCoyoneda` is an iso of functors, but moreover it is an iso of\n-- | comonads, i.e. the following law holds:\n-- | ```purescript\n-- | g <<= liftCoyoneda w = liftCoyoneda $ g <<< liftCoyoneda <<= w\n-- | ```\ninstance comonadCoyoneda :: Comonad w => Comonad (Coyoneda w) where\n  extract (Coyoneda e) = runExists (\\(CoyonedaF k fi) -> k $ extract fi) e\n\ninstance foldableCoyoneda :: Foldable f => Foldable (Coyoneda f) where\n  foldr f z = unCoyoneda \\k -> foldr (f <<< k) z\n  foldl f z = unCoyoneda \\k -> foldl (\\x -> f x <<< k) z\n  foldMap f = unCoyoneda \\k -> foldMap (f <<< k)\n\ninstance traversableCoyoneda :: Traversable f => Traversable (Coyoneda f) where\n  traverse f = unCoyoneda \\k -> map liftCoyoneda <<< traverse (f <<< k)\n  sequence = unCoyoneda \\k -> map liftCoyoneda <<< traverse k\n\ninstance foldable1Coyoneda :: Foldable1 f => Foldable1 (Coyoneda f) where\n  foldMap1 f = unCoyoneda \\k -> foldMap1 (f <<< k)\n  foldr1 = foldr1Default\n  foldl1 = foldl1Default\n\ninstance traversable1Coyoneda :: Traversable1 f => Traversable1 (Coyoneda f) where\n  traverse1 f = unCoyoneda \\k -> map liftCoyoneda <<< traverse1 (f <<< k)\n  sequence1 = unCoyoneda \\k -> map liftCoyoneda <<< sequence1 <<< map k\n\ninstance distributiveCoyoneda :: Distributive f => Distributive (Coyoneda f) where\n  collect f = liftCoyoneda <<< collect (lowerCoyoneda <<< f)\n  distribute = liftCoyoneda <<< collect lowerCoyoneda\n\n-- | Construct a value of type `Coyoneda f b` from a mapping function and a\n-- | value of type `f a`.\ncoyoneda :: forall f a b. (a -> b) -> f a -> Coyoneda f b\ncoyoneda k fi = Coyoneda $ mkExists $ CoyonedaF k fi\n\n-- | Deconstruct a value of `Coyoneda a` to retrieve the mapping function and\n-- | original value.\nunCoyoneda :: forall f a r. (forall b. (b -> a) -> f b -> r) -> Coyoneda f a -> r\nunCoyoneda f (Coyoneda e) = runExists (\\(CoyonedaF k fi) -> f k fi) e\n\n-- | Lift a value described by the type constructor `f` to `Coyoneda f`.\n-- |\n-- | Note that for any functor `f` `liftCoyoneda` has a right inverse\n-- | `lowerCoyoneda`:\n-- | ```purescript\n-- | liftCoyoneda <<< lowerCoyoneda $ (Coyoneda e)\n-- | = liftCoyoneda <<< unCoyoneda map $ (Coyoneda e)\n-- | = liftCoyonead (runExists (\\(CoyonedaF k fi) -> map k fi) e)\n-- | = liftCoyonead (Coyoneda e)\n-- | = coyoneda identity (Coyoneda e)\n-- | = Coyoneda e\n-- | ```\n-- | Moreover if `f` is a `Functor` then `liftCoyoneda` is an isomorphism of\n-- | functors with inverse `lowerCoyoneda`:  we already showed that\n-- | `lowerCoyoneda <<< hoistCoyoneda identity = lowerCoyoneda` is its left inverse\n-- | whenever `f` is a functor.\nliftCoyoneda :: forall f. f ~> Coyoneda f\nliftCoyoneda = coyoneda identity\n\n-- | Lower a value of type `Coyoneda f a` to the `Functor` `f`.\nlowerCoyoneda :: forall f. Functor f => Coyoneda f ~> f\nlowerCoyoneda = unCoyoneda map\n\n-- | Use a natural transformation to change the generating type constructor of a\n-- | `Coyoneda`.\nhoistCoyoneda :: forall f g. (f ~> g) -> Coyoneda f ~> Coyoneda g\nhoistCoyoneda nat (Coyoneda e) =\n  runExists (\\(CoyonedaF k fi) -> coyoneda k (nat fi)) e\n", "module Halogen.Data.OrdBox\n  ( OrdBox\n  , mkOrdBox\n  , unOrdBox\n  ) where\n\nimport Prelude\n\n-- | A value carrying its `Ord` instance so it can be used at a later date\n-- | without the need for evidence of the instance.\ndata OrdBox a = OrdBox (a -> a -> Boolean) (a -> a -> Ordering) a\n\ninstance eqOrdBox :: Eq (OrdBox a) where\n  eq (OrdBox e _ x) (OrdBox _ _ y) = e x y\n\ninstance ordOrdBox :: Ord (OrdBox a) where\n  compare (OrdBox _ c x) (OrdBox _ _ y) = c x y\n\nmkOrdBox :: forall a. Ord a => a -> OrdBox a\nmkOrdBox = OrdBox eq compare\n\nunOrdBox :: forall a. OrdBox a -> a\nunOrdBox (OrdBox _ _ a) = a\n", "module Halogen.Data.Slot\n  ( Slot\n  , SlotStorage\n  , empty\n  , lookup\n  , insert\n  , pop\n  , slots\n  , foreachSlot\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (traverse_)\nimport Data.Map (Map)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Data.Monoid.Alternate (Alternate(..))\nimport Data.Newtype (un)\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Tuple (Tuple(..))\nimport Halogen.Data.OrdBox (OrdBox, mkOrdBox, unOrdBox)\nimport Prim.Row as Row\nimport Type.Proxy (Proxy)\nimport Unsafe.Coerce (unsafeCoerce)\n\nforeign import data Any :: Type\n\n-- | A type which records the queries, output messages, and slot identifier for\n-- | a particular slot (ie. a location in HTML where a component is rendered).\n-- | For example:\n-- |\n-- | ```purescript\n-- | type ButtonSlot slot = Slot Button.Query Button.Output slot\n-- |\n-- | -- A component using this slot type can have one type of child component,\n-- | -- which supports `Button.Query` queries, `Button.Output` outputs, and\n-- | -- which can be uniquely identified by an integer.\n-- | type Slots = ( button :: ButtonSlot Int )\n-- | ```\n-- |\n-- | - `query` represents the requests that can be made of this component\n-- | - `output` represents the output messages that can be raised by this component\n-- | - `slot` represents the unique identifier for this component\ndata Slot :: (Type -> Type) -> Type -> Type -> Type\ndata Slot (query :: Type -> Type) output slot\n\nnewtype SlotStorage (slots :: Row Type) (slot :: (Type -> Type) -> Type -> Type) =\n  SlotStorage (Map (Tuple String (OrdBox Any)) Any)\n\nempty :: forall slots slot. SlotStorage slots slot\nempty = SlotStorage Map.empty\n\nlookup\n  :: forall sym px slots slot query output s\n   . Row.Cons sym (Slot query output s) px slots\n  => IsSymbol sym\n  => Ord s\n  => Proxy sym\n  -> s\n  -> SlotStorage slots slot\n  -> Maybe (slot query output)\nlookup sym key (SlotStorage m) =\n  coerceSlot (Map.lookup (Tuple (reflectSymbol sym) (coerceBox (mkOrdBox key))) m)\n  where\n  coerceSlot :: Maybe Any -> Maybe (slot query output)\n  coerceSlot = unsafeCoerce\n\n  coerceBox :: OrdBox s -> OrdBox Any\n  coerceBox = unsafeCoerce\n\npop\n  :: forall sym px slots slot query output s\n   . Row.Cons sym (Slot query output s) px slots\n  => IsSymbol sym\n  => Ord s\n  => Proxy sym\n  -> s\n  -> SlotStorage slots slot\n  -> Maybe (Tuple (slot query output) (SlotStorage slots slot))\npop sym key (SlotStorage m) =\n  coercePop (Map.pop (Tuple (reflectSymbol sym) (coerceBox (mkOrdBox key))) m)\n  where\n  coercePop :: Maybe (Tuple Any (Map (Tuple String (OrdBox Any)) Any)) -> Maybe (Tuple (slot query output) (SlotStorage slots slot))\n  coercePop = unsafeCoerce\n\n  coerceBox :: OrdBox s -> OrdBox Any\n  coerceBox = unsafeCoerce\n\ninsert\n  :: forall sym px slots slot query output s\n   . Row.Cons sym (Slot query output s) px slots\n  => IsSymbol sym\n  => Ord s\n  => Proxy sym\n  -> s\n  -> slot query output\n  -> SlotStorage slots slot\n  -> SlotStorage slots slot\ninsert sym key val (SlotStorage m) =\n  SlotStorage (Map.insert (Tuple (reflectSymbol sym) (coerceBox (mkOrdBox key))) (coerceVal val) m)\n  where\n  coerceBox :: OrdBox s -> OrdBox Any\n  coerceBox = unsafeCoerce\n\n  coerceVal :: slot query output -> Any\n  coerceVal = unsafeCoerce\n\nslots\n  :: forall sym px slots slot query output s\n   . Row.Cons sym (Slot query output s) px slots\n  => IsSymbol sym\n  => Ord s\n  => Proxy sym\n  -> SlotStorage slots slot\n  -> Map s (slot query output)\nslots sym (SlotStorage m) = un Alternate $ Map.foldSubmap Nothing Nothing go m\n  where\n  key = reflectSymbol sym\n\n  go (Tuple key' ob) val\n    | key == key' = Alternate $ Map.singleton (unOrdBox (coerceBox ob)) (coerceVal val)\n    | otherwise = Alternate Map.empty\n\n  coerceBox :: OrdBox Any -> OrdBox s\n  coerceBox = unsafeCoerce\n\n  coerceVal :: Any -> slot query output\n  coerceVal = unsafeCoerce\n\nforeachSlot\n  :: forall m slots slot\n   . Applicative m\n  => SlotStorage slots slot\n  -> (forall query output. slot query output -> m Unit)\n  -> m Unit\nforeachSlot (SlotStorage m) k = traverse_ (k <<< coerceVal) m\n  where\n  coerceVal :: forall query output. Any -> slot query output\n  coerceVal = unsafeCoerce\n", "module DOM.HTML.Indexed.AutocompleteType where\n\nimport Prelude\n\ndata AutocompleteType\n  = AutocompleteOff\n  | AutocompleteOn\n  | AutocompleteName\n  | AutocompleteHonorificPrefix\n  | AutocompleteGivenName\n  | AutocompleteAdditionalName\n  | AutocompleteFamilyName\n  | AutocompleteHonorificSuffix\n  | AutocompleteNickname\n  | AutocompleteEmail\n  | AutocompleteUsername\n  | AutocompleteNewPassword\n  | AutocompleteCurrentPassword\n  | AutocompleteOneTimeCode\n  | AutocompleteOrganizationTitle\n  | AutocompleteOrganization\n  | AutocompleteStreetAddress\n  | AutocompleteAddressLine1\n  | AutocompleteAddressLine2\n  | AutocompleteAddressLine3\n  | AutocompleteAddressLevel1\n  | AutocompleteAddressLevel2\n  | AutocompleteAddressLevel3\n  | AutocompleteAddressLevel4\n  | AutocompleteCountry\n  | AutocompleteCountryName\n  | AutocompletePostalCode\n  | AutocompleteCreditCardName\n  | AutocompleteCreditCardGivenName\n  | AutocompleteCreditCardAdditionalName\n  | AutocompleteCreditCardFamilyName\n  | AutocompleteCreditCardNumber\n  | AutocompleteCreditCardExpiration\n  | AutocompleteCreditCardExpirationMonth\n  | AutocompleteCreditCardExpirationYear\n  | AutocompleteCreditCardSecurityCode\n  | AutocompleteCreditCardType\n  | AutocompleteTransactionCurrency\n  | AutocompleteTransactionAmount\n  | AutocompleteLanguage\n  | AutocompleteBirthday\n  | AutocompleteBirthdayDay\n  | AutocompleteBirthdayMonth\n  | AutocompleteBirthdayYear\n  | AutocompleteSex\n  | AutocompleteTelephone\n  | AutocompleteTelephoneCountryCode\n  | AutocompleteTelephoneNational\n  | AutocompleteTelephoneAreaCode\n  | AutocompleteTelephoneLocal\n  | AutocompleteTelephoneLocalPrefix\n  | AutocompleteTelephoneLocalSuffix\n  | AutocompleteTelephoneExtension\n  | AutocompleteIMPP\n  | AutocompleteURL\n  | AutocompletePhoto\n\nderive instance eqAutocompleteType :: Eq AutocompleteType\nderive instance ordAutocompleteType :: Ord AutocompleteType\n\nrenderAutocompleteType :: AutocompleteType -> String\nrenderAutocompleteType = case _ of\n  AutocompleteOff -> \"off\"\n  AutocompleteOn -> \"on\"\n  AutocompleteName -> \"name\"\n  AutocompleteHonorificPrefix -> \"honorific-prefix\"\n  AutocompleteGivenName -> \"given-name\"\n  AutocompleteAdditionalName -> \"additional-name\"\n  AutocompleteFamilyName -> \"family-name\"\n  AutocompleteHonorificSuffix -> \"honorific-suffix\"\n  AutocompleteNickname -> \"nickname\"\n  AutocompleteEmail -> \"email\"\n  AutocompleteUsername -> \"username\"\n  AutocompleteNewPassword -> \"new-password\"\n  AutocompleteCurrentPassword -> \"current-password\"\n  AutocompleteOneTimeCode -> \"one-time-code\"\n  AutocompleteOrganizationTitle -> \"organization-title\"\n  AutocompleteOrganization -> \"organization\"\n  AutocompleteStreetAddress -> \"street-address\"\n  AutocompleteAddressLine1 -> \"address-line1\"\n  AutocompleteAddressLine2 -> \"address-line2\"\n  AutocompleteAddressLine3 -> \"address-line3\"\n  AutocompleteAddressLevel1 -> \"address-level1\"\n  AutocompleteAddressLevel2 -> \"address-level2\"\n  AutocompleteAddressLevel3 -> \"address-level3\"\n  AutocompleteAddressLevel4 -> \"address-level4\"\n  AutocompleteCountry -> \"country\"\n  AutocompleteCountryName -> \"country-name\"\n  AutocompletePostalCode -> \"postal-code\"\n  AutocompleteCreditCardName -> \"cc-name\"\n  AutocompleteCreditCardGivenName -> \"cc-given-name\"\n  AutocompleteCreditCardAdditionalName -> \"cc-additional-name\"\n  AutocompleteCreditCardFamilyName -> \"cc-family-name\"\n  AutocompleteCreditCardNumber -> \"cc-number\"\n  AutocompleteCreditCardExpiration -> \"cc-exp\"\n  AutocompleteCreditCardExpirationMonth -> \"cc-exp-month\"\n  AutocompleteCreditCardExpirationYear -> \"cc-exp-year\"\n  AutocompleteCreditCardSecurityCode -> \"cc-csc\"\n  AutocompleteCreditCardType -> \"cc-type\"\n  AutocompleteTransactionCurrency -> \"transaction-currency\"\n  AutocompleteTransactionAmount -> \"transaction-amount\"\n  AutocompleteLanguage -> \"language\"\n  AutocompleteBirthday -> \"bday\"\n  AutocompleteBirthdayDay -> \"bday-day\"\n  AutocompleteBirthdayMonth -> \"bday-month\"\n  AutocompleteBirthdayYear -> \"bday-year\"\n  AutocompleteSex -> \"sex\"\n  AutocompleteTelephone -> \"tel\"\n  AutocompleteTelephoneCountryCode -> \"tel-country-code\"\n  AutocompleteTelephoneNational -> \"tel-national\"\n  AutocompleteTelephoneAreaCode -> \"telarea-code\"\n  AutocompleteTelephoneLocal -> \"tel-local\"\n  AutocompleteTelephoneLocalPrefix -> \"tel-local-prefix\"\n  AutocompleteTelephoneLocalSuffix -> \"tel-local-suffix\"\n  AutocompleteTelephoneExtension -> \"tel-extension\"\n  AutocompleteIMPP -> \"impp\"\n  AutocompleteURL -> \"url\"\n  AutocompletePhoto -> \"photo\"\n", "module DOM.HTML.Indexed.ButtonType where\n\nimport Prelude\n\ndata ButtonType\n  = ButtonButton\n  | ButtonSubmit\n  | ButtonReset\n\nderive instance eqButtonType :: Eq ButtonType\nderive instance ordButtonType :: Ord ButtonType\n\nrenderButtonType :: ButtonType -> String\nrenderButtonType = case _ of\n  ButtonButton -> \"button\"\n  ButtonSubmit -> \"submit\"\n  ButtonReset -> \"reset\"\n", "module DOM.HTML.Indexed.InputType where\n\nimport Prelude\n\ndata InputType\n  = InputButton\n  | InputCheckbox\n  | InputColor\n  | InputDate\n  | InputDatetimeLocal\n  | InputEmail\n  | InputFile\n  | InputHidden\n  | InputImage\n  | InputMonth\n  | InputNumber\n  | InputPassword\n  | InputRadio\n  | InputRange\n  | InputReset\n  | InputSearch\n  | InputSubmit\n  | InputTel\n  | InputText\n  | InputTime\n  | InputUrl\n  | InputWeek\n\nderive instance eqInputType :: Eq InputType\nderive instance ordInputType :: Ord InputType\n\nrenderInputType :: InputType -> String\nrenderInputType = case _ of\n  InputButton -> \"button\"\n  InputCheckbox -> \"checkbox\"\n  InputColor -> \"color\"\n  InputDate -> \"date\"\n  InputDatetimeLocal -> \"datetime-local\"\n  InputEmail -> \"email\"\n  InputFile -> \"file\"\n  InputHidden -> \"hidden\"\n  InputImage -> \"image\"\n  InputMonth -> \"month\"\n  InputNumber -> \"number\"\n  InputPassword -> \"password\"\n  InputRadio -> \"radio\"\n  InputRange -> \"range\"\n  InputReset -> \"reset\"\n  InputSearch -> \"search\"\n  InputSubmit -> \"submit\"\n  InputTel -> \"tel\"\n  InputText -> \"text\"\n  InputTime -> \"time\"\n  InputUrl -> \"url\"\n  InputWeek -> \"week\"\n", "module Halogen.Query.Input where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Newtype (class Newtype)\nimport Web.DOM (Element)\n\nnewtype RefLabel = RefLabel String\n\nderive instance newtypeRefLabel :: Newtype RefLabel _\nderive newtype instance eqRefLabel :: Eq RefLabel\nderive newtype instance ordRefLabel :: Ord RefLabel\n\ndata Input action\n  = RefUpdate RefLabel (Maybe Element)\n  | Action action\n\nderive instance functorInput :: Functor Input\n", "module Halogen.VDom.Machine\n  ( Machine\n  , Step'(..)\n  , Step\n  , mkStep\n  , unStep\n  , extract\n  , step\n  , halt\n  ) where\n\nimport Prelude\n\nimport Effect.Uncurried (EffectFn1, EffectFn2, mkEffectFn1, mkEffectFn2, runEffectFn1, runEffectFn2)\nimport Unsafe.Coerce (unsafeCoerce)\n\ntype Machine a b = EffectFn1 a (Step a b)\n\ndata Step' a b s = Step b s (EffectFn2 s a (Step a b)) (EffectFn1 s Unit)\n\nforeign import data Step \u2237 Type \u2192 Type \u2192 Type\n\nmkStep \u2237 \u2200 a b s. Step' a b s \u2192 Step a b\nmkStep = unsafeCoerce\n\nunStep :: \u2200 a b r. (\u2200 s. Step' a b s \u2192 r) \u2192 Step a b \u2192 r\nunStep = unsafeCoerce\n\n-- | Returns the output value of a `Step`.\nextract \u2237 \u2200 a b. Step a b \u2192 b\nextract = unStep \\(Step x _ _ _) \u2192 x\n\n-- | Runs the next step.\nstep \u2237 \u2200 a b. EffectFn2 (Step a b) a (Step a b)\nstep = coerce $ mkEffectFn2 \\(Step _ s k _) a \u2192 runEffectFn2 k s a\n  where\n  coerce \u2237 \u2200 s. EffectFn2 (Step' a b s) a (Step a b) \u2192 EffectFn2 (Step a b) a (Step a b)\n  coerce = unsafeCoerce\n\n-- | Runs the finalizer associated with a `Step`\nhalt \u2237 \u2200 a b. EffectFn1 (Step a b) Unit\nhalt = coerce $ mkEffectFn1 \\(Step _ s _ k) \u2192 runEffectFn1 k s\n  where\n  coerce \u2237 \u2200 s. EffectFn1 (Step' a b s) Unit \u2192 EffectFn1 (Step a b) Unit\n  coerce = unsafeCoerce\n", "module Halogen.VDom.Types\n  ( VDom(..)\n  , renderWidget\n  , Graft\n  , GraftX(..)\n  , graft\n  , unGraft\n  , runGraft\n  , ElemName(..)\n  , Namespace(..)\n  ) where\n\nimport Prelude\nimport Data.Bifunctor (class Bifunctor, bimap)\nimport Data.Maybe (Maybe)\nimport Data.Newtype (class Newtype)\nimport Data.Tuple (Tuple)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | The core virtual-dom tree type, where `a` is the type of attributes,\n-- | and `w` is the type of \"widgets\". Widgets are machines that have complete\n-- | control over the lifecycle of some `DOM.Node`.\n-- |\n-- | The `Grafted` constructor and associated machinery enables `bimap`\n-- | fusion using a Coyoneda-like encoding.\ndata VDom a w\n  = Text String\n  | Elem (Maybe Namespace) ElemName a (Array (VDom a w))\n  | Keyed (Maybe Namespace) ElemName a (Array (Tuple String (VDom a w)))\n  | Widget w\n  | Grafted (Graft a w)\n\ninstance functorVDom \u2237 Functor (VDom a) where\n  map _ (Text a) = Text a\n  map g (Grafted a) = Grafted (map g a)\n  map g a = Grafted (graft (Graft identity g a))\n\ninstance bifunctorVDom \u2237 Bifunctor VDom where\n  bimap _ _ (Text a) = Text a\n  bimap f g (Grafted a) = Grafted (bimap f g a)\n  bimap f g a = Grafted (graft (Graft f g a))\n\n-- | Replaces \"widgets\" in the `VDom` with the ability to turn them into other\n-- | `VDom` nodes.\n-- |\n-- | Using this function will fuse any `Graft`s present in the `VDom`.\nrenderWidget \u2237 \u2200 a b w x. (a \u2192 b) \u2192 (w \u2192 VDom b x) \u2192 VDom a w \u2192 VDom b x\nrenderWidget f g = case _ of\n  Text a \u2192 Text a\n  Elem ns n a ch \u2192 Elem ns n (f a) (map (renderWidget f g) ch)\n  Keyed ns n a ch \u2192 Keyed ns n (f a) (map (map (renderWidget f g)) ch)\n  Widget w \u2192 g w\n  Grafted gaw \u2192 renderWidget f g (runGraft gaw)\n\nforeign import data Graft \u2237 Type \u2192 Type \u2192 Type\n\ninstance functorGraft \u2237 Functor (Graft a) where\n  map g = unGraft \\(Graft f' g' a) \u2192 graft (Graft f' (g <<< g') a)\n\ninstance bifunctorGraft \u2237 Bifunctor Graft where\n  bimap f g = unGraft \\(Graft f' g' a) \u2192 graft (Graft (f <<< f') (g <<< g') a)\n\ndata GraftX a a' w w' =\n  Graft (a \u2192 a') (w \u2192 w') (VDom a w)\n\ngraft\n  \u2237 \u2200 a a' w w'\n  . GraftX a a' w w'\n  \u2192 Graft a' w'\ngraft = unsafeCoerce\n\nunGraft\n  \u2237 \u2200 a' w' r\n  . (\u2200 a w. GraftX a a' w w' \u2192 r)\n  \u2192 Graft a' w'\n  \u2192 r\nunGraft f = f <<< unsafeCoerce\n\nrunGraft\n  \u2237 \u2200 a' w'\n  . Graft a' w'\n  \u2192 VDom a' w'\nrunGraft =\n  unGraft \\(Graft fa fw v) \u2192\n    let\n      go (Text s) = Text s\n      go (Elem ns n a ch) = Elem ns n (fa a) (map go ch)\n      go (Keyed ns n a ch) = Keyed ns n (fa a) (map (map go) ch)\n      go (Widget w) = Widget (fw w)\n      go (Grafted g) = Grafted (bimap fa fw g)\n    in\n      go v\n\nnewtype ElemName = ElemName String\n\nderive instance newtypeElemName \u2237 Newtype ElemName _\nderive newtype instance eqElemName \u2237 Eq ElemName\nderive newtype instance ordElemName \u2237 Ord ElemName\n\nnewtype Namespace = Namespace String\n\nderive instance newtypeNamespace \u2237 Newtype Namespace _\nderive newtype instance eqNamespace \u2237 Eq Namespace\nderive newtype instance ordNamespace \u2237 Ord Namespace\n", "\"use strict\";\n\nexport function unsafeGetAny(key, obj) {\n  return obj[key];\n}\n\nexport function unsafeHasAny(key, obj) {\n  return obj.hasOwnProperty(key);\n}\n\nexport function unsafeSetAny(key, val, obj) {\n    obj[key] = val;\n}\n\nexport function unsafeDeleteAny(key, obj) {\n  delete obj[key];\n}\n\nexport function forE(a, f) {\n  var b = [];\n  for (var i = 0; i < a.length; i++) {\n    b.push(f(i, a[i]));\n  }\n  return b;\n}\n\nexport function forEachE(a, f) {\n  for (var i = 0; i < a.length; i++) {\n    f(a[i]);\n  }\n}\n\nexport function forInE(o, f) {\n  var ks = Object.keys(o);\n  for (var i = 0; i < ks.length; i++) {\n    var k = ks[i];\n    f(k, o[k]);\n  }\n}\n\nexport function replicateE(n, f) {\n  for (var i = 0; i < n; i++) {\n    f();\n  }\n}\n\nexport function diffWithIxE(a1, a2, f1, f2, f3) {\n  var a3 = [];\n  var l1 = a1.length;\n  var l2 = a2.length;\n  var i  = 0;\n  while (1) {\n    if (i < l1) {\n      if (i < l2) {\n        a3.push(f1(i, a1[i], a2[i]));\n      } else {\n        f2(i, a1[i]);\n      }\n    } else if (i < l2) {\n      a3.push(f3(i, a2[i]));\n    } else {\n      break;\n    }\n    i++;\n  }\n  return a3;\n}\n\nexport function strMapWithIxE(as, fk, f) {\n  var o = {};\n  for (var i = 0; i < as.length; i++) {\n    var a = as[i];\n    var k = fk(a);\n    o[k] = f(k, i, a);\n  }\n  return o;\n}\n\nexport function diffWithKeyAndIxE(o1, as, fk, f1, f2, f3) {\n  var o2 = {};\n  for (var i = 0; i < as.length; i++) {\n    var a = as[i];\n    var k = fk(a);\n    if (o1.hasOwnProperty(k)) {\n      o2[k] = f1(k, i, o1[k], a);\n    } else {\n      o2[k] = f3(k, i, a);\n    }\n  }\n  for (var k in o1) {\n    if (k in o2) {\n      continue;\n    }\n    f2(k, o1[k]);\n  }\n  return o2;\n}\n\nexport function refEq(a, b) {\n  return a === b;\n}\n\nexport function createTextNode(s, doc) {\n  return doc.createTextNode(s);\n}\n\nexport function setTextContent(s, n) {\n  n.textContent = s;\n}\n\nexport function createElement(ns, name, doc) {\n  if (ns != null) {\n    return doc.createElementNS(ns, name);\n  } else {\n    return doc.createElement(name)\n  }\n}\n\nexport function insertChildIx(i, a, b) {\n  var n = b.childNodes.item(i) || null;\n  if (n !== a) {\n    b.insertBefore(a, n);\n  }\n}\n\nexport function removeChild(a, b) {\n  if (b && a.parentNode === b) {\n    b.removeChild(a);\n  }\n}\n\nexport function parentNode(a) {\n  return a.parentNode;\n}\n\nexport function setAttribute(ns, attr, val, el) {\n  if (ns != null) {\n    el.setAttributeNS(ns, attr, val);\n  } else {\n    el.setAttribute(attr, val);\n  }\n}\n\nexport function removeAttribute(ns, attr, el) {\n  if (ns != null) {\n    el.removeAttributeNS(ns, attr);\n  } else {\n    el.removeAttribute(attr);\n  }\n}\n\nexport function hasAttribute(ns, attr, el) {\n  if (ns != null) {\n    return el.hasAttributeNS(ns, attr);\n  } else {\n    return el.hasAttribute(attr);\n  }\n}\n\nexport function addEventListener(ev, listener, el) {\n  el.addEventListener(ev, listener, false);\n}\n\nexport function removeEventListener(ev, listener, el) {\n  el.removeEventListener(ev, listener, false);\n}\n\nexport var jsUndefined = void 0;\n", "module Halogen.VDom.Util\n  ( newMutMap\n  , pokeMutMap\n  , deleteMutMap\n  , unsafeFreeze\n  , unsafeLookup\n  , unsafeGetAny\n  , unsafeHasAny\n  , unsafeSetAny\n  , unsafeDeleteAny\n  , forE\n  , forEachE\n  , forInE\n  , replicateE\n  , diffWithIxE\n  , diffWithKeyAndIxE\n  , strMapWithIxE\n  , refEq\n  , createTextNode\n  , setTextContent\n  , createElement\n  , insertChildIx\n  , removeChild\n  , parentNode\n  , setAttribute\n  , removeAttribute\n  , hasAttribute\n  , addEventListener\n  , removeEventListener\n  , JsUndefined\n  , jsUndefined\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried as Fn\nimport Data.Nullable (Nullable)\nimport Effect (Effect)\nimport Effect.Uncurried as EFn\nimport Foreign.Object (Object)\nimport Foreign.Object as Object\nimport Foreign.Object.ST (STObject)\nimport Foreign.Object.ST as STObject\nimport Halogen.VDom.Types (Namespace, ElemName)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Document (Document) as DOM\nimport Web.DOM.Element (Element) as DOM\nimport Web.DOM.Node (Node) as DOM\nimport Web.Event.EventTarget (EventListener) as DOM\n\nnewMutMap \u2237 \u2200 r a. Effect (STObject r a)\nnewMutMap = unsafeCoerce STObject.new\n\npokeMutMap \u2237 \u2200 r a. EFn.EffectFn3 String a (STObject r a) Unit\npokeMutMap = unsafeSetAny\n\ndeleteMutMap \u2237 \u2200 r a. EFn.EffectFn2 String (STObject r a) Unit\ndeleteMutMap = unsafeDeleteAny\n\nunsafeFreeze \u2237 \u2200 r a. STObject r a \u2192 Object a\nunsafeFreeze = unsafeCoerce\n\nunsafeLookup \u2237 \u2200 a. Fn.Fn2 String (Object a) a\nunsafeLookup = unsafeGetAny\n\nforeign import unsafeGetAny\n  \u2237 \u2200 a b. Fn.Fn2 String a b\n\nforeign import unsafeHasAny\n  \u2237 \u2200 a. Fn.Fn2 String a Boolean\n\nforeign import unsafeSetAny \u2237 \u2200 a b. EFn.EffectFn3 String a b Unit\n\nforeign import unsafeDeleteAny\n  \u2237 \u2200 a. EFn.EffectFn2 String a Unit\n\nforeign import forE\n  \u2237 \u2200 a b\n  . EFn.EffectFn2\n      (Array a)\n      (EFn.EffectFn2 Int a b)\n      (Array b)\n\nforeign import forEachE\n  \u2237 \u2200 a\n  . EFn.EffectFn2\n      (Array a)\n      (EFn.EffectFn1 a Unit)\n      Unit\n\nforeign import forInE\n  \u2237 \u2200 a\n  . EFn.EffectFn2\n      (Object.Object a)\n      (EFn.EffectFn2 String a Unit)\n      Unit\n\nforeign import replicateE\n  \u2237 \u2200 a\n  . EFn.EffectFn2\n      Int\n      (Effect a)\n      Unit\n\nforeign import diffWithIxE\n  \u2237 \u2200 b c d\n  . EFn.EffectFn5\n      (Array b)\n      (Array c)\n      (EFn.EffectFn3 Int b c d)\n      (EFn.EffectFn2 Int b Unit)\n      (EFn.EffectFn2 Int c d)\n      (Array d)\n\nforeign import diffWithKeyAndIxE\n  \u2237 \u2200 a b c d\n  . EFn.EffectFn6\n      (Object.Object a)\n      (Array b)\n      (b \u2192 String)\n      (EFn.EffectFn4 String Int a b c)\n      (EFn.EffectFn2 String a d)\n      (EFn.EffectFn3 String Int b c)\n      (Object.Object c)\n\nforeign import strMapWithIxE\n  \u2237 \u2200 a b\n  . EFn.EffectFn3\n      (Array a)\n      (a \u2192 String)\n      (EFn.EffectFn3 String Int a b)\n      (Object.Object b)\n\nforeign import refEq\n  \u2237 \u2200 a b. Fn.Fn2 a b Boolean\n\nforeign import createTextNode\n  \u2237 EFn.EffectFn2 String DOM.Document DOM.Node\n\nforeign import setTextContent\n  \u2237 EFn.EffectFn2 String DOM.Node Unit\n\nforeign import createElement\n  \u2237 EFn.EffectFn3 (Nullable Namespace) ElemName DOM.Document DOM.Element\n\nforeign import insertChildIx\n  \u2237 EFn.EffectFn3 Int DOM.Node DOM.Node Unit\n\nforeign import removeChild\n  \u2237 EFn.EffectFn2 DOM.Node DOM.Node Unit\n\nforeign import parentNode\n  \u2237 EFn.EffectFn1 DOM.Node DOM.Node\n\nforeign import setAttribute\n  \u2237 EFn.EffectFn4 (Nullable Namespace) String String DOM.Element Unit\n\nforeign import removeAttribute\n  \u2237 EFn.EffectFn3 (Nullable Namespace) String DOM.Element Unit\n\nforeign import hasAttribute\n  \u2237 EFn.EffectFn3 (Nullable Namespace) String DOM.Element Boolean\n\nforeign import addEventListener\n  \u2237 EFn.EffectFn3 String DOM.EventListener DOM.Element Unit\n\nforeign import removeEventListener\n  \u2237 EFn.EffectFn3 String DOM.EventListener DOM.Element Unit\n\nforeign import data JsUndefined \u2237 Type\n\nforeign import jsUndefined \u2237 JsUndefined\n", "var getProp = function (name) {\n  return function (doctype) {\n    return doctype[name];\n  };\n};\n\nexport const _namespaceURI = getProp(\"namespaceURI\");\nexport const _prefix = getProp(\"prefix\");\nexport const localName = getProp(\"localName\");\nexport const tagName = getProp(\"tagName\");\n\nexport function id(node) {\n  return function () {\n    return node.id;\n  };\n}\n\nexport function setId(id) {\n  return function (node) {\n    return function () {\n      node.id = id;\n    };\n  };\n}\n\nexport function className(node) {\n  return function () {\n    return node.className;\n  };\n}\n\nexport function classList(element) {\n  return function () {\n    return element.classList;\n  };\n}\n\nexport function setClassName(className) {\n  return function (node) {\n    return function () {\n      node.className = className;\n    };\n  };\n}\n\nexport function getElementsByTagName(localName) {\n  return function (doc) {\n    return function () {\n      return doc.getElementsByTagName(localName);\n    };\n  };\n}\n\nexport function _getElementsByTagNameNS(ns) {\n  return function (localName) {\n    return function (doc) {\n      return function () {\n        return doc.getElementsByTagNameNS(ns, localName);\n      };\n    };\n  };\n}\n\nexport function getElementsByClassName(classNames) {\n  return function (doc) {\n    return function () {\n      return doc.getElementsByClassName(classNames);\n    };\n  };\n}\n\nexport function setAttribute(name) {\n  return function (value) {\n    return function (element) {\n      return function () {\n        element.setAttribute(name, value);\n      };\n    };\n  };\n}\n\nexport function _getAttribute(name) {\n  return function (element) {\n    return function () {\n      return element.getAttribute(name);\n    };\n  };\n}\n\nexport function hasAttribute(name) {\n  return function (element) {\n    return function () {\n      return element.hasAttribute(name);\n    };\n  };\n}\n\nexport function removeAttribute(name) {\n  return function (element) {\n    return function () {\n      element.removeAttribute(name);\n    };\n  };\n}\n\nexport function matches(selector) {\n  return function(element) {\n    return function () {\n      return element.matches(selector);\n    };\n  };\n}\n\nexport function _closest(selector) {\n  return function(element) {\n    return function () {\n      return element.closest(selector);\n    };\n  };\n}\n\n// - CSSOM ---------------------------------------------------------------------\n\nexport function scrollTop(node) {\n  return function () {\n    return node.scrollTop;\n  };\n}\n\nexport function setScrollTop(scrollTop) {\n  return function (node) {\n    return function () {\n      node.scrollTop = scrollTop;\n    };\n  };\n}\n\nexport function scrollLeft(node) {\n  return function () {\n    return node.scrollLeft;\n  };\n}\n\nexport function setScrollLeft(scrollLeft) {\n  return function (node) {\n    return function () {\n      node.scrollLeft = scrollLeft;\n    };\n  };\n}\n\nexport function scrollWidth(el) {\n  return function () {\n    return el.scrollWidth;\n  };\n}\n\nexport function scrollHeight(el) {\n  return function () {\n    return el.scrollHeight;\n  };\n}\n\nexport function clientTop(el) {\n  return function () {\n    return el.clientTop;\n  };\n}\n\nexport function clientLeft(el) {\n  return function () {\n    return el.clientLeft;\n  };\n}\n\nexport function clientWidth(el) {\n  return function () {\n    return el.clientWidth;\n  };\n}\n\nexport function clientHeight(el) {\n  return function () {\n    return el.clientHeight;\n  };\n}\n\nexport function getBoundingClientRect(el) {\n  return function () {\n    var rect = el.getBoundingClientRect();\n    return {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: rect.width,\n      height: rect.height,\n      x: rect.x,\n      y: rect.y\n    };\n  };\n}\n\nexport function _attachShadow(props) {\n  return function (el) {\n    return function() {\n      return el.attachShadow(props);\n    };\n  };\n}\n", "module Web.DOM.Element\n  ( module Exports\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , namespaceURI\n  , prefix\n  , localName\n  , tagName\n  , id\n  , setId\n  , className\n  , classList\n  , setClassName\n  , getElementsByTagName\n  , getElementsByTagNameNS\n  , getElementsByClassName\n  , setAttribute\n  , getAttribute\n  , hasAttribute\n  , removeAttribute\n  , matches\n  , closest\n  , scrollTop\n  , setScrollTop\n  , scrollLeft\n  , setScrollLeft\n  , scrollWidth\n  , scrollHeight\n  , clientTop\n  , clientLeft\n  , clientWidth\n  , clientHeight\n  , getBoundingClientRect\n  , DOMRect\n  , ShadowRootInit\n  , attachShadow\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe, toNullable)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.ChildNode (ChildNode)\nimport Web.DOM.DOMTokenList (DOMTokenList)\nimport Web.DOM.Internal.Types (Element) as Exports\nimport Web.DOM.Internal.Types (Element, HTMLCollection, Node)\nimport Web.DOM.NonDocumentTypeChildNode (NonDocumentTypeChildNode)\nimport Web.DOM.ParentNode (QuerySelector) as Exports\nimport Web.DOM.ParentNode (ParentNode, QuerySelector)\nimport Web.DOM.ShadowRoot (ShadowRoot, ShadowRootMode)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nfromNode :: Node -> Maybe Element\nfromNode = unsafeReadProtoTagged \"Element\"\n\nfromChildNode :: ChildNode -> Maybe Element\nfromChildNode = unsafeReadProtoTagged \"Element\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe Element\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"Element\"\n\nfromParentNode :: ParentNode -> Maybe Element\nfromParentNode = unsafeReadProtoTagged \"Element\"\n\nfromEventTarget :: EventTarget -> Maybe Element\nfromEventTarget = unsafeReadProtoTagged \"Element\"\n\ntoNode :: Element -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: Element -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: Element -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: Element -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: Element -> EventTarget\ntoEventTarget = unsafeCoerce\n\nnamespaceURI :: Element -> Maybe String\nnamespaceURI = toMaybe <<< _namespaceURI\n\nprefix :: Element -> Maybe String\nprefix = toMaybe <<< _prefix\n\nforeign import _namespaceURI :: Element -> Nullable String\nforeign import _prefix :: Element -> Nullable String\nforeign import localName :: Element -> String\nforeign import tagName :: Element -> String\n\nforeign import id :: Element -> Effect String\nforeign import setId :: String -> Element -> Effect Unit\nforeign import className :: Element -> Effect String\nforeign import classList :: Element -> Effect DOMTokenList\nforeign import setClassName :: String -> Element -> Effect Unit\n\nforeign import getElementsByTagName :: String -> Element -> Effect HTMLCollection\n\ngetElementsByTagNameNS :: Maybe String -> String -> Element -> Effect HTMLCollection\ngetElementsByTagNameNS = _getElementsByTagNameNS <<< toNullable\n\nforeign import _getElementsByTagNameNS :: Nullable String -> String -> Element -> Effect HTMLCollection\n\nforeign import getElementsByClassName :: String -> Element -> Effect HTMLCollection\n\nforeign import setAttribute :: String -> String -> Element -> Effect Unit\n\ngetAttribute :: String -> Element -> Effect (Maybe String)\ngetAttribute attr = map toMaybe <<< _getAttribute attr\n\nforeign import _getAttribute :: String -> Element -> Effect (Nullable String)\nforeign import hasAttribute :: String -> Element -> Effect Boolean\nforeign import removeAttribute :: String -> Element -> Effect Unit\n\nforeign import matches :: QuerySelector -> Element -> Effect Boolean\n\nclosest :: QuerySelector -> Element -> Effect (Maybe Element)\nclosest qs = map toMaybe <<< _closest qs\n\nforeign import _closest :: QuerySelector -> Element -> Effect (Nullable Element)\n\nforeign import scrollTop :: Element -> Effect Number\nforeign import setScrollTop :: Number -> Element -> Effect Unit\n\nforeign import scrollLeft :: Element -> Effect Number\nforeign import setScrollLeft :: Number -> Element -> Effect Unit\n\nforeign import scrollWidth :: Element -> Effect Number\nforeign import scrollHeight :: Element -> Effect Number\nforeign import clientTop :: Element -> Effect Number\nforeign import clientLeft :: Element -> Effect Number\nforeign import clientWidth :: Element -> Effect Number\nforeign import clientHeight :: Element -> Effect Number\n\ntype DOMRect =\n  { top :: Number\n  , right :: Number\n  , bottom :: Number\n  , left :: Number\n  , width :: Number\n  , height :: Number\n  , x :: Number\n  , y :: Number\n  }\n\nforeign import getBoundingClientRect :: Element -> Effect DOMRect\n\ntype ShadowRootInit = {\n  mode :: ShadowRootMode,\n  delegatesFocus :: Boolean\n}\n\nattachShadow :: ShadowRootInit -> Element -> Effect ShadowRoot\nattachShadow = _attachShadow <<< initToProps\n\ntype ShadowRootProps = {\n  mode :: String,\n  delegatesFocus :: Boolean\n}\n\ninitToProps :: ShadowRootInit -> ShadowRootProps\ninitToProps init = {\n  mode: show init.mode,\n  delegatesFocus: init.delegatesFocus\n}\n\nforeign import _attachShadow :: ShadowRootProps -> Element -> Effect ShadowRoot\n", "module Halogen.VDom.DOM\n  ( VDomSpec(..)\n  , buildVDom\n  , buildText\n  , buildElem\n  , buildKeyed\n  , buildWidget\n  ) where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Function.Uncurried as Fn\nimport Data.Maybe (Maybe(..))\nimport Data.Nullable (toNullable)\nimport Data.Tuple (Tuple(..), fst)\nimport Effect.Uncurried as EFn\nimport Foreign.Object as Object\nimport Halogen.VDom.Machine (Machine, Step, Step'(..), extract, halt, mkStep, step, unStep)\nimport Halogen.VDom.Machine as Machine\nimport Halogen.VDom.Types (ElemName(..), Namespace(..), VDom(..), runGraft)\nimport Halogen.VDom.Util as Util\nimport Web.DOM.Document (Document) as DOM\nimport Web.DOM.Element (Element) as DOM\nimport Web.DOM.Element as DOMElement\nimport Web.DOM.Node (Node) as DOM\n\ntype VDomMachine a w = Machine (VDom a w) DOM.Node\n\ntype VDomStep a w = Step (VDom a w) DOM.Node\n\ntype VDomInit i a w = EFn.EffectFn1 i (VDomStep a w)\n\ntype VDomBuilder i a w = EFn.EffectFn3 (VDomSpec a w) (VDomMachine a w) i (VDomStep a w)\n\ntype VDomBuilder4 i j k l a w = EFn.EffectFn6 (VDomSpec a w) (VDomMachine a w) i j k l (VDomStep a w)\n\n-- | Widget machines recursively reference the configured spec to potentially\n-- | enable recursive trees of Widgets.\nnewtype VDomSpec a w = VDomSpec\n  { buildWidget \u2237 VDomSpec a w \u2192 Machine w DOM.Node\n  , buildAttributes \u2237 DOM.Element \u2192 Machine a Unit\n  , document \u2237 DOM.Document\n  }\n\n-- | Starts an initial `VDom` machine by providing a `VDomSpec`.\n-- |\n-- | ```purescript\n-- | main = do\n-- |   machine1 \u2190 buildVDom spec vdomTree1\n-- |   machine2 \u2190 Machine.step machine1 vdomTree2\n-- |   machine3 \u2190 Machine.step machine2 vdomTree3\n-- |   ...\n-- | ````\nbuildVDom \u2237 \u2200 a w. VDomSpec a w \u2192 VDomMachine a w\nbuildVDom spec = build\n  where\n  build = EFn.mkEffectFn1 case _ of\n    Text s \u2192 EFn.runEffectFn3 buildText spec build s\n    Elem ns n a ch \u2192 EFn.runEffectFn6 buildElem spec build ns n a ch\n    Keyed ns n a ch \u2192 EFn.runEffectFn6 buildKeyed spec build ns n a ch\n    Widget w \u2192 EFn.runEffectFn3 buildWidget spec build w\n    Grafted g \u2192 EFn.runEffectFn1 build (runGraft g)\n\ntype TextState a w =\n  { build \u2237 VDomMachine a w\n  , node \u2237 DOM.Node\n  , value \u2237 String\n  }\n\nbuildText \u2237 \u2200 a w. VDomBuilder String a w\nbuildText = EFn.mkEffectFn3 \\(VDomSpec spec) build s \u2192 do\n  node \u2190 EFn.runEffectFn2 Util.createTextNode s spec.document\n  let state = { build, node, value: s }\n  pure $ mkStep $ Step node state patchText haltText\n\npatchText \u2237 \u2200 a w. EFn.EffectFn2 (TextState a w) (VDom a w) (VDomStep a w)\npatchText = EFn.mkEffectFn2 \\state vdom \u2192 do\n  let { build, node, value: value1 } = state\n  case vdom of\n    Grafted g \u2192\n      EFn.runEffectFn2 patchText state (runGraft g)\n    Text value2\n      | value1 == value2 \u2192\n          pure $ mkStep $ Step node state patchText haltText\n      | otherwise \u2192 do\n          let nextState = { build, node, value: value2 }\n          EFn.runEffectFn2 Util.setTextContent value2 node\n          pure $ mkStep $ Step node nextState patchText haltText\n    _ \u2192 do\n      EFn.runEffectFn1 haltText state\n      EFn.runEffectFn1 build vdom\n\nhaltText \u2237 \u2200 a w. EFn.EffectFn1 (TextState a w) Unit\nhaltText = EFn.mkEffectFn1 \\{ node } \u2192 do\n  parent \u2190 EFn.runEffectFn1 Util.parentNode node\n  EFn.runEffectFn2 Util.removeChild node parent\n\ntype ElemState a w =\n  { build \u2237 VDomMachine a w\n  , node \u2237 DOM.Node\n  , attrs \u2237 Step a Unit\n  , ns \u2237 Maybe Namespace\n  , name \u2237 ElemName\n  , children \u2237 Array (VDomStep a w)\n  }\n\nbuildElem \u2237 \u2200 a w. VDomBuilder4 (Maybe Namespace) ElemName a (Array (VDom a w)) a w\nbuildElem = EFn.mkEffectFn6 \\(VDomSpec spec) build ns1 name1 as1 ch1 \u2192 do\n  el \u2190 EFn.runEffectFn3 Util.createElement (toNullable ns1) name1 spec.document\n  let\n    node = DOMElement.toNode el\n    onChild = EFn.mkEffectFn2 \\ix child \u2192 do\n      res \u2190 EFn.runEffectFn1 build child\n      EFn.runEffectFn3 Util.insertChildIx ix (extract res) node\n      pure res\n  children \u2190 EFn.runEffectFn2 Util.forE ch1 onChild\n  attrs \u2190 EFn.runEffectFn1 (spec.buildAttributes el) as1\n  let\n    state =\n      { build\n      , node\n      , attrs\n      , ns: ns1\n      , name: name1\n      , children\n      }\n  pure $ mkStep $ Step node state patchElem haltElem\n\npatchElem \u2237 \u2200 a w. EFn.EffectFn2 (ElemState a w) (VDom a w) (VDomStep a w)\npatchElem = EFn.mkEffectFn2 \\state vdom \u2192 do\n  let { build, node, attrs, ns: ns1, name: name1, children: ch1 } = state\n  case vdom of\n    Grafted g \u2192\n      EFn.runEffectFn2 patchElem state (runGraft g)\n    Elem ns2 name2 as2 ch2 | Fn.runFn4 eqElemSpec ns1 name1 ns2 name2 \u2192 do\n      case Array.length ch1, Array.length ch2 of\n        0, 0 \u2192 do\n          attrs2 \u2190 EFn.runEffectFn2 step attrs as2\n          let\n            nextState =\n              { build\n              , node\n              , attrs: attrs2\n              , ns: ns2\n              , name: name2\n              , children: ch1\n              }\n          pure $ mkStep $ Step node nextState patchElem haltElem\n        _, _ \u2192 do\n          let\n            onThese = EFn.mkEffectFn3 \\ix s v \u2192 do\n              res \u2190 EFn.runEffectFn2 step s v\n              EFn.runEffectFn3 Util.insertChildIx ix (extract res) node\n              pure res\n            onThis = EFn.mkEffectFn2 \\_ s \u2192 EFn.runEffectFn1 halt s\n            onThat = EFn.mkEffectFn2 \\ix v \u2192 do\n              res \u2190 EFn.runEffectFn1 build v\n              EFn.runEffectFn3 Util.insertChildIx ix (extract res) node\n              pure res\n          children2 \u2190 EFn.runEffectFn5 Util.diffWithIxE ch1 ch2 onThese onThis onThat\n          attrs2 \u2190 EFn.runEffectFn2 step attrs as2\n          let\n            nextState =\n              { build\n              , node\n              , attrs: attrs2\n              , ns: ns2\n              , name: name2\n              , children: children2\n              }\n          pure $ mkStep $ Step node nextState patchElem haltElem\n    _ \u2192 do\n      EFn.runEffectFn1 haltElem state\n      EFn.runEffectFn1 build vdom\n\nhaltElem \u2237 \u2200 a w. EFn.EffectFn1 (ElemState a w) Unit\nhaltElem = EFn.mkEffectFn1 \\{ node, attrs, children } \u2192 do\n  parent \u2190 EFn.runEffectFn1 Util.parentNode node\n  EFn.runEffectFn2 Util.removeChild node parent\n  EFn.runEffectFn2 Util.forEachE children halt\n  EFn.runEffectFn1 halt attrs\n\ntype KeyedState a w =\n  { build \u2237 VDomMachine a w\n  , node \u2237 DOM.Node\n  , attrs \u2237 Step a Unit\n  , ns \u2237 Maybe Namespace\n  , name \u2237 ElemName\n  , children \u2237 Object.Object (VDomStep a w)\n  , length \u2237 Int\n  }\n\nbuildKeyed \u2237 \u2200 a w. VDomBuilder4 (Maybe Namespace) ElemName a (Array (Tuple String (VDom a w))) a w\nbuildKeyed = EFn.mkEffectFn6 \\(VDomSpec spec) build ns1 name1 as1 ch1 \u2192 do\n  el \u2190 EFn.runEffectFn3 Util.createElement (toNullable ns1) name1 spec.document\n  let\n    node = DOMElement.toNode el\n    onChild = EFn.mkEffectFn3 \\_ ix (Tuple _ vdom) \u2192 do\n      res \u2190 EFn.runEffectFn1 build vdom\n      EFn.runEffectFn3 Util.insertChildIx ix (extract res) node\n      pure res\n  children \u2190 EFn.runEffectFn3 Util.strMapWithIxE ch1 fst onChild\n  attrs \u2190 EFn.runEffectFn1 (spec.buildAttributes el) as1\n  let\n    state =\n      { build\n      , node\n      , attrs\n      , ns: ns1\n      , name: name1\n      , children\n      , length: Array.length ch1\n      }\n  pure $ mkStep $ Step node state patchKeyed haltKeyed\n\npatchKeyed \u2237 \u2200 a w. EFn.EffectFn2 (KeyedState a w) (VDom a w) (VDomStep a w)\npatchKeyed = EFn.mkEffectFn2 \\state vdom \u2192 do\n  let { build, node, attrs, ns: ns1, name: name1, children: ch1, length: len1 } = state\n  case vdom of\n    Grafted g \u2192\n      EFn.runEffectFn2 patchKeyed state (runGraft g)\n    Keyed ns2 name2 as2 ch2 | Fn.runFn4 eqElemSpec ns1 name1 ns2 name2 \u2192\n      case len1, Array.length ch2 of\n        0, 0 \u2192 do\n          attrs2 \u2190 EFn.runEffectFn2 Machine.step attrs as2\n          let\n            nextState =\n              { build\n              , node\n              , attrs: attrs2\n              , ns: ns2\n              , name: name2\n              , children: ch1\n              , length: 0\n              }\n          pure $ mkStep $ Step node nextState patchKeyed haltKeyed\n        _, len2 \u2192 do\n          let\n            onThese = EFn.mkEffectFn4 \\_ ix' s (Tuple _ v) \u2192 do\n              res \u2190 EFn.runEffectFn2 step s v\n              EFn.runEffectFn3 Util.insertChildIx ix' (extract res) node\n              pure res\n            onThis = EFn.mkEffectFn2 \\_ s \u2192 EFn.runEffectFn1 halt s\n            onThat = EFn.mkEffectFn3 \\_ ix (Tuple _ v) \u2192 do\n              res \u2190 EFn.runEffectFn1 build v\n              EFn.runEffectFn3 Util.insertChildIx ix (extract res) node\n              pure res\n          children2 \u2190 EFn.runEffectFn6 Util.diffWithKeyAndIxE ch1 ch2 fst onThese onThis onThat\n          attrs2 \u2190 EFn.runEffectFn2 step attrs as2\n          let\n            nextState =\n              { build\n              , node\n              , attrs: attrs2\n              , ns: ns2\n              , name: name2\n              , children: children2\n              , length: len2\n              }\n          pure $ mkStep $ Step node nextState patchKeyed haltKeyed\n    _ \u2192 do\n      EFn.runEffectFn1 haltKeyed state\n      EFn.runEffectFn1 build vdom\n\nhaltKeyed \u2237 \u2200 a w. EFn.EffectFn1 (KeyedState a w) Unit\nhaltKeyed = EFn.mkEffectFn1 \\{ node, attrs, children } \u2192 do\n  parent \u2190 EFn.runEffectFn1 Util.parentNode node\n  EFn.runEffectFn2 Util.removeChild node parent\n  EFn.runEffectFn2 Util.forInE children (EFn.mkEffectFn2 \\_ s \u2192 EFn.runEffectFn1 halt s)\n  EFn.runEffectFn1 halt attrs\n\ntype WidgetState a w =\n  { build \u2237 VDomMachine a w\n  , widget \u2237 Step w DOM.Node\n  }\n\nbuildWidget \u2237 \u2200 a w. VDomBuilder w a w\nbuildWidget = EFn.mkEffectFn3 \\(VDomSpec spec) build w \u2192 do\n  res \u2190 EFn.runEffectFn1 (spec.buildWidget (VDomSpec spec)) w\n  let\n    res' = res # unStep \\(Step n _ _ _) \u2192\n      mkStep $ Step n { build, widget: res } patchWidget haltWidget\n  pure res'\n\npatchWidget \u2237 \u2200 a w. EFn.EffectFn2 (WidgetState a w) (VDom a w) (VDomStep a w)\npatchWidget = EFn.mkEffectFn2 \\state vdom \u2192 do\n  let { build, widget } = state\n  case vdom of\n    Grafted g \u2192\n      EFn.runEffectFn2 patchWidget state (runGraft g)\n    Widget w \u2192 do\n      res \u2190 EFn.runEffectFn2 step widget w\n      let\n        res' = res # unStep \\(Step n _ _ _) \u2192\n          mkStep $ Step n { build, widget: res } patchWidget haltWidget\n      pure res'\n    _ \u2192 do\n      EFn.runEffectFn1 haltWidget state\n      EFn.runEffectFn1 build vdom\n\nhaltWidget \u2237 forall a w. EFn.EffectFn1 (WidgetState a w) Unit\nhaltWidget = EFn.mkEffectFn1 \\{ widget } \u2192 do\n  EFn.runEffectFn1 halt widget\n\neqElemSpec \u2237 Fn.Fn4 (Maybe Namespace) ElemName (Maybe Namespace) ElemName Boolean\neqElemSpec = Fn.mkFn4 \\ns1 (ElemName name1) ns2 (ElemName name2) \u2192\n  if name1 == name2\n    then case ns1, ns2 of\n      Just (Namespace ns1'), Just (Namespace ns2') | ns1' == ns2' \u2192 true\n      Nothing, Nothing \u2192 true\n      _, _ \u2192 false\n    else false\n", "module Halogen.VDom.DOM.Prop\n  ( Prop(..)\n  , ElemRef(..)\n  , PropValue\n  , propFromString\n  , propFromBoolean\n  , propFromInt\n  , propFromNumber\n  , buildProp\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried as Fn\nimport Data.Maybe (Maybe(..))\nimport Data.Nullable (null, toNullable)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Effect (Effect)\nimport Effect.Ref as Ref\nimport Effect.Uncurried as EFn\nimport Foreign (typeOf)\nimport Foreign.Object as Object\nimport Halogen.VDom as V\nimport Halogen.VDom.Machine (Step'(..), mkStep)\nimport Halogen.VDom.Types (Namespace(..))\nimport Halogen.VDom.Util as Util\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Element (Element) as DOM\nimport Web.Event.Event (EventType(..), Event) as DOM\nimport Web.Event.EventTarget (eventListener) as DOM\n\n-- | Attributes, properties, event handlers, and element lifecycles.\n-- | Parameterized by the type of handlers outputs.\ndata Prop a\n  = Attribute (Maybe Namespace) String String\n  | Property String PropValue\n  | Handler DOM.EventType (DOM.Event \u2192 Maybe a)\n  | Ref (ElemRef DOM.Element \u2192 Maybe a)\n\ninstance functorProp \u2237 Functor Prop where\n  map f (Handler ty g) = Handler ty (map f <$> g)\n  map f (Ref g) = Ref (map f <$> g)\n  map _ p = unsafeCoerce p\n\ndata ElemRef a\n  = Created a\n  | Removed a\n\ninstance functorElemRef \u2237 Functor ElemRef where\n  map f (Created a) = Created (f a)\n  map f (Removed a) = Removed (f a)\n\nforeign import data PropValue \u2237 Type\n\npropFromString \u2237 String \u2192 PropValue\npropFromString = unsafeCoerce\n\npropFromBoolean \u2237 Boolean \u2192 PropValue\npropFromBoolean = unsafeCoerce\n\npropFromInt \u2237 Int \u2192 PropValue\npropFromInt = unsafeCoerce\n\npropFromNumber \u2237 Number \u2192 PropValue\npropFromNumber = unsafeCoerce\n\n-- | A `Machine`` for applying attributes, properties, and event handlers.\n-- | An emitter effect must be provided to respond to events. For example,\n-- | to allow arbitrary effects in event handlers, one could use `id`.\nbuildProp\n  \u2237 \u2200 a\n  . (a \u2192 Effect Unit)\n  \u2192 DOM.Element\n  \u2192 V.Machine (Array (Prop a)) Unit\nbuildProp emit el = renderProp\n  where\n  renderProp = EFn.mkEffectFn1 \\ps1 \u2192 do\n    events \u2190 Util.newMutMap\n    ps1' \u2190 EFn.runEffectFn3 Util.strMapWithIxE ps1 propToStrKey (applyProp events)\n    let\n      state =\n        { events: Util.unsafeFreeze events\n        , props: ps1'\n        }\n    pure $ mkStep $ Step unit state patchProp haltProp\n\n  patchProp = EFn.mkEffectFn2 \\state ps2 \u2192 do\n    events \u2190 Util.newMutMap\n    let\n      { events: prevEvents, props: ps1 } = state\n      onThese = Fn.runFn2 diffProp prevEvents events\n      onThis = removeProp prevEvents\n      onThat = applyProp events\n    props \u2190 EFn.runEffectFn6 Util.diffWithKeyAndIxE ps1 ps2 propToStrKey onThese onThis onThat\n    let\n      nextState =\n        { events: Util.unsafeFreeze events\n        , props\n        }\n    pure $ mkStep $ Step unit nextState patchProp haltProp\n\n  haltProp = EFn.mkEffectFn1 \\state \u2192 do\n    case Object.lookup \"ref\" state.props of\n      Just (Ref f) \u2192\n        EFn.runEffectFn1 mbEmit (f (Removed el))\n      _ \u2192 pure unit\n\n  mbEmit = EFn.mkEffectFn1 case _ of\n    Just a \u2192 emit a\n    _ \u2192 pure unit\n\n  applyProp events = EFn.mkEffectFn3 \\_ _ v \u2192\n    case v of\n      Attribute ns attr val \u2192 do\n        EFn.runEffectFn4 Util.setAttribute (toNullable ns) attr val el\n        pure v\n      Property prop val \u2192 do\n        EFn.runEffectFn3 setProperty prop val el\n        pure v\n      Handler (DOM.EventType ty) f \u2192 do\n        case Fn.runFn2 Util.unsafeGetAny ty events of\n          handler | Fn.runFn2 Util.unsafeHasAny ty events \u2192 do\n            Ref.write f (snd handler)\n            pure v\n          _ \u2192 do\n            ref \u2190 Ref.new f\n            listener \u2190 DOM.eventListener \\ev \u2192 do\n              f' \u2190 Ref.read ref\n              EFn.runEffectFn1 mbEmit (f' ev)\n            EFn.runEffectFn3 Util.pokeMutMap ty (Tuple listener ref) events\n            EFn.runEffectFn3 Util.addEventListener ty listener el\n            pure v\n      Ref f \u2192 do\n        EFn.runEffectFn1 mbEmit (f (Created el))\n        pure v\n\n  diffProp = Fn.mkFn2 \\prevEvents events \u2192 EFn.mkEffectFn4 \\_ _ v1 v2 \u2192\n    case v1, v2 of\n      Attribute _ _ val1, Attribute ns2 attr2 val2 \u2192\n        if val1 == val2\n          then pure v2\n          else do\n            EFn.runEffectFn4 Util.setAttribute (toNullable ns2) attr2 val2 el\n            pure v2\n      Property _ val1, Property prop2 val2 \u2192\n        case Fn.runFn2 Util.refEq val1 val2, prop2 of\n          true, _ \u2192\n            pure v2\n          _, \"value\" \u2192 do\n            let elVal = Fn.runFn2 unsafeGetProperty \"value\" el\n            if Fn.runFn2 Util.refEq elVal val2\n              then pure v2\n              else do\n                EFn.runEffectFn3 setProperty prop2 val2 el\n                pure v2\n          _, _ \u2192 do\n            EFn.runEffectFn3 setProperty prop2 val2 el\n            pure v2\n      Handler _ _, Handler (DOM.EventType ty) f \u2192 do\n        let\n          handler = Fn.runFn2 Util.unsafeLookup ty prevEvents\n        Ref.write f (snd handler)\n        EFn.runEffectFn3 Util.pokeMutMap ty handler events\n        pure v2\n      _, _ \u2192\n        pure v2\n\n  removeProp prevEvents = EFn.mkEffectFn2 \\_ v \u2192\n    case v of\n      Attribute ns attr _ \u2192\n        EFn.runEffectFn3 Util.removeAttribute (toNullable ns) attr el\n      Property prop _ \u2192\n        EFn.runEffectFn2 removeProperty prop el\n      Handler (DOM.EventType ty) _ \u2192 do\n        let\n          handler = Fn.runFn2 Util.unsafeLookup ty prevEvents\n        EFn.runEffectFn3 Util.removeEventListener ty (fst handler) el\n      Ref _ \u2192\n        pure unit\n\npropToStrKey \u2237 \u2200 i. Prop i \u2192 String\npropToStrKey = case _ of\n  Attribute (Just (Namespace ns)) attr _ \u2192 \"attr/\" <> ns <> \":\" <> attr\n  Attribute _ attr _ \u2192 \"attr/:\" <> attr\n  Property prop _ \u2192 \"prop/\" <> prop\n  Handler (DOM.EventType ty) _ \u2192 \"handler/\" <> ty\n  Ref _ \u2192 \"ref\"\n\nsetProperty \u2237 EFn.EffectFn3 String PropValue DOM.Element Unit\nsetProperty = Util.unsafeSetAny\n\nunsafeGetProperty \u2237 Fn.Fn2 String DOM.Element PropValue\nunsafeGetProperty = Util.unsafeGetAny\n\nremoveProperty \u2237 EFn.EffectFn2 String DOM.Element Unit\nremoveProperty = EFn.mkEffectFn2 \\key el \u2192\n  EFn.runEffectFn3 Util.hasAttribute null key el >>= if _\n    then EFn.runEffectFn3 Util.removeAttribute null key el\n    else case typeOf (Fn.runFn2 Util.unsafeGetAny key el) of\n      \"string\" \u2192 EFn.runEffectFn3 Util.unsafeSetAny key \"\" el\n      _        \u2192 case key of\n        \"rowSpan\" \u2192 EFn.runEffectFn3 Util.unsafeSetAny key 1 el\n        \"colSpan\" \u2192 EFn.runEffectFn3 Util.unsafeSetAny key 1 el\n        _ \u2192 EFn.runEffectFn3 Util.unsafeSetAny key Util.jsUndefined el\n", "module Halogen.HTML.Core\n  ( HTML(..)\n  , renderWidget\n  , widget\n  , text\n  , element\n  , keyed\n  , prop\n  , attr\n  , handler\n  , ref\n  , class IsProp\n  , toPropValue\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport DOM.HTML.Indexed.AutocompleteType (AutocompleteType, renderAutocompleteType)\nimport DOM.HTML.Indexed.ButtonType (ButtonType, renderButtonType)\nimport DOM.HTML.Indexed.CrossOriginValue (CrossOriginValue, renderCrossOriginValue)\nimport DOM.HTML.Indexed.DirValue (DirValue, renderDirValue)\nimport DOM.HTML.Indexed.FormMethod (FormMethod, renderFormMethod)\nimport DOM.HTML.Indexed.InputAcceptType (InputAcceptType, renderInputAcceptType)\nimport DOM.HTML.Indexed.InputType (InputType, renderInputType)\nimport DOM.HTML.Indexed.KindValue (KindValue, renderKindValue)\nimport DOM.HTML.Indexed.MenuType (MenuType, renderMenuType)\nimport DOM.HTML.Indexed.MenuitemType (MenuitemType, renderMenuitemType)\nimport DOM.HTML.Indexed.OrderedListType (OrderedListType, renderOrderedListType)\nimport DOM.HTML.Indexed.PreloadValue (PreloadValue, renderPreloadValue)\nimport DOM.HTML.Indexed.ScopeValue (ScopeValue, renderScopeValue)\nimport DOM.HTML.Indexed.StepValue (StepValue, renderStepValue)\nimport DOM.HTML.Indexed.WrapValue (WrapValue, renderWrapValue)\nimport Data.Bifunctor (class Bifunctor, bimap, rmap)\nimport Data.Maybe (Maybe(..))\nimport Data.MediaType (MediaType)\nimport Data.Newtype (class Newtype, un, unwrap)\nimport Data.Tuple (Tuple)\nimport Halogen.Query.Input (Input)\nimport Halogen.VDom (ElemName(..), Namespace(..)) as Exports\nimport Halogen.VDom.DOM.Prop (ElemRef(..), Prop(..), PropValue, propFromBoolean, propFromInt, propFromNumber, propFromString)\nimport Halogen.VDom.DOM.Prop (Prop(..), PropValue) as Exports\nimport Halogen.VDom.Types as VDom\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Element (Element)\nimport Web.Event.Event (Event, EventType)\nimport Web.HTML.Common (AttrName(..), ClassName(..), PropName(..)) as Exports\nimport Web.HTML.Common (AttrName(..), PropName(..))\n\nnewtype HTML w i = HTML (VDom.VDom (Array (Prop (Input i))) w)\n\nderive instance newtypeHTML :: Newtype (HTML w i) _\n\ninstance bifunctorHTML :: Bifunctor HTML where\n  bimap f g (HTML vdom) = HTML (bimap (map (map (map g))) f vdom)\n\ninstance functorHTML :: Functor (HTML p) where\n  map = rmap\n\nrenderWidget :: forall w x i j. (i -> j) -> (w -> HTML x j) -> HTML w i -> HTML x j\nrenderWidget f g (HTML vdom) =\n  HTML (VDom.renderWidget (map (map (map f))) (un HTML <<< g) vdom)\n\nwidget :: forall p q. p -> HTML p q\nwidget = HTML <<< VDom.Widget\n\n-- | Constructs a text node `HTML` value.\ntext :: forall w i. String -> HTML w i\ntext = HTML <<< VDom.Text\n\n-- | A smart constructor for HTML elements.\nelement :: forall w i. Maybe VDom.Namespace -> VDom.ElemName -> Array (Prop i) -> Array (HTML w i) -> HTML w i\nelement ns =\n  coe (\\name props children -> VDom.Elem ns name props children)\n  where\n  coe\n    :: (VDom.ElemName -> Array (Prop i) -> Array (VDom.VDom (Array (Prop i)) w) -> VDom.VDom (Array (Prop i)) w)\n    -> VDom.ElemName\n    -> Array (Prop i)\n    -> Array (HTML w i)\n    -> HTML w i\n  coe = unsafeCoerce\n\n-- | A smart constructor for HTML elements with keyed children.\nkeyed :: forall w i. Maybe VDom.Namespace -> VDom.ElemName -> Array (Prop i) -> Array (Tuple String (HTML w i)) -> HTML w i\nkeyed ns = coe (\\name props children -> VDom.Keyed ns name props children)\n  where\n  coe\n    :: (VDom.ElemName -> Array (Prop i) -> Array (Tuple String (VDom.VDom (Array (Prop i)) w)) -> VDom.VDom (Array (Prop i)) w)\n    -> VDom.ElemName\n    -> Array (Prop i)\n    -> Array (Tuple String (HTML w i))\n    -> HTML w i\n  coe = unsafeCoerce\n\n-- | Create a HTML property.\nprop :: forall value i. IsProp value => PropName value -> value -> Prop i\nprop (PropName name) = Property name <<< toPropValue\n\n-- | Create a HTML attribute.\nattr :: forall i. Maybe VDom.Namespace -> AttrName -> String -> Prop i\nattr ns (AttrName name) = Attribute ns name\n\n-- | Create an event handler.\nhandler :: forall i. EventType -> (Event -> Maybe i) -> Prop i\nhandler = Handler\n\nref :: forall i. (Maybe Element -> Maybe i) -> Prop i\nref f = Ref $ f <<< case _ of\n  Created x -> Just x\n  Removed _ -> Nothing\n\nclass IsProp a where\n  toPropValue :: a -> PropValue\n\ninstance isPropString :: IsProp String where\n  toPropValue = propFromString\n\ninstance isPropInt :: IsProp Int where\n  toPropValue = propFromInt\n\ninstance isPropNumber :: IsProp Number where\n  toPropValue = propFromNumber\n\ninstance isPropBoolean :: IsProp Boolean where\n  toPropValue = propFromBoolean\n\ninstance isPropMediaType :: IsProp MediaType where\n  toPropValue = propFromString <<< unwrap\n\ninstance isPropButtonType :: IsProp ButtonType where\n  toPropValue = propFromString <<< renderButtonType\n\ninstance isPropCrossOriginValue :: IsProp CrossOriginValue where\n  toPropValue = propFromString <<< renderCrossOriginValue\n\ninstance isPropDirValue :: IsProp DirValue where\n  toPropValue = propFromString <<< renderDirValue\n\ninstance isPropFormMethod :: IsProp FormMethod where\n  toPropValue = propFromString <<< renderFormMethod\n\ninstance isPropInputType :: IsProp InputType where\n  toPropValue = propFromString <<< renderInputType\n\ninstance isPropKindValue :: IsProp KindValue where\n  toPropValue = propFromString <<< renderKindValue\n\ninstance isPropMenuitemType :: IsProp MenuitemType where\n  toPropValue = propFromString <<< renderMenuitemType\n\ninstance isPropMenuType :: IsProp MenuType where\n  toPropValue = propFromString <<< renderMenuType\n\ninstance isPropAutocompleteType :: IsProp AutocompleteType where\n  toPropValue = propFromString <<< renderAutocompleteType\n\ninstance isPropOrderedListType :: IsProp OrderedListType where\n  toPropValue = propFromString <<< renderOrderedListType\n\ninstance isPropPreloadValue :: IsProp PreloadValue where\n  toPropValue = propFromString <<< renderPreloadValue\n\ninstance isPropScopeValue :: IsProp ScopeValue where\n  toPropValue = propFromString <<< renderScopeValue\n\ninstance isPropStepValue :: IsProp StepValue where\n  toPropValue = propFromString <<< renderStepValue\n\ninstance isPropWrapValue :: IsProp WrapValue where\n  toPropValue = propFromString <<< renderWrapValue\n\ninstance isPropInputAcceptType :: IsProp InputAcceptType where\n  toPropValue = propFromString <<< renderInputAcceptType\n", "module Control.Applicative.Free\n  ( FreeAp\n  , liftFreeAp\n  , retractFreeAp\n  , foldFreeAp\n  , hoistFreeAp\n  , analyzeFreeAp\n  ) where\n\nimport Prelude\n\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.List (List(..))\nimport Data.List.NonEmpty as NEL\nimport Data.Newtype (unwrap)\nimport Data.NonEmpty ((:|))\nimport Data.Tuple (Tuple(..))\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | The free applicative functor for a type constructor `f`.\ndata FreeAp f a\n  = Pure a\n  | Lift (f a)\n  | Ap (FreeAp f (Val -> a)) (FreeAp f Val)\n\ndata Val\n\n-- | Lift a value described by the type constructor `f` into\n-- | the free applicative functor.\nliftFreeAp :: forall f a. f a -> FreeAp f a\nliftFreeAp = Lift\n\ntype ApFunc g = { func :: g (Val -> Val), count :: Int }\ntype FuncStack g = List (ApFunc g)\ntype ValStack f = NEL.NonEmptyList (FreeAp f Val)\ntype Stack f g = Tuple (FuncStack g) (ValStack f)\n\n-- | Run a free applicative functor with a natural transformation from\n-- | the type constructor `f` to the applicative functor `g`.\nfoldFreeAp :: forall f g a. Applicative g => (f ~> g) -> FreeAp f a -> g a\nfoldFreeAp nat z =\n  unsafeToG $ go $ Tuple Nil (NEL.singleton $ unsafeToFVal z)\n  where\n  unsafeToG :: g Val -> g a\n  unsafeToG = unsafeCoerce\n\n  unsafeToFVal :: forall f' a'. FreeAp f' a' -> FreeAp f' Val\n  unsafeToFVal = unsafeCoerce\n\n  go :: Stack f g -> g Val\n  go (Tuple fStack (NEL.NonEmptyList (val :| vals))) =\n    case val of\n      Pure a -> case goApply fStack vals (pure a) of\n        Left x -> x\n        Right s -> go s\n      Lift a -> case goApply fStack vals (nat a) of\n        Left x -> x\n        Right s -> go s\n      Ap l r ->\n        let nextVals = NEL.NonEmptyList (r :| vals)\n        in go $ goLeft fStack nextVals nat l 1\n\ngoApply\n  :: forall f g\n  . Applicative g\n  => FuncStack g\n  -> List (FreeAp f Val)\n  -> g Val\n  -> Either (g Val) (Stack f g)\ngoApply fStack vals gVal =\n  case fStack of\n    Nil -> Left gVal\n    Cons f fs ->\n      let gRes = f.func <*> gVal\n      in if f.count == 1 then\n        case fs of\n          Nil ->\n            -- here vals must be empty\n            Left gRes\n          _ -> goApply fs vals gRes\n        else\n          case vals of\n            Nil -> Left gRes\n            Cons val vals' ->\n              Right $ Tuple\n                (Cons { func: unsafeToGFunc gRes, count: f.count - 1 } fs)\n                (NEL.NonEmptyList (val :| vals'))\n  where\n  unsafeToGFunc :: g Val -> g (Val -> Val)\n  unsafeToGFunc = unsafeCoerce\n\ngoLeft\n  :: forall f g\n  . Applicative g\n  => FuncStack g\n  -> ValStack f\n  -> (f ~> g)\n  -> FreeAp f (Val -> Val)\n  -> Int\n  -> Stack f g\ngoLeft fStack valStack nat func count = case func of\n  Pure a -> Tuple (Cons { func: pure a, count } fStack) valStack\n  Lift a -> Tuple (Cons { func: nat a, count } fStack) valStack\n  Ap l r -> goLeft fStack (NEL.cons r valStack) nat (unsafeToFunc l) (count + 1)\n  where\n  unsafeToFunc :: FreeAp f (Val -> Val -> Val) -> FreeAp f (Val -> Val)\n  unsafeToFunc = unsafeCoerce\n\n-- | Run a free applicative functor using the applicative instance for\n-- | the type constructor `f`.\nretractFreeAp :: forall f a. Applicative f => FreeAp f a -> f a\nretractFreeAp = foldFreeAp identity\n\n-- | Natural transformation from `FreeAp f a` to `FreeAp g a` given a\n-- | natural transformation from `f` to `g`.\nhoistFreeAp :: forall f g a. (f ~> g) -> FreeAp f a -> FreeAp g a\nhoistFreeAp f = foldFreeAp (f >>> liftFreeAp)\n\n-- | Perform monoidal analysis over the free applicative functor `f`.\nanalyzeFreeAp :: forall f m a. Monoid m => (forall b. f b -> m) -> FreeAp f a -> m\nanalyzeFreeAp k = unwrap <<< foldFreeAp (Const <<< k)\n\nmkAp :: forall f a b. FreeAp f (b -> a) -> FreeAp f b -> FreeAp f a\nmkAp fba fb = Ap (coerceFunc fba) (coerceValue fb)\n  where\n  coerceFunc :: FreeAp f (b -> a) -> FreeAp f (Val -> a)\n  coerceFunc = unsafeCoerce\n\n  coerceValue :: FreeAp f b -> FreeAp f Val\n  coerceValue = unsafeCoerce\n\ninstance functorFreeAp :: Functor (FreeAp f) where\n  map f x = mkAp (Pure f) x\n\ninstance applyFreeAp :: Apply (FreeAp f) where\n  apply fba fb = mkAp fba fb\n\ninstance applicativeFreeAp :: Applicative (FreeAp f) where\n  pure = Pure\n", "-- | This module defines a strict double-ended queue.\n-- |\n-- | The queue implementation is based on a pair of lists where all\n-- | operations require `O(1)` amortized time.\n-- |\n-- | However, any single `uncons` operation may run in `O(n)` time.\n-- |\n-- | See [Simple and Efficient Purely Functional Queues and Dequeues](http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp95queue.pdf) (Okasaki 1995)\nmodule Data.CatQueue\n  ( CatQueue(..)\n  , empty\n  , null\n  , singleton\n  , length\n  , cons\n  , snoc\n  , uncons\n  , unsnoc\n  , fromFoldable\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Foldable (class Foldable, foldMap, foldMapDefaultL, foldl, foldrDefault)\nimport Data.List (List(..), reverse)\nimport Data.List as L\nimport Data.Maybe (Maybe(..))\nimport Data.Traversable (class Traversable, sequenceDefault)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable, class Unfoldable1)\n\n-- | A strict double-ended queue (dequeue) representated using a pair of lists.\ndata CatQueue a = CatQueue (List a) (List a)\n\n-- | Create an empty queue.\n-- |\n-- | Running time: `O(1)`\nempty :: forall a. CatQueue a\nempty = CatQueue Nil Nil\n\n-- | Test whether a queue is empty.\n-- |\n-- | Running time: `O(1)`\nnull :: forall a. CatQueue a -> Boolean\nnull (CatQueue Nil Nil) = true\nnull _ = false\n\n-- | Create a queue containing a single element.\n-- |\n-- | Running time: `O(1)`\nsingleton :: forall a. a -> CatQueue a\nsingleton = snoc empty\n\n-- | Number of elements in queue.\n-- |\n-- | Running time: `O(n)` in length of queue.\nlength :: forall a. CatQueue a -> Int\nlength (CatQueue l r) = L.length l + L.length r\n\n-- | Append an element to the beginning of the queue, creating a new queue.\n-- |\n-- | Running time: `O(1)`\ncons :: forall a. a -> CatQueue a -> CatQueue a\ncons a (CatQueue l r) = CatQueue (Cons a l) r\n\n-- | Append an element to the end of the queue, creating a new queue.\n-- |\n-- | Running time: `O(1)`\nsnoc :: forall a. CatQueue a -> a -> CatQueue a\nsnoc (CatQueue l r) a = CatQueue l (Cons a r)\n\n-- | Decompose a queue into a `Tuple` of the first element and the rest of the queue.\n-- |\n-- | Running time: `O(1)`\n-- |\n-- | Note that any single operation may run in `O(n)`.\nuncons :: forall a. CatQueue a -> Maybe (Tuple a (CatQueue a))\nuncons (CatQueue Nil Nil) = Nothing\nuncons (CatQueue Nil r) = uncons (CatQueue (reverse r) Nil)\nuncons (CatQueue (Cons a as) r) = Just (Tuple a (CatQueue as r))\n\n-- | Decompose a queue into a `Tuple` of the last element and the rest of the queue.\n-- |\n-- | Running time: `O(1)`\n-- |\n-- | Note that any single operation may run in `O(n)`.\nunsnoc :: forall a. CatQueue a -> Maybe (Tuple a (CatQueue a))\nunsnoc (CatQueue l (Cons a as)) = Just (Tuple a (CatQueue l as))\nunsnoc (CatQueue Nil Nil) = Nothing\nunsnoc (CatQueue l Nil) = unsnoc (CatQueue Nil (reverse l))\n\n-- | Convert any `Foldable` into a `CatQueue`.\n-- |\n-- | Running time: `O(n)`\nfromFoldable :: forall f a. Foldable f => f a -> CatQueue a\nfromFoldable f = foldMap singleton f\n\ncqEq :: forall a. Eq a => CatQueue a -> CatQueue a -> Boolean\ncqEq = go\n  where\n    elemEq = eq :: (a -> a -> Boolean)\n    go xs ys = case uncons xs, uncons ys of\n      Just (Tuple x xs'), Just (Tuple y ys')\n        | x `elemEq` y -> go xs' ys'\n      Nothing, Nothing -> true\n      _      , _       -> false\n\ncqCompare :: forall a. Ord a => CatQueue a -> CatQueue a -> Ordering\ncqCompare = go\n  where\n    elemCompare = compare :: (a -> a -> Ordering)\n    go xs ys = case uncons xs, uncons ys of\n      Just (Tuple x xs'), Just (Tuple y ys') ->\n        case elemCompare x y of\n             EQ       -> go xs' ys'\n             ordering -> ordering\n      Just _,   Nothing -> GT\n      Nothing,  Just _  -> LT\n      Nothing,  Nothing -> EQ\n\ninstance eqCatQueue :: Eq a => Eq (CatQueue a) where\n  eq = cqEq\n\ninstance ordCatQueue :: Ord a => Ord (CatQueue a) where\n  compare = cqCompare\n\n-- | Running time: `O(n) in the length of the second queue`\ninstance semigroupCatQueue :: Semigroup (CatQueue a) where\n  append = foldl snoc\n\ninstance monoidCatQueue :: Monoid (CatQueue a) where\n  mempty = empty\n\ninstance showCatQueue :: Show a => Show (CatQueue a) where\n  show (CatQueue l r) = \"(CatQueue \" <> show l <> \" \" <> show r <> \")\"\n\ninstance foldableCatQueue :: Foldable CatQueue where\n  foldMap = foldMapDefaultL\n  foldr f = foldrDefault f\n  foldl f = go\n    where\n    go acc q = case uncons q of\n       Just (Tuple x xs) -> go (f acc x) xs\n       Nothing -> acc\n\ninstance unfoldable1CatQueue :: Unfoldable1 CatQueue where\n  unfoldr1 f b = go b empty\n    where\n      go source memo = case f source of\n        Tuple one Nothing -> snoc memo one\n        Tuple one (Just rest) -> go rest (snoc memo one)\n\ninstance unfoldableCatQueue :: Unfoldable CatQueue where\n  unfoldr f b = go b empty\n    where\n      go source memo = case f source of\n        Nothing -> memo\n        Just (Tuple one rest) -> go rest (snoc memo one)\n\ninstance traversableCatQueue :: Traversable CatQueue where\n  traverse f =\n    map (foldl snoc empty)\n    <<< foldl (\\acc -> lift2 snoc acc <<< f) (pure empty)\n  sequence = sequenceDefault\n\ninstance functorCatQueue :: Functor CatQueue where\n  map f (CatQueue l r) = CatQueue (map f l) (map f r)\n\ninstance applyCatQueue :: Apply CatQueue where\n  apply = ap\n\ninstance applicativeCatQueue :: Applicative CatQueue where\n  pure = singleton\n\ninstance bindCatQueue :: Bind CatQueue where\n  bind = flip foldMap\n\ninstance monadCatQueue :: Monad CatQueue\n\ninstance altCatQueue :: Alt CatQueue where\n  alt = append\n\ninstance plusCatQueue :: Plus CatQueue where\n  empty = empty\n\ninstance alternativeCatQueue :: Alternative CatQueue\n\ninstance monadPlusCatQueue :: MonadPlus CatQueue\n", "-- | This module defines a strict catenable list.\n-- |\n-- | The implementation is based on a queue where all operations require\n-- | `O(1)` amortized time.\n-- |\n-- | However, any single `uncons` operation may run in `O(n)` time.\n-- |\n-- | See [Purely Functional Data Structures](http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf) (Okasaki 1996)\nmodule Data.CatList\n  ( CatList(..)\n  , empty\n  , null\n  , singleton\n  , length\n  , append\n  , cons\n  , snoc\n  , uncons\n  , fromFoldable\n  ) where\n\nimport Prelude hiding (append)\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.CatQueue as Q\nimport Data.Foldable (class Foldable, foldMapDefaultL)\nimport Data.Foldable as Foldable\nimport Data.List as L\nimport Data.Maybe (Maybe(..))\nimport Data.Traversable (sequence, traverse, class Traversable)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable)\nimport Data.Unfoldable1 (class Unfoldable1)\n\n-- | A strict catenable list.\n-- |\n-- | `CatList` may be empty, represented by `CatNil`.\n-- |\n-- | `CatList` may be non-empty, represented by `CatCons`. The `CatCons`\n-- | data constructor takes the first element of the list and a queue of\n-- | `CatList`.\ndata CatList a = CatNil | CatCons a (Q.CatQueue (CatList a))\n\n-- | Create an empty catenable list.\n-- |\n-- | Running time: `O(1)`\nempty :: forall a. CatList a\nempty = CatNil\n\n-- | Test whether a catenable list is empty.\n-- |\n-- | Running time: `O(1)`\nnull :: forall a. CatList a -> Boolean\nnull CatNil = true\nnull _ = false\n\n-- | Number of elements in queue.\n-- |\n-- | Running time: `O(n)` in length of queue.\nlength :: forall a. CatList a -> Int\nlength = Foldable.length\n\n-- | Append all elements of a catenable list to the end of another\n-- | catenable list, create a new catenable list.\n-- |\n-- | Running time: `O(1)`\nappend :: forall a. CatList a -> CatList a -> CatList a\nappend = link\n\n-- | Append an element to the beginning of the catenable list, creating a new\n-- | catenable list.\n-- |\n-- | Running time: `O(1)`\ncons :: forall a. a -> CatList a -> CatList a\ncons a cat = append (CatCons a Q.empty) cat\n\n-- | Create a catenable list with a single item.\n-- |\n-- | Running time: `O(1)`\nsingleton :: forall a. a -> CatList a\nsingleton a = cons a CatNil\n\n-- | Append an element to the end of the catenable list, creating a new\n-- | catenable list.\n-- |\n-- | Running time: `O(1)`\nsnoc :: forall a. CatList a -> a -> CatList a\nsnoc cat a = append cat (CatCons a Q.empty)\n\n-- | Decompose a catenable list into a `Tuple` of the first element and\n-- | the rest of the catenable list.\n-- |\n-- | Running time: `O(1)`\n-- |\n-- | Note that any single operation may run in `O(n)`.\nuncons :: forall a. CatList a -> Maybe (Tuple a (CatList a))\nuncons CatNil = Nothing\nuncons (CatCons a q) = Just (Tuple a (if Q.null q then CatNil else (foldr link CatNil q)))\n\n-- | Links two catenable lists by making appending the queue in the\n-- | first catenable list to the second catenable list. This operation\n-- | creates a new catenable list.\n-- |\n-- | Running time: `O(1)`\nlink :: forall a. CatList a -> CatList a -> CatList a\nlink CatNil cat = cat\nlink cat CatNil = cat\nlink (CatCons a q) cat = CatCons a (Q.snoc q cat)\n\n-- | Tail recursive version of foldr on `CatList`.\n-- |\n-- | Ensures foldl on `List` is tail-recursive.\nfoldr :: forall a. (CatList a -> CatList a -> CatList a) -> CatList a -> Q.CatQueue (CatList a) -> CatList a\nfoldr k b q = go q L.Nil\n  where\n  go :: Q.CatQueue (CatList a) -> L.List (CatList a -> CatList a) -> CatList a\n  go xs ys = case Q.uncons xs of\n                  Nothing -> foldl (\\x i -> i x) b ys\n                  Just (Tuple a rest) -> go rest (L.Cons (k a) ys)\n\n  foldl :: forall b c. (c -> b -> c) -> c -> L.List b -> c\n  foldl _ c L.Nil = c\n  foldl k' c (L.Cons b' as) = foldl k' (k' c b') as\n\n-- | Convert any `Foldable` into a `CatList`.\n-- |\n-- | Running time: `O(n)`\nfromFoldable :: forall f. Foldable f => f ~> CatList\nfromFoldable f = Foldable.foldMap singleton f\n\nfoldMap :: forall a m. Monoid m => (a -> m) -> CatList a -> m\nfoldMap _ CatNil = mempty\nfoldMap f (CatCons a q) =\n  let d = if Q.null q then CatNil else (foldr link CatNil q)\n  in f a <> foldMap f d\n\n-- | Running time: `O(1)`\ninstance semigroupCatList :: Semigroup (CatList a) where\n  append = append\n\ninstance monoidCatList :: Monoid (CatList a) where\n  mempty = CatNil\n\ninstance showCatList :: Show a => Show (CatList a) where\n  show CatNil = \"CatNil\"\n  show (CatCons a as) = \"(CatList \" <> show a <> \" \" <> show as <> \")\"\n\ninstance foldableCatList :: Foldable CatList where\n  foldMap = foldMapDefaultL\n  foldr f s l = Foldable.foldrDefault f s l\n  foldl f = go\n    where\n    go acc q = case uncons q of\n       Just (Tuple x xs) -> go (f acc x) xs\n       Nothing -> acc\n\ninstance unfoldableCatList :: Unfoldable CatList where\n  unfoldr f b = go b CatNil\n    where\n      go source memo = case f source of\n        Nothing -> memo\n        Just (Tuple one rest) -> go rest (snoc memo one)\n\ninstance unfoldable1CatList :: Unfoldable1 CatList where\n  unfoldr1 f b = go b CatNil\n    where\n      go source memo = case f source of\n        Tuple one Nothing -> snoc memo one\n        Tuple one (Just rest) -> go rest (snoc memo one)\n\ninstance traversableCatList :: Traversable CatList where\n  traverse _ CatNil = pure CatNil\n  traverse f (CatCons a q) =\n    let d = if Q.null q then CatNil else (foldr link CatNil q)\n    in cons <$> f a <*> traverse f d\n  sequence CatNil = pure CatNil\n  sequence (CatCons a q) =\n    let d = if Q.null q then CatNil else (foldr link CatNil q)\n    in cons <$> a <*> sequence d\n\ninstance functorCatList :: Functor CatList where\n  map _ CatNil = CatNil\n  map f (CatCons a q) =\n    let d = if Q.null q then CatNil else (foldr link CatNil q)\n    in f a `cons` map f d\n\ninstance applyCatList :: Apply CatList where\n  apply = ap\n\ninstance applicativeCatList :: Applicative CatList where\n  pure = singleton\n\ninstance bindCatList :: Bind CatList where\n  bind = flip foldMap\n\ninstance monadCatList :: Monad CatList\n\ninstance altCatList :: Alt CatList where\n  alt = append\n\ninstance plusCatList :: Plus CatList where\n  empty = empty\n\ninstance alternativeCatList :: Alternative CatList\n\ninstance monadPlusCatList :: MonadPlus CatList\n", "module Control.Monad.Free\n  ( Free\n  , suspendF\n  , wrap\n  , liftF\n  , hoistFree\n  , foldFree\n  , substFree\n  , runFree\n  , runFreeM\n  , resume\n  , resume'\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM)\nimport Control.Monad.Trans.Class (class MonadTrans)\n\nimport Data.CatList (CatList, empty, snoc, uncons)\nimport Data.Either (Either(..))\nimport Data.Eq (class Eq1, eq1)\nimport Data.Foldable (class Foldable, foldMap, foldl, foldr)\nimport Data.Maybe (Maybe(..))\nimport Data.Ord (class Ord1, compare1)\nimport Data.Traversable (class Traversable, traverse)\nimport Data.Tuple (Tuple(..))\n\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | The free monad for a type constructor `f`.\n-- |\n-- | Implemented in the spirit of [Reflection without Remorse](http://okmij.org/ftp/Haskell/zseq.pdf),\n-- | the free monad is represented using a sequential data structure in\n-- | order to overcome the quadratic complexity of left-associated binds\n-- | and traversal through the free monad structure.\ndata Free f a = Free (FreeView f Val Val) (CatList (ExpF f))\n\nnewtype ExpF f = ExpF (Val -> Free f Val)\n\ndata FreeView f a b = Return a | Bind (f b) (b -> Free f a)\n\ndata Val\n\ninstance eqFree :: (Functor f, Eq1 f, Eq a) => Eq (Free f a) where\n  eq x y = case resume x, resume y of\n    Left fa, Left fb -> eq1 fa fb\n    Right a, Right b -> a == b\n    _, _ -> false\n\ninstance eq1Free :: (Functor f, Eq1 f) => Eq1 (Free f) where\n  eq1 = eq\n\ninstance ordFree :: (Functor f, Ord1 f, Ord a) => Ord (Free f a) where\n  compare x y = case resume x, resume y of\n    Left fa, Left fb -> compare1 fa fb\n    Left _, _ -> LT\n    _, Left _ -> GT\n    Right a, Right b -> compare a b\n\ninstance ord1Free :: (Functor f, Ord1 f) => Ord1 (Free f) where\n  compare1 = compare\n\ninstance freeFunctor :: Functor (Free f) where\n  map k f = pure <<< k =<< f\n\ninstance freeBind :: Bind (Free f) where\n  bind (Free v s) k = Free v (snoc s (ExpF (unsafeCoerceBind k)))\n    where\n    unsafeCoerceBind :: forall a b. (a -> Free f b) -> Val -> Free f Val\n    unsafeCoerceBind = unsafeCoerce\n\ninstance freeApplicative :: Applicative (Free f) where\n  pure = fromView <<< Return\n\ninstance freeApply :: Apply (Free f) where\n  apply = ap\n\ninstance freeMonad :: Monad (Free f)\n\ninstance freeMonadTrans :: MonadTrans Free where\n  lift = liftF\n\ninstance freeMonadRec :: MonadRec (Free f) where\n  tailRecM k a = k a >>= case _ of\n    Loop b -> tailRecM k b\n    Done r -> pure r\n\ninstance foldableFree :: (Functor f, Foldable f) => Foldable (Free f) where\n  foldMap f = go\n    where\n    go = resume >>> case _ of\n      Left fa -> foldMap go fa\n      Right a -> f a\n  foldl f = go\n    where\n    go r = resume >>> case _  of\n      Left fa -> foldl go r fa\n      Right a -> f r a\n  foldr f = go\n    where\n    go r = resume >>> case _ of\n      Left fa -> foldr (flip go) r fa\n      Right a -> f a r\n\ninstance traversableFree :: Traversable f => Traversable (Free f) where\n  traverse f = go\n    where\n    go = resume >>> case _ of\n      Left fa -> join <<< liftF <$> traverse go fa\n      Right a -> pure <$> f a\n  sequence tma = traverse identity tma\n\ninstance semigroupFree :: Semigroup a => Semigroup (Free f a) where\n  append = lift2 append\n\ninstance monoidFree :: Monoid a => Monoid (Free f a) where\n  mempty = pure mempty\n  \n-- | Lift an impure value described by the generating type constructor `f` into\n-- | the free monad.\nliftF :: forall f. f ~> Free f\nliftF f = fromView (Bind (unsafeCoerceF f) (pure <<< unsafeCoerceVal))\n  where\n  unsafeCoerceF :: forall a. f a -> f Val\n  unsafeCoerceF = unsafeCoerce\n\n  unsafeCoerceVal :: forall a. Val -> a\n  unsafeCoerceVal = unsafeCoerce\n\n-- | Add a layer.\nwrap :: forall f a. f (Free f a) -> Free f a\nwrap f = fromView (Bind (unsafeCoerceF f) unsafeCoerceVal)\n  where\n  unsafeCoerceF :: forall b. f (Free f b) -> f Val\n  unsafeCoerceF = unsafeCoerce\n\n  unsafeCoerceVal :: forall b. Val -> Free f b\n  unsafeCoerceVal = unsafeCoerce\n\n-- | Suspend a value given the applicative functor `f` into the free monad.\nsuspendF :: forall f. Applicative f => Free f ~> Free f\nsuspendF f = wrap (pure f)\n\n-- | Use a natural transformation to change the generating type constructor of a\n-- | free monad.\nhoistFree :: forall f g. (f ~> g) -> Free f ~> Free g\nhoistFree k = substFree (liftF <<< k)\n\n-- | Run a free monad with a natural transformation from the type constructor `f`\n-- | to the tail-recursive monad `m`. See the `MonadRec` type class for more\n-- | details.\nfoldFree :: forall f m. MonadRec m => (f ~> m) -> Free f ~> m\nfoldFree k = tailRecM go\n  where\n  go :: forall a. Free f a -> m (Step (Free f a) a)\n  go f = case toView f of\n    Return a -> Done <$> pure a\n    Bind g i -> (Loop <<< i) <$> k g\n\n-- | Like `foldFree`, but for folding into some other Free monad without the\n-- | overhead that `MonadRec` incurs.\nsubstFree :: forall f g. (f ~> Free g) -> Free f ~> Free g\nsubstFree k = go\n  where\n  go :: Free f ~> Free g\n  go f = case toView f of\n    Return a -> pure a\n    Bind g i -> k g >>= go <$> i\n\n-- | Run a free monad with a function that unwraps a single layer of the functor\n-- | `f` at a time.\nrunFree :: forall f a. Functor f => (f (Free f a) -> Free f a) -> Free f a -> a\nrunFree k = go\n  where\n  go :: Free f a -> a\n  go f = case toView f of\n    Return a -> a\n    Bind g i -> go (k (i <$> g))\n\n-- | Run a free monad with a function mapping a functor `f` to a tail-recursive\n-- | monad `m`. See the `MonadRec` type class for more details.\nrunFreeM\n  :: forall f m a\n   . Functor f\n  => MonadRec m\n  => (f (Free f a) -> m (Free f a))\n  -> Free f a\n  -> m a\nrunFreeM k = tailRecM go\n  where\n  go :: Free f a -> m (Step (Free f a) a)\n  go f = case toView f of\n    Return a -> Done <$> pure a\n    Bind g i -> Loop <$> k (i <$> g)\n\n-- | Unwraps a single layer of the functor `f`.\nresume\n  :: forall f a\n   . Functor f\n  => Free f a\n  -> Either (f (Free f a)) a\nresume = resume' (\\g i -> Left (i <$> g)) Right\n\n-- | Unwraps a single layer of `f`, providing the continuation.\nresume'\n  :: forall f a r\n   . (forall b. f b -> (b -> Free f a) -> r)\n  -> (a -> r)\n  -> Free f a\n  -> r\nresume' k j f = case toView f of\n  Return a -> j a\n  Bind g i -> k g i\n\nfromView :: forall f a. FreeView f a Val -> Free f a\nfromView f = Free (unsafeCoerceFreeView f) empty\n  where\n  unsafeCoerceFreeView :: FreeView f a Val -> FreeView f Val Val\n  unsafeCoerceFreeView = unsafeCoerce\n\ntoView :: forall f a. Free f a -> FreeView f a Val\ntoView (Free v s) =\n  case v of\n    Return a ->\n      case uncons s of\n        Nothing ->\n          Return (unsafeCoerceVal a)\n        Just (Tuple h t) ->\n          toView (unsafeCoerceFree (concatF ((runExpF h) a) t))\n    Bind f k ->\n      Bind f (\\a -> unsafeCoerceFree (concatF (k a) s))\n  where\n  concatF :: Free f Val -> CatList (ExpF f) -> Free f Val\n  concatF (Free v' l) r = Free v' (l <> r)\n\n  runExpF :: ExpF f -> (Val -> Free f Val)\n  runExpF (ExpF k) = k\n\n  unsafeCoerceFree :: Free f Val -> Free f a\n  unsafeCoerceFree = unsafeCoerce\n\n  unsafeCoerceVal :: Val -> a\n  unsafeCoerceVal = unsafeCoerce\n", "module Effect.Aff.Class where\n\nimport Prelude\nimport Control.Monad.Cont.Trans (ContT)\nimport Control.Monad.Except.Trans (ExceptT)\nimport Control.Monad.List.Trans (ListT)\nimport Control.Monad.Maybe.Trans (MaybeT)\nimport Control.Monad.Reader.Trans (ReaderT)\nimport Control.Monad.RWS.Trans (RWST)\nimport Control.Monad.State.Trans (StateT)\nimport Control.Monad.Trans.Class (lift)\nimport Control.Monad.Writer.Trans (WriterT)\nimport Effect.Aff (Aff)\nimport Effect.Class (class MonadEffect)\n\nclass MonadEffect m <= MonadAff m where\n  liftAff :: Aff ~> m\n\ninstance monadAffAff :: MonadAff Aff where\n  liftAff = identity\n\ninstance monadAffContT :: MonadAff m => MonadAff (ContT r m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffExceptT :: MonadAff m => MonadAff (ExceptT e m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffListT :: MonadAff m => MonadAff (ListT m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffMaybe :: MonadAff m => MonadAff (MaybeT m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffReader :: MonadAff m => MonadAff (ReaderT r m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffRWS :: (MonadAff m, Monoid w) => MonadAff (RWST r w s m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffState :: MonadAff m => MonadAff (StateT s m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffWriter :: (MonadAff m, Monoid w) => MonadAff (WriterT w m) where\n  liftAff = lift <<< liftAff\n", "module Halogen.Query.ChildQuery where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Halogen.Data.Slot (SlotStorage)\nimport Unsafe.Coerce (unsafeCoerce)\n\ndata ChildQueryBox :: Row Type -> Type -> Type\ndata ChildQueryBox (ps :: Row Type) a\n\ndata ChildQuery ps g o a f b =\n  ChildQuery\n    (forall slot m. Applicative m => (slot g o -> m (Maybe b)) -> SlotStorage ps slot -> m (f b))\n    (g b)\n    (f b -> a)\n\ninstance functorChildQuery :: Functor (ChildQueryBox ps) where\n  map f = unChildQueryBox \\(ChildQuery u q k) ->\n    mkChildQueryBox (ChildQuery u q (f <<< k))\n\nmkChildQueryBox\n  :: forall ps g o a f b\n   . ChildQuery ps g o a f b\n  -> ChildQueryBox ps a\nmkChildQueryBox = unsafeCoerce\n\nunChildQueryBox\n  :: forall ps a r\n   . (forall g o f b. ChildQuery ps g o a f b -> r)\n  -> ChildQueryBox ps a\n  -> r\nunChildQueryBox = unsafeCoerce\n", "export function reallyUnsafeRefEq(a) {\n  return function (b) {\n    return a === b;\n  };\n}\n", "module Unsafe.Reference\n  ( unsafeRefEq\n  , reallyUnsafeRefEq\n  , UnsafeRefEq(..)\n  , UnsafeRefEqFallback(..)\n  ) where\n\nimport Prelude\n\n-- | Compares two values of the same type using strict (`===`) equality.\nunsafeRefEq :: forall a. a -> a -> Boolean\nunsafeRefEq = reallyUnsafeRefEq\n\n-- | Compares two values of different types using strict (`===`) equality.\nforeign import reallyUnsafeRefEq :: forall a b. a -> b -> Boolean\n\n-- | The `Eq` instance is defined by `unsafeRefEq`.\nnewtype UnsafeRefEq a = UnsafeRefEq a\n\ninstance eqUnsafeRefEq :: Eq (UnsafeRefEq a) where\n  eq (UnsafeRefEq l) (UnsafeRefEq r) = unsafeRefEq l r\n\n-- | The `Eq` instance first checks `unsafeRefEq`, if `false` falls back to\n-- | the underlying `Eq` instance.\nnewtype UnsafeRefEqFallback a = UnsafeRefEqFallback a\n\ninstance eqUnsafeRefEqFallback ::\n  Eq a =>\n  Eq (UnsafeRefEqFallback a) where\n  eq (UnsafeRefEqFallback l) (UnsafeRefEqFallback r) =\n    unsafeRefEq l r || l == r\n\n", "module Halogen.Subscription\n  ( SubscribeIO(..)\n  , create\n  , Listener\n  , notify\n  , Emitter\n  , makeEmitter\n  , Subscription\n  , subscribe\n  , unsubscribe\n  , fold\n  , filter\n  , fix\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Plus (class Plus)\nimport Data.Array (deleteBy)\nimport Data.Foldable (traverse_)\nimport Data.Functor.Contravariant (class Contravariant)\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Ref as Ref\nimport Effect.Unsafe (unsafePerformEffect)\nimport Safe.Coerce (coerce)\nimport Unsafe.Reference (unsafeRefEq)\n\n-- | A paired `Listener` and `Emitter` produced with the `create` function.\ntype SubscribeIO a =\n  { listener :: Listener a\n  , emitter :: Emitter a\n  }\n\n-- | Create a paired `Listener` and `Emitter`, where you can push values to\n-- | the listener and subscribe to values from the emitter.\n-- |\n-- | ```purs\n-- | { emitter, listener } <- create\n-- |\n-- | -- Push values into the listener:\n-- | notify listener \"hello\"\n-- |\n-- | -- Subscribe to outputs from the emitter with a callback:\n-- | subscription <- subscribe emitter \\value ->\n-- |   Console.log value\n-- |\n-- | -- Unsubscribe at any time:\n-- | unsubscribe subscription\n-- | ```\ncreate :: forall a. Effect (SubscribeIO a)\ncreate = do\n  subscribers <- Ref.new []\n  pure\n    { emitter: Emitter \\k -> do\n        Ref.modify_ (_ <> [k]) subscribers\n        pure $ Subscription do\n          Ref.modify_ (deleteBy unsafeRefEq k) subscribers\n    , listener: Listener \\a -> do\n        Ref.read subscribers >>= traverse_ \\k -> k a\n    }\n\n-- | An `Emitter` represents a collection of discrete occurrences of an event;\n-- | conceptually, an emitter is a possibly-infinite list of values.\n-- |\n-- | Emitters are created from real events like timers or mouse clicks and can\n-- | be combined or transformed with the functions and instances in this module.\n-- |\n-- | Emitters are consumed by providing a callback via the `subscribe` function.\nnewtype Emitter a = Emitter ((a -> Effect Unit) -> Effect Subscription)\n\ninstance functorEmitter :: Functor Emitter where\n  map f (Emitter e) = Emitter \\k -> e (k <<< f)\n\ninstance applyEmitter :: Apply Emitter where\n  apply (Emitter e1) (Emitter e2) = Emitter \\k -> do\n    latestA <- Ref.new Nothing\n    latestB <- Ref.new Nothing\n    Subscription c1 <- e1 \\a -> do\n      Ref.write (Just a) latestA\n      Ref.read latestB >>= traverse_ (k <<< a)\n    Subscription c2 <- e2 \\b -> do\n      Ref.write (Just b) latestB\n      Ref.read latestA >>= traverse_ (k <<< (_ $ b))\n    pure (Subscription (c1 *> c2))\n\ninstance applicativeEmitter :: Applicative Emitter where\n  pure a = Emitter \\k -> do\n    k a\n    pure (Subscription (pure unit))\n\ninstance altEmitter :: Alt Emitter where\n  alt (Emitter f) (Emitter g) = Emitter \\k -> do\n    Subscription c1 <- f k\n    Subscription c2 <- g k\n    pure (Subscription (c1 *> c2))\n\ninstance plusEmitter :: Plus Emitter where\n  empty = Emitter \\_ -> pure (Subscription (pure unit))\n\ninstance alternativeEmitter :: Alternative Emitter\n\ninstance semigroupEmitter :: Semigroup a => Semigroup (Emitter a) where\n  append = lift2 append\n\ninstance monoidEmitter :: Monoid a => Monoid (Emitter a) where\n  mempty = Emitter mempty\n\n-- | Make an `Emitter` from a function which accepts a callback and returns an\n-- | unsubscription function.\n-- |\n-- | Note: You should use `create` unless you need explicit control over\n-- | unsubscription.\nmakeEmitter\n  :: forall a\n   . ((a -> Effect Unit) -> Effect (Effect Unit))\n  -> Emitter a\nmakeEmitter = coerce\n\n-- | Conceptually, a `Listener` represents an input source to an `Emitter`. You\n-- | can push a value to its paired emitter with the `notify` function.\nnewtype Listener a = Listener (a -> Effect Unit)\n\ninstance contravariantListener :: Contravariant Listener where\n  cmap f (Listener g) = coerce (g <<< f)\n\n-- | Push a value to the `Emitter` paired with the provided `Listener` argument.\n-- |\n-- | ```purs\n-- | -- Create an emitter and listener with `create`:\n-- | { emitter, listener } <- create\n-- |\n-- | -- Then, push values to the emitter via the listener with `notify`:\n-- | notify listener \"hello\"\n-- | ```\nnotify :: forall a. Listener a -> a -> Effect Unit\nnotify (Listener f) a = f a\n\n-- | A `Subscription` results from subscribing to an `Emitter` with `subscribe`;\n-- | the subscription can be ended at any time with `unsubscribe`.\nnewtype Subscription = Subscription (Effect Unit)\n\nderive newtype instance semigroupSubscription :: Semigroup Subscription\nderive newtype instance monoidSubscription :: Monoid Subscription\n\n-- | Subscribe to an `Emitter` by providing a callback to run on values produced\n-- | by the emitter:\n-- |\n-- | ```purs\n-- | -- Produce an emitter / listener pair with `create`:\n-- | { emitter, listener } <- create\n-- |\n-- | -- Then, subscribe to the emitter by providing a callback:\n-- | subscription <- subscribe emitter \\emitted ->\n-- |   doSomethingWith emitted\n-- |\n-- | -- End the subscription at any time with `unsubscribe`:\n-- | unsubscribe subscription\n-- | ```\nsubscribe\n  :: forall r a\n   . Emitter a\n  -> (a -> Effect r)\n  -> Effect Subscription\nsubscribe (Emitter e) k = e (void <<< k)\n\n-- | End a subscription to an `Emitter`.\nunsubscribe :: Subscription -> Effect Unit\nunsubscribe (Subscription unsub) = unsub\n\n-- | Fold over values received from some `Emitter`, creating a new `Emitter`.\nfold :: forall a b. (a -> b -> b) -> Emitter a -> b -> Emitter b\nfold f (Emitter e) b = Emitter \\k -> do\n  result <- Ref.new b\n  e \\a -> Ref.modify (f a) result >>= k\n\n-- | Create an `Emitter` which only fires when a predicate holds.\nfilter :: forall a. (a -> Boolean) -> Emitter a -> Emitter a\nfilter p (Emitter e) = Emitter \\k -> e \\a -> if p a then k a else pure unit\n\n-- | Compute a fixed point.\nfix :: forall i o. (Emitter i -> { input :: Emitter i, output :: Emitter o }) -> Emitter o\nfix f = Emitter \\k -> do\n  Subscription c1 <- subscribe input (notify listener)\n  Subscription c2 <- subscribe output k\n  pure (Subscription (c1 *> c2))\n  where\n  { emitter, listener } = unsafePerformEffect create\n  { input, output } = f emitter\n", "module Halogen.Query.HalogenM where\n\nimport Prelude\n\nimport Control.Applicative.Free (FreeAp, liftFreeAp, hoistFreeAp)\nimport Control.Monad.Error.Class (class MonadThrow, throwError)\nimport Control.Monad.Free (Free, hoistFree, liftF)\nimport Control.Monad.Reader.Class (class MonadAsk, ask)\nimport Control.Monad.Rec.Class (class MonadRec, tailRecM, Step(..))\nimport Control.Monad.State.Class (class MonadState)\nimport Control.Monad.Trans.Class (class MonadTrans)\nimport Control.Monad.Writer.Class (class MonadTell, tell)\nimport Control.Parallel.Class (class Parallel)\nimport Data.Bifunctor (lmap)\nimport Data.FoldableWithIndex (foldrWithIndex)\nimport Data.Map (Map)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Newtype (class Newtype, over)\nimport Data.Symbol (class IsSymbol)\nimport Data.Traversable (traverse)\nimport Data.Tuple (Tuple)\nimport Effect.Aff.Class (class MonadAff, liftAff)\nimport Effect.Class (class MonadEffect, liftEffect)\nimport Halogen.Data.Slot (Slot)\nimport Halogen.Data.Slot as Slot\nimport Halogen.Query.ChildQuery as CQ\nimport Halogen.Query.Input (RefLabel)\nimport Halogen.Subscription as HS\nimport Prim.Row as Row\nimport Type.Proxy (Proxy)\nimport Web.DOM (Element)\n\n-- | The Halogen component eval algebra.\n-- |\n-- | - `state` is the component's state\n-- | - `action` is the type of actions; events internal to the component that\n-- |   can be evaluated\n-- | - `slots` is the set of slots for addressing child components\n-- | - `output` is the type of output messages the component can raise\n-- | - `m` is the monad used during evaluation\n-- | - `a` is the result of the HalogenF expression (see HalogenM for an example).\ndata HalogenF state action slots output m a\n  = State (state -> Tuple a state)\n  | Subscribe (SubscriptionId -> HS.Emitter action) (SubscriptionId -> a)\n  | Unsubscribe SubscriptionId a\n  | Lift (m a)\n  | ChildQuery (CQ.ChildQueryBox slots a)\n  | Raise output a\n  | Par (HalogenAp state action slots output m a)\n  | Fork (HalogenM state action slots output m Unit) (ForkId -> a)\n  | Join ForkId a\n  | Kill ForkId a\n  | GetRef RefLabel (Maybe Element -> a)\n\ninstance functorHalogenF :: Functor m => Functor (HalogenF state action slots output m) where\n  map f = case _ of\n    State k -> State (lmap f <<< k)\n    Subscribe fes k -> Subscribe fes (f <<< k)\n    Unsubscribe sid a -> Unsubscribe sid (f a)\n    Lift q -> Lift (map f q)\n    ChildQuery cq -> ChildQuery (map f cq)\n    Raise o a -> Raise o (f a)\n    Par pa -> Par (map f pa)\n    Fork hmu k -> Fork hmu (f <<< k)\n    Join fid a -> Join fid (f a)\n    Kill fid a -> Kill fid (f a)\n    GetRef p k -> GetRef p (f <<< k)\n\n-- | The Halogen component eval effect monad.\n-- |\n-- | - `state` is the component's state\n-- | - `action` is the type of actions; events internal to the component that\n-- |   can be evaluated\n-- | - `slots` is the set of slots for addressing child components\n-- | - `output` is the type of output messages the component can raise\n-- | - `m` is the monad used during evaluation\n-- | - `a` is the result of the HalogenM expression. Use the following pattern:\n-- |     `handleAction :: Action -> H.HalogenM State Action Slots Output m Unit`\n-- |     `handleQuery  :: forall a. Query a -> H.HalogenM State Action Slots Output m (Maybe a)`\nnewtype HalogenM state action slots output m a = HalogenM (Free (HalogenF state action slots output m) a)\n\nderive newtype instance functorHalogenM :: Functor (HalogenM state action slots output m)\nderive newtype instance applyHalogenM :: Apply (HalogenM state action slots output m)\nderive newtype instance applicativeHalogenM :: Applicative (HalogenM state action slots output m)\nderive newtype instance bindHalogenM :: Bind (HalogenM state action slots output m)\nderive newtype instance monadHalogenM :: Monad (HalogenM state action slots output m)\nderive newtype instance semigroupHalogenM :: Semigroup a => Semigroup (HalogenM state action slots output m a)\nderive newtype instance monoidHalogenM :: Monoid a => Monoid (HalogenM state action slots output m a)\n\ninstance monadEffectHalogenM :: MonadEffect m => MonadEffect (HalogenM state action slots output m) where\n  liftEffect = HalogenM <<< liftF <<< Lift <<< liftEffect\n\ninstance monadAffHalogenM :: MonadAff m => MonadAff (HalogenM state action slots output m) where\n  liftAff = HalogenM <<< liftF <<< Lift <<< liftAff\n\ninstance parallelHalogenM :: Parallel (HalogenAp state action slots output m) (HalogenM state action slots output m) where\n  parallel = HalogenAp <<< liftFreeAp\n  sequential = HalogenM <<< liftF <<< Par\n\ninstance monadTransHalogenM :: MonadTrans (HalogenM state action slots o) where\n  lift = HalogenM <<< liftF <<< Lift\n\ninstance monadRecHalogenM :: MonadRec (HalogenM state action slots output m) where\n  tailRecM k a = k a >>= case _ of\n    Loop x -> tailRecM k x\n    Done y -> pure y\n\ninstance monadStateHalogenM :: MonadState state (HalogenM state action slots output m) where\n  state = HalogenM <<< liftF <<< State\n\ninstance monadAskHalogenM :: MonadAsk r m => MonadAsk r (HalogenM state action slots output m) where\n  ask = HalogenM $ liftF $ Lift ask\n\ninstance monadTellHalogenM :: MonadTell w m => MonadTell w (HalogenM state action slots output m) where\n  tell = HalogenM <<< liftF <<< Lift <<< tell\n\ninstance monadThrowHalogenM :: MonadThrow e m => MonadThrow e (HalogenM state action slots output m) where\n  throwError = HalogenM <<< liftF <<< Lift <<< throwError\n\n-- | An applicative-only version of `HalogenM` to allow for parallel evaluation.\nnewtype HalogenAp state action slots output m a = HalogenAp (FreeAp (HalogenM state action slots output m) a)\n\nderive instance newtypeHalogenAp :: Newtype (HalogenAp state query slots output m a) _\nderive newtype instance functorHalogenAp :: Functor (HalogenAp state query slots output m)\nderive newtype instance applyHalogenAp :: Apply (HalogenAp state query slots output m)\nderive newtype instance applicativeHalogenAp :: Applicative (HalogenAp state query slots output m)\n\n-- | Raises an output message for the component.\nraise :: forall state action slots output m. output -> HalogenM state action slots output m Unit\nraise o = HalogenM $ liftF $ Raise o unit\n\n-- | Sends a query to a child of a component at the specified slot.\nquery\n  :: forall state action output m label slots query output' slot a _1\n   . Row.Cons label (Slot query output' slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> slot\n  -> query a\n  -> HalogenM state action slots output m (Maybe a)\nquery label p q = HalogenM $ liftF $ ChildQuery $ CQ.mkChildQueryBox $\n  CQ.ChildQuery (\\k -> maybe (pure Nothing) k <<< Slot.lookup label p) q identity\n\n-- | Sends a query to all children of a component at a given slot label.\nqueryAll\n  :: forall state action output m label slots query output' slot a _1\n   . Row.Cons label (Slot query output' slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> query a\n  -> HalogenM state action slots output m (Map slot a)\nqueryAll label q =\n  HalogenM $ liftF $ ChildQuery $ CQ.mkChildQueryBox $\n    CQ.ChildQuery (\\k -> map catMapMaybes <<< traverse k <<< Slot.slots label) q identity\n  where\n  catMapMaybes :: forall k v. Ord k => Map k (Maybe v) -> Map k v\n  catMapMaybes = foldrWithIndex (\\k v acc -> maybe acc (flip (Map.insert k) acc) v) Map.empty\n\n-- | The ID value associated with a subscription. Allows the subscription to be\n-- | stopped at a later time.\nnewtype SubscriptionId = SubscriptionId Int\n\nderive newtype instance eqSubscriptionId :: Eq SubscriptionId\nderive newtype instance ordSubscriptionId :: Ord SubscriptionId\n\n-- | Subscribes a component to an `Emitter`.\n-- |\n-- | When a component is disposed of any active subscriptions will automatically\n-- | be stopped and no further subscriptions will be possible during\n-- | finalization.\nsubscribe :: forall state action slots output m. HS.Emitter action -> HalogenM state action slots output m SubscriptionId\nsubscribe es = HalogenM $ liftF $ Subscribe (\\_ -> es) identity\n\n-- | An alternative to `subscribe`, intended for subscriptions that unsubscribe\n-- | themselves. Instead of returning the `SubscriptionId` from `subscribe'`, it\n-- | is passed into an `Emitter` constructor. This allows emitted queries\n-- | to include the `SubscriptionId`, rather than storing it in the state of the\n-- | component.\n-- |\n-- | When a component is disposed of any active subscriptions will automatically\n-- | be stopped and no further subscriptions will be possible during\n-- | finalization.\nsubscribe' :: forall state action slots output m. (SubscriptionId -> HS.Emitter action) -> HalogenM state action slots output m Unit\nsubscribe' esc = HalogenM $ liftF $ Subscribe esc (const unit)\n\n-- | Unsubscribes a component from a subscription. If the subscription associated\n-- | with the ID has already ended this will have no effect.\nunsubscribe :: forall state action slots output m. SubscriptionId -> HalogenM state action slots output m Unit\nunsubscribe sid = HalogenM $ liftF $ Unsubscribe sid unit\n\n-- | The ID value associated with a forked process. Allows the fork to be killed\n-- | at a later time.\nnewtype ForkId = ForkId Int\n\nderive newtype instance eqForkId :: Eq ForkId\nderive newtype instance ordForkId :: Ord ForkId\n\n-- | Starts a `HalogenM` process running independent from the current `eval`\n-- | \"thread\".\n-- |\n-- | A commonly use case for `fork` is in component initializers where some\n-- | async action is started. Normally all interaction with the component will\n-- | be blocked until the initializer completes, but if the async action is\n-- | `fork`ed instead, the initializer can complete synchronously while the\n-- | async action continues.\n-- |\n-- | Some care needs to be taken when using a `fork` that can modify the\n-- | component state, as it's easy for the forked process to \"clobber\" the state\n-- | (overwrite some or all of it with an old value) by mistake.\n-- |\n-- | When a component is disposed of any active forks will automatically\n-- | be killed. New forks can be started during finalization but there will be\n-- | no means of killing them.\nfork :: forall state action slots output m. HalogenM state action slots output m Unit -> HalogenM state action slots output m ForkId\nfork hmu = HalogenM $ liftF $ Fork hmu identity\n\n-- | Joins a forked process. Attempting to join a forked process that has\n-- | already ended will result in eval continuing immediately. Attempting\n-- | to join a forked process that has been killed will also terminate the\n-- | current eval.\njoin :: forall state action slots output m. ForkId -> HalogenM state action slots output m Unit\njoin fid = HalogenM $ liftF $ Join fid unit\n\n-- | Kills a forked process if it is still running. Attempting to kill a forked\n-- | process that has already ended will have no effect.\nkill :: forall state action slots output m. ForkId -> HalogenM state action slots output m Unit\nkill fid = HalogenM $ liftF $ Kill fid unit\n\n-- | Retrieves an `Element` value that is associated with a `Ref` in the\n-- | rendered output of a component. If there is no currently rendered value for\n-- | the requested ref this will return `Nothing`.\ngetRef :: forall state action slots output m. RefLabel -> HalogenM state action slots output m (Maybe Element)\ngetRef p = HalogenM $ liftF $ GetRef p identity\n\nimapState\n  :: forall state state' action slots output m a\n   . (state -> state')\n  -> (state' -> state)\n  -> HalogenM state action slots output m a\n  -> HalogenM state' action slots output m a\nimapState f f' (HalogenM h) = HalogenM (hoistFree go h)\n  where\n  go :: HalogenF state action slots output m ~> HalogenF state' action slots output m\n  go = case _ of\n    State fs -> State (map f <<< fs <<< f')\n    Subscribe fes k -> Subscribe fes k\n    Unsubscribe sid a -> Unsubscribe sid a\n    Lift q -> Lift q\n    ChildQuery cq -> ChildQuery cq\n    Raise o a -> Raise o a\n    Par p -> Par (over HalogenAp (hoistFreeAp (imapState f f')) p)\n    Fork hmu k -> Fork (imapState f f' hmu) k\n    Join fid a -> Join fid a\n    Kill fid a -> Kill fid a\n    GetRef p k -> GetRef p k\n\nmapAction\n  :: forall state action action' slots output m a\n   . Functor m\n  => (action -> action')\n  -> HalogenM state action slots output m a\n  -> HalogenM state action' slots output m a\nmapAction f (HalogenM h) = HalogenM (hoistFree go h)\n  where\n  go :: HalogenF state action slots output m ~> HalogenF state action' slots output m\n  go = case _ of\n    State fs -> State fs\n    Subscribe fes k -> Subscribe (map f <<< fes) k\n    Unsubscribe sid a -> Unsubscribe sid a\n    Lift q -> Lift q\n    ChildQuery cq -> ChildQuery cq\n    Raise o a -> Raise o a\n    Par p -> Par (over HalogenAp (hoistFreeAp (mapAction f)) p)\n    Fork hmu k -> Fork (mapAction f hmu) k\n    Join fid a -> Join fid a\n    Kill fid a -> Kill fid a\n    GetRef p k -> GetRef p k\n\nmapOutput\n  :: forall state action slots output output' m a\n   . (output -> output')\n  -> HalogenM state action slots output m a\n  -> HalogenM state action slots output' m a\nmapOutput f (HalogenM h) = HalogenM (hoistFree go h)\n  where\n  go :: HalogenF state action slots output m ~> HalogenF state action slots output' m\n  go = case _ of\n    State fs -> State fs\n    Subscribe fes k -> Subscribe fes k\n    Unsubscribe sid a -> Unsubscribe sid a\n    Lift q -> Lift q\n    ChildQuery cq -> ChildQuery cq\n    Raise o a -> Raise (f o) a\n    Par p -> Par (over HalogenAp (hoistFreeAp (mapOutput f)) p)\n    Fork hmu k -> Fork (mapOutput f hmu) k\n    Join fid a -> Join fid a\n    Kill fid a -> Kill fid a\n    GetRef p k -> GetRef p k\n\nhoist\n  :: forall state action slots output m m' a\n   . Functor m'\n  => (m ~> m')\n  -> HalogenM state action slots output m a\n  -> HalogenM state action slots output m' a\nhoist nat (HalogenM fa) = HalogenM (hoistFree go fa)\n  where\n  go :: HalogenF state action slots output m ~> HalogenF state action slots output m'\n  go = case _ of\n    State f -> State f\n    Subscribe fes k -> Subscribe fes k\n    Unsubscribe sid a -> Unsubscribe sid a\n    Lift q -> Lift (nat q)\n    ChildQuery cq -> ChildQuery cq\n    Raise o a -> Raise o a\n    Par p -> Par (over HalogenAp (hoistFreeAp (hoist nat)) p)\n    Fork hmu k -> Fork (hoist nat hmu) k\n    Join fid a -> Join fid a\n    Kill fid a -> Kill fid a\n    GetRef p k -> GetRef p k\n", "module Halogen.Query.HalogenQ where\n\nimport Prelude\n\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Coyoneda (Coyoneda)\n\ndata HalogenQ query action input a\n  = Initialize a\n  | Finalize a\n  | Receive input a\n  | Action action a\n  | Query (Coyoneda query a) (Unit -> a)\n\ninstance bifunctorHalogenQ :: Bifunctor (HalogenQ query action) where\n  bimap f g = case _ of\n    Initialize a -> Initialize (g a)\n    Finalize a -> Finalize (g a)\n    Receive i a -> Receive (f i) (g a)\n    Action action a -> Action action (g a)\n    Query fa k -> Query (map g fa) (map g k)\n\nderive instance functorHalogenQ :: Functor (HalogenQ query action input)\n", "module Halogen.VDom.Thunk\n  ( Thunk\n  , buildThunk\n  , runThunk\n  , hoist\n  , mapThunk\n  , thunked\n  , thunk1\n  , thunk2\n  , thunk3\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried as Fn\nimport Effect.Uncurried as EFn\nimport Halogen.VDom as V\nimport Halogen.VDom.Machine as M\nimport Halogen.VDom.Util as Util\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Node (Node)\n\nforeign import data ThunkArg \u2237 Type\n\nforeign import data ThunkId \u2237 Type\n\ndata Thunk :: (Type -> Type) -> Type -> Type\ndata Thunk f i = Thunk ThunkId (Fn.Fn2 ThunkArg ThunkArg Boolean) (ThunkArg \u2192 f i) ThunkArg\n\nunsafeThunkId \u2237 \u2200 a. a \u2192 ThunkId\nunsafeThunkId = unsafeCoerce\n\ninstance functorThunk \u2237 Functor f \u21D2 Functor (Thunk f) where\n  map f (Thunk a b c d) = Thunk a b (c >>> map f) d\n\nhoist \u2237 \u2200 f g. (f ~> g) \u2192 Thunk f ~> Thunk g\nhoist = mapThunk\n\nmapThunk \u2237 \u2200 f g i j. (f i -> g j) \u2192 Thunk f i -> Thunk g j\nmapThunk k (Thunk a b c d) = Thunk a b (c >>> k) d\n\nthunk \u2237 \u2200 a f i. Fn.Fn4 ThunkId (Fn.Fn2 a a Boolean) (a \u2192 f i) a (Thunk f i)\nthunk = Fn.mkFn4 \\tid eqFn f a \u2192\n  Thunk tid\n    (unsafeCoerce eqFn \u2237 Fn.Fn2 ThunkArg ThunkArg Boolean)\n    (unsafeCoerce f \u2237 ThunkArg \u2192 f i)\n    (unsafeCoerce a \u2237 ThunkArg)\n\nthunked \u2237 \u2200 a f i. (a \u2192 a \u2192 Boolean) \u2192 (a \u2192 f i) \u2192 a \u2192 Thunk f i\nthunked eqFn f =\n  let\n    tid = unsafeThunkId { f }\n    eqFn' = Fn.mkFn2 eqFn\n  in\n    \\a \u2192 Fn.runFn4 thunk tid eqFn' f a\n\nthunk1 \u2237 \u2200 a f i. Fn.Fn2 (a \u2192 f i) a (Thunk f i)\nthunk1 = Fn.mkFn2 \\f a \u2192 Fn.runFn4 thunk (unsafeThunkId f) Util.refEq f a\n\nthunk2 \u2237 \u2200 a b f i. Fn.Fn3 (a \u2192 b \u2192 f i) a b (Thunk f i)\nthunk2 =\n  let\n    eqFn = Fn.mkFn2 \\a b \u2192\n      Fn.runFn2 Util.refEq a._1 b._1 &&\n      Fn.runFn2 Util.refEq a._2 b._2\n  in\n    Fn.mkFn3 \\f a b \u2192\n      Fn.runFn4 thunk (unsafeThunkId f) eqFn (\\{ _1, _2 } \u2192 f _1 _2) { _1: a, _2: b }\n\nthunk3 \u2237 \u2200 a b c f i. Fn.Fn4 (a \u2192 b \u2192 c \u2192 f i) a b c (Thunk f i)\nthunk3 =\n  let\n    eqFn = Fn.mkFn2 \\a b \u2192\n      Fn.runFn2 Util.refEq a._1 b._1 &&\n      Fn.runFn2 Util.refEq a._2 b._2 &&\n      Fn.runFn2 Util.refEq a._3 b._3\n  in\n    Fn.mkFn4 \\f a b c \u2192\n      Fn.runFn4 thunk (unsafeThunkId f) eqFn (\\{ _1, _2, _3 } \u2192 f _1 _2 _3) { _1: a, _2: b, _3: c }\n\nrunThunk \u2237 \u2200 f i. Thunk f i \u2192 f i\nrunThunk (Thunk _ _ render arg) = render arg\n\nunsafeEqThunk \u2237 \u2200 f i. Fn.Fn2 (Thunk f i) (Thunk f i) Boolean\nunsafeEqThunk = Fn.mkFn2 \\(Thunk a1 b1 _ d1) (Thunk a2 b2 _ d2) \u2192\n  Fn.runFn2 Util.refEq a1 a2 &&\n  Fn.runFn2 Util.refEq b1 b2 &&\n  Fn.runFn2 b1 d1 d2\n\ntype ThunkState :: (Type -> Type) -> Type -> Type -> Type -> Type\ntype ThunkState f i a w =\n  { thunk \u2237 Thunk f i\n  , vdom \u2237 M.Step (V.VDom a w) Node\n  }\n\nbuildThunk\n  \u2237 \u2200 f i a w\n  . (f i \u2192 V.VDom a w)\n  \u2192 V.VDomSpec a w\n  \u2192 V.Machine (Thunk f i) Node\nbuildThunk toVDom = renderThunk\n  where\n  renderThunk \u2237 V.VDomSpec a w \u2192 V.Machine (Thunk f i) Node\n  renderThunk spec = EFn.mkEffectFn1 \\t \u2192 do\n    vdom \u2190 EFn.runEffectFn1 (V.buildVDom spec) (toVDom (runThunk t))\n    pure $ M.mkStep $ M.Step (M.extract vdom) { thunk: t, vdom } patchThunk haltThunk\n\n  patchThunk \u2237 EFn.EffectFn2 (ThunkState f i a w) (Thunk f i) (V.Step (Thunk f i) Node)\n  patchThunk = EFn.mkEffectFn2 \\state t2 \u2192 do\n    let { vdom: prev, thunk: t1 } = state\n    if Fn.runFn2 unsafeEqThunk t1 t2\n      then pure $ M.mkStep $ M.Step (M.extract prev) state patchThunk haltThunk\n      else do\n        vdom \u2190 EFn.runEffectFn2 M.step prev (toVDom (runThunk t2))\n        pure $ M.mkStep $ M.Step (M.extract vdom) { vdom, thunk: t2 } patchThunk haltThunk\n\n  haltThunk \u2237 EFn.EffectFn1 (ThunkState f i a w) Unit\n  haltThunk = EFn.mkEffectFn1 \\state \u2192 do\n    EFn.runEffectFn1 M.halt state.vdom\n", "module Halogen.Component\n  ( Component\n  , ComponentSpec\n  , mkComponent\n  , unComponent\n  , hoist\n  , EvalSpec\n  , mkEval\n  , defaultEval\n  , ComponentSlotBox\n  , ComponentSlot(..)\n  , componentSlot\n  , ComponentSlotSpec\n  , mkComponentSlot\n  , unComponentSlot\n  , hoistSlot\n  ) where\n\nimport Prelude\n\nimport Data.Bifunctor (bimap, lmap)\nimport Data.Coyoneda (unCoyoneda)\nimport Data.Foldable (traverse_)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Symbol (class IsSymbol)\nimport Data.Tuple (Tuple)\nimport Halogen.Data.Slot (Slot, SlotStorage)\nimport Halogen.Data.Slot as Slot\nimport Halogen.HTML.Core as HC\nimport Halogen.Query.HalogenM (HalogenM)\nimport Halogen.Query.HalogenM as HM\nimport Halogen.Query.HalogenQ (HalogenQ(..))\nimport Halogen.VDom.Thunk (Thunk)\nimport Halogen.VDom.Thunk as Thunk\nimport Prim.Row as Row\nimport Type.Proxy (Proxy)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | The \"public\" type for a component, with details of the component internals\n-- | existentially hidden.\n-- |\n-- |   `HTML`\n-- | - `query` is the query algebra; the requests that can be made of the\n-- |   component\n-- | - `input` is the input value that will be received when the parent of\n-- |   this component renders\n-- | - `output` is the type of messages the component can raise\n-- | - `m` is the effect monad used during evaluation\ndata Component\n  (query :: Type -> Type)\n  (input :: Type)\n  (output :: Type)\n  (m :: Type -> Type)\n\n-- | The spec for a component.\n-- |\n-- | The type variables involved:\n-- | - `state` is the component's state\n-- | - `query` is the query algebra; the requests that can be made of the\n-- |   component\n-- | - `action` is the type of actions; messages internal to the component that\n-- |   can be evaluated\n-- | - `slots` is the set of slots for addressing child components\n-- | - `input` is the input value that will be received when the parent of\n-- |   this component renders\n-- | - `output` is the type of messages the component can raise\n-- | - `m` is the effect monad used during evaluation\n-- |\n-- | The values in the record:\n-- | - `initialState` is a function that accepts an input value and produces the\n-- |   state the component will start with. If the input value is unused\n-- |   (`Unit`), or irrelevant to the state construction, this will often be\n-- |   `const ?someInitialStateValue`.\n-- | - `render` is a function that accepts the component's current state and\n-- |   produces a value to render (`HTML` usually). The rendered output can\n-- |   raise actions that will be handled in `eval`.\n-- | - `eval` is a function that handles the `HalogenQ` algebra that deals with\n-- |   component lifecycle, handling actions, and responding to requests.\ntype ComponentSpec state query action slots input output m =\n  { initialState :: input -> state\n  , render :: state -> HC.HTML (ComponentSlot slots m action) action\n  , eval :: HalogenQ query action input ~> HalogenM state action slots output m\n  }\n\n-- | Constructs a [`Component`](#t:Component) from a [`ComponentSpec`](#t:ComponentSpec).\nmkComponent\n  :: forall state query action slots input output m\n   . ComponentSpec state query action slots input output m\n  -> Component query input output m\nmkComponent = unsafeCoerce\n\n-- | Exposes the inner details of a [`Component`](#t:Component) to a function\n-- | to produce a new result.\n-- |\n-- | The hidden details will not be allowed to be revealed in the result\n-- | of the function - if any of the hidden types (state, action, set of slots)\n-- | appear in the result, the compiler will complain about an escaped skolem.\nunComponent\n  :: forall query input output m a\n   . (forall state action slots. ComponentSpec state query action slots input output m -> a)\n  -> Component query input output m\n  -> a\nunComponent = unsafeCoerce\n\n-- | Changes the [`Component`](#t:Component)'s `m` type. A use case for this\n-- | might be to interpret some `Free` monad as `Aff` so the component can be\n-- | used with `runUI`.\nhoist\n  :: forall query input output m m'\n   . Functor m'\n  => (m ~> m')\n  -> Component query input output m\n  -> Component query input output m'\nhoist nat = unComponent \\c ->\n  mkComponent\n    { initialState: c.initialState\n    , render: lmap (hoistSlot nat) <<< c.render\n    , eval: HM.hoist nat <<< c.eval\n    }\n\n-- | The spec record that `mkEval` accepts to construct a component `eval`\n-- | function.\n-- |\n-- | It's not a requirement to use `mkEval`, and sometimes it's preferrable\n-- | to write a component `eval` function from scratch, but often `mkEval` is\n-- | more convenient for common cases.\n-- |\n-- | See below for more details about `mkEval` and `defaultEval`.\ntype EvalSpec state query action slots input output m =\n  { handleAction :: action -> HalogenM state action slots output m Unit\n  , handleQuery :: forall a. query a -> HalogenM state action slots output m (Maybe a)\n  , receive :: input -> Maybe action\n  , initialize :: Maybe action\n  , finalize :: Maybe action\n  }\n\n-- | A default value for `mkEval` that will result in an `eval` that nothing at\n-- | all - all incoming actions and queries will be ignored, and no receiver,\n-- | initializer, or finalizer will be specified.\n-- |\n-- | Usually this will be used with record update syntax to override fields to\n-- | specify things as needed. If a component only needs to handle actions,\n-- | for instance, a usage might be something like this:\n-- |\n-- | ```purescript\n-- | H.mkComponent\n-- |   { initialState\n-- |   , render\n-- |   , eval: H.mkEval (H.defaultEval { handleAction = ?handleAction })\n-- |   }\n-- | ```\ndefaultEval :: forall state query action slots input output m. EvalSpec state query action slots input output m\ndefaultEval =\n  { handleAction: const (pure unit)\n  , handleQuery: const (pure Nothing)\n  , receive: const Nothing\n  , initialize: Nothing\n  , finalize: Nothing\n  }\n\n-- | Accepts an `EvalSpec` to produce an `eval` function for a component. For\n-- | example:\n-- |\n-- | ```purescript\n-- | -- use `defaultEval` and override fields selectively\n-- | H.mkEval (H.defaultEval { handleAction = ?handleAction })\n-- |\n-- | -- or specify all the fields in the `EvalSpec`\n-- | H.mkEval\n-- |   { handleAction: ?handleAction\n-- |   , handleQuery: ?handleQuery\n-- |   , receive: ?receive\n-- |   , initialize: ?initialize\n-- |   , finalize: ?finalize\n-- |   }\n-- | ```\nmkEval\n  :: forall state query action slots input output m a\n   . EvalSpec state query action slots input output m\n  -> HalogenQ query action input a\n  -> HalogenM state action slots output m a\nmkEval args = case _ of\n  Initialize a ->\n    traverse_ args.handleAction args.initialize $> a\n  Finalize a ->\n    traverse_ args.handleAction args.finalize $> a\n  Receive i a ->\n    traverse_ args.handleAction (args.receive i) $> a\n  Action action a ->\n    args.handleAction action $> a\n  Query req f ->\n    unCoyoneda (\\g -> map (maybe (f unit) g) <<< args.handleQuery) req\n\n-- | A slot for a child component in a component's rendered content.\ndata ComponentSlotBox\n  (slots :: Row Type)\n  (m :: Type -> Type)\n  (action :: Type)\n\ninstance functorComponentSlotBox :: Functor (ComponentSlotBox slots m) where\n  map f = unComponentSlot \\slot ->\n    mkComponentSlot $ slot { output = map f <$> slot.output }\n\ndata ComponentSlot slots m action\n  = ComponentSlot (ComponentSlotBox slots m action)\n  | ThunkSlot (Thunk (HC.HTML (ComponentSlot slots m action)) action)\n\ninstance functorComponentSlot :: Functor (ComponentSlot slots m) where\n  map f = case _ of\n    ComponentSlot box -> ComponentSlot (map f box)\n    ThunkSlot thunk -> ThunkSlot (Thunk.mapThunk (bimap (map f) f) thunk)\n\n-- | Constructs a [`ComponentSlot`](#t:ComponentSlot).\n-- |\n-- | Takes:\n-- | - the slot address label\n-- | - the slot address index\n-- | - the component for the slot\n-- | - the input value to pass to the component\n-- | - a function mapping outputs from the component to a query in the parent\ncomponentSlot\n  :: forall query input output slots m action label slot _1\n   . Row.Cons label (Slot query output slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> slot\n  -> Component query input output m\n  -> input\n  -> (output -> Maybe action)\n  -> ComponentSlotBox slots m action\ncomponentSlot label p comp input output =\n  mkComponentSlot\n    { get: Slot.lookup label p\n    , pop: Slot.pop label p\n    , set: Slot.insert label p\n    , component: comp\n    , input: input\n    , output\n    }\n\n-- | The internal representation used for a [`ComponentSlot`](#t:ComponentSlot).\ntype ComponentSlotSpec query input output slots m action =\n  { get :: forall slot. SlotStorage slots slot -> Maybe (slot query output)\n  , pop :: forall slot. SlotStorage slots slot -> Maybe (Tuple (slot query output) (SlotStorage slots slot))\n  , set :: forall slot. slot query output -> SlotStorage slots slot -> SlotStorage slots slot\n  , component :: Component query input output m\n  , input :: input\n  , output :: output -> Maybe action\n  }\n\n-- | Constructs [`ComponentSlotBox`](#t:ComponentSlot) from a [`ComponentSlotSpec`](#t:ComponentSlotSpec).\nmkComponentSlot\n  :: forall query input output slots m action\n   . ComponentSlotSpec query input output slots m action\n  -> ComponentSlotBox slots m action\nmkComponentSlot = unsafeCoerce\n\n-- | Exposes the inner details of a [`ComponentSlot`](#t:ComponentSlot) to a\n-- | function to produce a new result.\n-- |\n-- |  The hidden details will not be allowed to be revealed in the result\n-- | of the function - if any of the hidden types (state, action, set of slots)\n-- | appear in the result, the compiler will complain about an escaped skolem.\nunComponentSlot\n  :: forall slots m action a\n   . (forall query input output. ComponentSlotSpec query input output slots m action -> a)\n  -> ComponentSlotBox slots m action\n  -> a\nunComponentSlot = unsafeCoerce\n\n-- | Changes the [`ComponentSlot`](#t:ComponentSlot)'s `m` type.\nhoistSlot\n  :: forall slots m m' action\n   . Functor m'\n  => (m ~> m')\n  -> ComponentSlot slots m action\n  -> ComponentSlot slots m' action\nhoistSlot nat = case _ of\n  ComponentSlot cs ->\n    cs # unComponentSlot \\slot ->\n      ComponentSlot $ mkComponentSlot $ slot { component = hoist nat slot.component }\n  ThunkSlot t ->\n    ThunkSlot $ Thunk.hoist (lmap (hoistSlot nat)) t\n", "module Halogen.HTML.Elements\n  ( Node\n  , Leaf\n  , element\n  , elementNS\n  , keyed\n  , keyedNS\n  , withKeys\n  , withKeys_\n  , a\n  , a_\n  , abbr\n  , abbr_\n  , address\n  , address_\n  , area\n  , article\n  , article_\n  , aside\n  , aside_\n  , audio\n  , audio_\n  , b\n  , b_\n  , base\n  , bdi\n  , bdi_\n  , bdo\n  , bdo_\n  , blockquote\n  , blockquote_\n  , body\n  , body_\n  , br\n  , br_\n  , button\n  , button_\n  , canvas\n  , caption\n  , caption_\n  , cite\n  , cite_\n  , code\n  , code_\n  , col\n  , colgroup\n  , colgroup_\n  , command\n  , datalist\n  , datalist_\n  , dd\n  , dd_\n  , del\n  , del_\n  , details\n  , details_\n  , dfn\n  , dfn_\n  , dialog\n  , dialog_\n  , div\n  , div_\n  , dl\n  , dl_\n  , dt\n  , dt_\n  , em\n  , em_\n  , embed\n  , embed_\n  , fieldset\n  , fieldset_\n  , figcaption\n  , figcaption_\n  , figure\n  , figure_\n  , footer\n  , footer_\n  , form\n  , form_\n  , h1\n  , h1_\n  , h2\n  , h2_\n  , h3\n  , h3_\n  , h4\n  , h4_\n  , h5\n  , h5_\n  , h6\n  , h6_\n  , head\n  , head_\n  , header\n  , header_\n  , hr\n  , hr_\n  , html\n  , html_\n  , i\n  , i_\n  , iframe\n  , img\n  , input\n  , ins\n  , ins_\n  , kbd\n  , kbd_\n  , label\n  , label_\n  , legend\n  , legend_\n  , li\n  , li_\n  , link\n  , main\n  , main_\n  , map\n  , map_\n  , mark\n  , mark_\n  , menu\n  , menu_\n  , menuitem\n  , menuitem_\n  , meta\n  , meter\n  , meter_\n  , nav\n  , nav_\n  , noscript\n  , noscript_\n  , object\n  , object_\n  , ol\n  , ol_\n  , optgroup\n  , optgroup_\n  , option\n  , option_\n  , output\n  , output_\n  , p\n  , p_\n  , param\n  , pre\n  , pre_\n  , progress\n  , progress_\n  , q\n  , q_\n  , rp\n  , rp_\n  , rt\n  , rt_\n  , ruby\n  , ruby_\n  , samp\n  , samp_\n  , script\n  , script_\n  , section\n  , section_\n  , select\n  , select_\n  , small\n  , small_\n  , source\n  , span\n  , span_\n  , strong\n  , strong_\n  , style\n  , style_\n  , sub\n  , sub_\n  , summary\n  , summary_\n  , sup\n  , sup_\n  , table\n  , table_\n  , tbody\n  , tbody_\n  , td\n  , td_\n  , textarea\n  , tfoot\n  , tfoot_\n  , th\n  , th_\n  , thead\n  , thead_\n  , time\n  , time_\n  , title\n  , title_\n  , tr\n  , tr_\n  , track\n  , u\n  , u_\n  , ul\n  , ul_\n  , var\n  , var_\n  , video\n  , video_\n  , wbr\n  ) where\n\nimport Prelude ((#), (>>>), pure)\nimport Data.Maybe (Maybe(Nothing))\nimport Data.Tuple (Tuple)\n\nimport DOM.HTML.Indexed as I\n\nimport Halogen.HTML.Core (ElemName(..), HTML(..), Namespace, Prop)\nimport Halogen.HTML.Core as Core\nimport Halogen.HTML.Properties (IProp)\nimport Halogen.Query.Input (Input)\nimport Halogen.VDom as VDom\n\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | An HTML element that admits children.\ntype Node r w i = Array (IProp r i) -> Array (HTML w i) -> HTML w i\n\n-- | An HTML element that does not admit children.\ntype Leaf r w i = Array (IProp r i) -> HTML w i\n\n-- | Creates an HTML element that expects indexed properties.\nelement :: forall r w i. ElemName -> Array (IProp r i) -> Array (HTML w i) -> HTML w i\nelement =\n  Core.element Nothing #\n    ( unsafeCoerce\n        :: (ElemName -> Array (Prop i) -> Array (HTML w i) -> HTML w i)\n        -> ElemName\n        -> Array (IProp r i)\n        -> Array (HTML w i)\n        -> HTML w i\n    )\n\n-- | Creates a Namespaced HTML element that expects indexed properties.\nelementNS :: forall r w i. Namespace -> ElemName -> Array (IProp r i) -> Array (HTML w i) -> HTML w i\nelementNS =\n  pure >>> Core.element >>>\n    ( unsafeCoerce\n        :: (ElemName -> Array (Prop i) -> Array (HTML w i) -> HTML w i)\n        -> ElemName\n        -> Array (IProp r i)\n        -> Array (HTML w i)\n        -> HTML w i\n    )\n\n-- | Creates an HTML element that expects indexed properties, with keyed\n-- | children.\nkeyed :: forall r w i. ElemName -> Array (IProp r i) -> Array (Tuple String (HTML w i)) -> HTML w i\nkeyed =\n  Core.keyed Nothing #\n    ( unsafeCoerce\n        :: (ElemName -> Array (Prop i) -> Array (Tuple String (HTML w i)) -> HTML w i)\n        -> ElemName\n        -> Array (IProp r i)\n        -> Array (Tuple String (HTML w i))\n        -> HTML w i\n    )\n\n-- | Creates a Namespaced HTML element that expects indexed properties, with\n-- | keyed children.\nkeyedNS :: forall r w i. Namespace -> ElemName -> Array (IProp r i) -> Array (Tuple String (HTML w i)) -> HTML w i\nkeyedNS =\n  pure >>> Core.keyed >>>\n    ( unsafeCoerce\n        :: (ElemName -> Array (Prop i) -> Array (Tuple String (HTML w i)) -> HTML w i)\n        -> ElemName\n        -> Array (IProp r i)\n        -> Array (Tuple String (HTML w i))\n        -> HTML w i\n    )\n\nwithKeys :: forall r w i. (Array (IProp r i) -> Array (HTML w i) -> HTML w i) -> Array (IProp r i) -> Array (Tuple String (HTML w i)) -> HTML w i\nwithKeys ctor props children =\n  case ctor props [] of\n    HTML (VDom.Elem x y z _) -> HTML (VDom.Keyed x y z (coe children))\n    h -> h\n  where\n  coe :: Array (Tuple String (HTML w i)) -> Array (Tuple String (VDom.VDom (Array (Prop (Input i))) w))\n  coe = unsafeCoerce\n\nwithKeys_ :: forall w i. (Array (HTML w i) -> HTML w i) -> Array (Tuple String (HTML w i)) -> HTML w i\nwithKeys_ ctor children =\n  case ctor [] of\n    HTML (VDom.Elem x y z _) -> HTML (VDom.Keyed x y z (coe children))\n    h -> h\n  where\n  coe :: Array (Tuple String (HTML w i)) -> Array (Tuple String (VDom.VDom (Array (Prop (Input i))) w))\n  coe = unsafeCoerce\n\na :: forall w i. Node I.HTMLa w i\na = element (ElemName \"a\")\n\na_ :: forall w i. Array (HTML w i) -> HTML w i\na_ = a []\n\nabbr :: forall w i. Node I.HTMLabbr w i\nabbr = element (ElemName \"abbr\")\n\nabbr_ :: forall w i. Array (HTML w i) -> HTML w i\nabbr_ = abbr []\n\naddress :: forall w i. Node I.HTMLaddress w i\naddress = element (ElemName \"address\")\n\naddress_ :: forall w i. Array (HTML w i) -> HTML w i\naddress_ = address []\n\narea :: forall w i. Leaf I.HTMLarea w i\narea props = element (ElemName \"area\") props []\n\narticle :: forall w i. Node I.HTMLarticle w i\narticle = element (ElemName \"article\")\n\narticle_ :: forall w i. Array (HTML w i) -> HTML w i\narticle_ = article []\n\naside :: forall w i. Node I.HTMLaside w i\naside = element (ElemName \"aside\")\n\naside_ :: forall w i. Array (HTML w i) -> HTML w i\naside_ = aside []\n\naudio :: forall w i. Node I.HTMLaudio w i\naudio = element (ElemName \"audio\")\n\naudio_ :: forall w i. Array (HTML w i) -> HTML w i\naudio_ = audio []\n\nb :: forall w i. Node I.HTMLb w i\nb = element (ElemName \"b\")\n\nb_ :: forall w i. Array (HTML w i) -> HTML w i\nb_ = b []\n\nbase :: forall w i. Leaf I.HTMLbase w i\nbase props = element (ElemName \"base\") props []\n\nbdi :: forall w i. Node I.HTMLbdi w i\nbdi = element (ElemName \"bdi\")\n\nbdi_ :: forall w i. Array (HTML w i) -> HTML w i\nbdi_ = bdi []\n\nbdo :: forall w i. Node I.HTMLbdo w i\nbdo = element (ElemName \"bdo\")\n\nbdo_ :: forall w i. Array (HTML w i) -> HTML w i\nbdo_ = bdo []\n\nblockquote :: forall w i. Node I.HTMLblockquote w i\nblockquote = element (ElemName \"blockquote\")\n\nblockquote_ :: forall w i. Array (HTML w i) -> HTML w i\nblockquote_ = blockquote []\n\nbody :: forall w i. Node I.HTMLbody w i\nbody = element (ElemName \"body\")\n\nbody_ :: forall w i. Array (HTML w i) -> HTML w i\nbody_ = body []\n\nbr :: forall w i. Leaf I.HTMLbr w i\nbr props = element (ElemName \"br\") props []\n\nbr_ :: forall w i. HTML w i\nbr_ = br []\n\nbutton :: forall w i. Node I.HTMLbutton w i\nbutton = element (ElemName \"button\")\n\nbutton_ :: forall w i. Array (HTML w i) -> HTML w i\nbutton_ = button []\n\ncanvas :: forall w i. Leaf I.HTMLcanvas w i\ncanvas props = element (ElemName \"canvas\") props []\n\ncaption :: forall w i. Node I.HTMLcaption w i\ncaption = element (ElemName \"caption\")\n\ncaption_ :: forall w i. Array (HTML w i) -> HTML w i\ncaption_ = caption []\n\ncite :: forall w i. Node I.HTMLcite w i\ncite = element (ElemName \"cite\")\n\ncite_ :: forall w i. Array (HTML w i) -> HTML w i\ncite_ = cite []\n\ncode :: forall w i. Node I.HTMLcode w i\ncode = element (ElemName \"code\")\n\ncode_ :: forall w i. Array (HTML w i) -> HTML w i\ncode_ = code []\n\ncol :: forall w i. Leaf I.HTMLcol w i\ncol props = element (ElemName \"col\") props []\n\ncolgroup :: forall w i. Node I.HTMLcolgroup w i\ncolgroup = element (ElemName \"colgroup\")\n\ncolgroup_ :: forall w i. Array (HTML w i) -> HTML w i\ncolgroup_ = colgroup []\n\ncommand :: forall w i. Leaf I.HTMLcommand w i\ncommand props = element (ElemName \"command\") props []\n\ndatalist :: forall w i. Node I.HTMLdatalist w i\ndatalist = element (ElemName \"datalist\")\n\ndatalist_ :: forall w i. Array (HTML w i) -> HTML w i\ndatalist_ = datalist []\n\ndd :: forall w i. Node I.HTMLdd w i\ndd = element (ElemName \"dd\")\n\ndd_ :: forall w i. Array (HTML w i) -> HTML w i\ndd_ = dd []\n\ndel :: forall w i. Node I.HTMLdel w i\ndel = element (ElemName \"del\")\n\ndel_ :: forall w i. Array (HTML w i) -> HTML w i\ndel_ = del []\n\ndetails :: forall w i. Node I.HTMLdetails w i\ndetails = element (ElemName \"details\")\n\ndetails_ :: forall w i. Array (HTML w i) -> HTML w i\ndetails_ = details []\n\ndfn :: forall w i. Node I.HTMLdfn w i\ndfn = element (ElemName \"dfn\")\n\ndfn_ :: forall w i. Array (HTML w i) -> HTML w i\ndfn_ = dfn []\n\ndialog :: forall w i. Node I.HTMLdialog w i\ndialog = element (ElemName \"dialog\")\n\ndialog_ :: forall w i. Array (HTML w i) -> HTML w i\ndialog_ = dialog []\n\ndiv :: forall w i. Node I.HTMLdiv w i\ndiv = element (ElemName \"div\")\n\ndiv_ :: forall w i. Array (HTML w i) -> HTML w i\ndiv_ = div []\n\ndl :: forall w i. Node I.HTMLdl w i\ndl = element (ElemName \"dl\")\n\ndl_ :: forall w i. Array (HTML w i) -> HTML w i\ndl_ = dl []\n\ndt :: forall w i. Node (I.HTMLdt) w i\ndt = element (ElemName \"dt\")\n\ndt_ :: forall w i. Array (HTML w i) -> HTML w i\ndt_ = dt []\n\nem :: forall w i. Node I.HTMLem w i\nem = element (ElemName \"em\")\n\nem_ :: forall w i. Array (HTML w i) -> HTML w i\nem_ = em []\n\nembed :: forall w i. Node I.HTMLembed w i\nembed = element (ElemName \"embed\")\n\nembed_ :: forall w i. Array (HTML w i) -> HTML w i\nembed_ = embed []\n\nfieldset :: forall w i. Node I.HTMLfieldset w i\nfieldset = element (ElemName \"fieldset\")\n\nfieldset_ :: forall w i. Array (HTML w i) -> HTML w i\nfieldset_ = fieldset []\n\nfigcaption :: forall w i. Node I.HTMLfigcaption w i\nfigcaption = element (ElemName \"figcaption\")\n\nfigcaption_ :: forall w i. Array (HTML w i) -> HTML w i\nfigcaption_ = figcaption []\n\nfigure :: forall w i. Node I.HTMLfigure w i\nfigure = element (ElemName \"figure\")\n\nfigure_ :: forall w i. Array (HTML w i) -> HTML w i\nfigure_ = figure []\n\nfooter :: forall w i. Node I.HTMLfooter w i\nfooter = element (ElemName \"footer\")\n\nfooter_ :: forall w i. Array (HTML w i) -> HTML w i\nfooter_ = footer []\n\nform :: forall w i. Node I.HTMLform w i\nform = element (ElemName \"form\")\n\nform_ :: forall w i. Array (HTML w i) -> HTML w i\nform_ = form []\n\nh1 :: forall w i. Node I.HTMLh1 w i\nh1 = element (ElemName \"h1\")\n\nh1_ :: forall w i. Array (HTML w i) -> HTML w i\nh1_ = h1 []\n\nh2 :: forall w i. Node I.HTMLh2 w i\nh2 = element (ElemName \"h2\")\n\nh2_ :: forall w i. Array (HTML w i) -> HTML w i\nh2_ = h2 []\n\nh3 :: forall w i. Node I.HTMLh3 w i\nh3 = element (ElemName \"h3\")\n\nh3_ :: forall w i. Array (HTML w i) -> HTML w i\nh3_ = h3 []\n\nh4 :: forall w i. Node I.HTMLh4 w i\nh4 = element (ElemName \"h4\")\n\nh4_ :: forall w i. Array (HTML w i) -> HTML w i\nh4_ = h4 []\n\nh5 :: forall w i. Node I.HTMLh5 w i\nh5 = element (ElemName \"h5\")\n\nh5_ :: forall w i. Array (HTML w i) -> HTML w i\nh5_ = h5 []\n\nh6 :: forall w i. Node I.HTMLh6 w i\nh6 = element (ElemName \"h6\")\n\nh6_ :: forall w i. Array (HTML w i) -> HTML w i\nh6_ = h6 []\n\nhead :: forall w i. Node I.HTMLhead w i\nhead = element (ElemName \"head\")\n\nhead_ :: forall w i. Array (HTML w i) -> HTML w i\nhead_ = head []\n\nheader :: forall w i. Node I.HTMLheader w i\nheader = element (ElemName \"header\")\n\nheader_ :: forall w i. Array (HTML w i) -> HTML w i\nheader_ = header []\n\nhr :: forall w i. Leaf I.HTMLhr w i\nhr props = element (ElemName \"hr\") props []\n\nhr_ :: forall w i. HTML w i\nhr_ = hr []\n\nhtml :: forall w i. Node I.HTMLhtml w i\nhtml = element (ElemName \"html\")\n\nhtml_ :: forall w i. Array (HTML w i) -> HTML w i\nhtml_ = html []\n\ni :: forall w i. Node I.HTMLi w i\ni = element (ElemName \"i\")\n\ni_ :: forall w i. Array (HTML w i) -> HTML w i\ni_ = i []\n\niframe :: forall w i. Leaf I.HTMLiframe w i\niframe props = element (ElemName \"iframe\") props []\n\nimg :: forall w i. Leaf I.HTMLimg w i\nimg props = element (ElemName \"img\") props []\n\ninput :: forall w i. Leaf I.HTMLinput w i\ninput props = element (ElemName \"input\") props []\n\nins :: forall w i. Node I.HTMLins w i\nins = element (ElemName \"ins\")\n\nins_ :: forall w i. Array (HTML w i) -> HTML w i\nins_ = ins []\n\nkbd :: forall w i. Node I.HTMLkbd w i\nkbd = element (ElemName \"kbd\")\n\nkbd_ :: forall w i. Array (HTML w i) -> HTML w i\nkbd_ = kbd []\n\nlabel :: forall w i. Node I.HTMLlabel w i\nlabel = element (ElemName \"label\")\n\nlabel_ :: forall w i. Array (HTML w i) -> HTML w i\nlabel_ = label []\n\nlegend :: forall w i. Node I.HTMLlegend w i\nlegend = element (ElemName \"legend\")\n\nlegend_ :: forall w i. Array (HTML w i) -> HTML w i\nlegend_ = legend []\n\nli :: forall w i. Node I.HTMLli w i\nli = element (ElemName \"li\")\n\nli_ :: forall w i. Array (HTML w i) -> HTML w i\nli_ = li []\n\nlink :: forall w i. Leaf I.HTMLlink w i\nlink props = element (ElemName \"link\") props []\n\nmain :: forall w i. Node I.HTMLmain w i\nmain = element (ElemName \"main\")\n\nmain_ :: forall w i. Array (HTML w i) -> HTML w i\nmain_ = main []\n\nmap :: forall w i. Node I.HTMLmap w i\nmap = element (ElemName \"map\")\n\nmap_ :: forall w i. Array (HTML w i) -> HTML w i\nmap_ = map []\n\nmark :: forall w i. Node I.HTMLmark w i\nmark = element (ElemName \"mark\")\n\nmark_ :: forall w i. Array (HTML w i) -> HTML w i\nmark_ = mark []\n\nmenu :: forall w i. Node I.HTMLmenu w i\nmenu = element (ElemName \"menu\")\n\nmenu_ :: forall w i. Array (HTML w i) -> HTML w i\nmenu_ = menu []\n\nmenuitem :: forall w i. Node I.HTMLmenuitem w i\nmenuitem = element (ElemName \"menuitem\")\n\nmenuitem_ :: forall w i. Array (HTML w i) -> HTML w i\nmenuitem_ = menuitem []\n\nmeta :: forall w i. Leaf I.HTMLmeta w i\nmeta props = element (ElemName \"meta\") props []\n\nmeter :: forall w i. Node I.HTMLmeter w i\nmeter = element (ElemName \"meter\")\n\nmeter_ :: forall w i. Array (HTML w i) -> HTML w i\nmeter_ = meter []\n\nnav :: forall w i. Node I.HTMLnav w i\nnav = element (ElemName \"nav\")\n\nnav_ :: forall w i. Array (HTML w i) -> HTML w i\nnav_ = nav []\n\nnoscript :: forall w i. Node I.HTMLnoscript w i\nnoscript = element (ElemName \"noscript\")\n\nnoscript_ :: forall w i. Array (HTML w i) -> HTML w i\nnoscript_ = noscript []\n\nobject :: forall w i. Node I.HTMLobject w i\nobject = element (ElemName \"object\")\n\nobject_ :: forall w i. Array (HTML w i) -> HTML w i\nobject_ = object []\n\nol :: forall w i. Node I.HTMLol w i\nol = element (ElemName \"ol\")\n\nol_ :: forall w i. Array (HTML w i) -> HTML w i\nol_ = ol []\n\noptgroup :: forall w i. Node I.HTMLoptgroup w i\noptgroup = element (ElemName \"optgroup\")\n\noptgroup_ :: forall w i. Array (HTML w i) -> HTML w i\noptgroup_ = optgroup []\n\noption :: forall w i. Node I.HTMLoption w i\noption = element (ElemName \"option\")\n\noption_ :: forall w i. Array (HTML w i) -> HTML w i\noption_ = option []\n\noutput :: forall w i. Node I.HTMLoutput w i\noutput = element (ElemName \"output\")\n\noutput_ :: forall w i. Array (HTML w i) -> HTML w i\noutput_ = output []\n\np :: forall w i. Node I.HTMLp w i\np = element (ElemName \"p\")\n\np_ :: forall w i. Array (HTML w i) -> HTML w i\np_ = p []\n\nparam :: forall w i. Leaf I.HTMLparam w i\nparam props = element (ElemName \"param\") props []\n\npre :: forall w i. Node I.HTMLpre w i\npre = element (ElemName \"pre\")\n\npre_ :: forall w i. Array (HTML w i) -> HTML w i\npre_ = pre []\n\nprogress :: forall w i. Node I.HTMLprogress w i\nprogress = element (ElemName \"progress\")\n\nprogress_ :: forall w i. Array (HTML w i) -> HTML w i\nprogress_ = progress []\n\nq :: forall w i. Node I.HTMLq w i\nq = element (ElemName \"q\")\n\nq_ :: forall w i. Array (HTML w i) -> HTML w i\nq_ = q []\n\nrp :: forall w i. Node I.HTMLrp w i\nrp = element (ElemName \"rp\")\n\nrp_ :: forall w i. Array (HTML w i) -> HTML w i\nrp_ = rp []\n\nrt :: forall w i. Node I.HTMLrt w i\nrt = element (ElemName \"rt\")\n\nrt_ :: forall w i. Array (HTML w i) -> HTML w i\nrt_ = rt []\n\nruby :: forall w i. Node I.HTMLruby w i\nruby = element (ElemName \"ruby\")\n\nruby_ :: forall w i. Array (HTML w i) -> HTML w i\nruby_ = ruby []\n\nsamp :: forall w i. Node I.HTMLsamp w i\nsamp = element (ElemName \"samp\")\n\nsamp_ :: forall w i. Array (HTML w i) -> HTML w i\nsamp_ = samp []\n\nscript :: forall w i. Node I.HTMLscript w i\nscript = element (ElemName \"script\")\n\nscript_ :: forall w i. Array (HTML w i) -> HTML w i\nscript_ = script []\n\nsection :: forall w i. Node I.HTMLsection w i\nsection = element (ElemName \"section\")\n\nsection_ :: forall w i. Array (HTML w i) -> HTML w i\nsection_ = section []\n\nselect :: forall w i. Node I.HTMLselect w i\nselect = element (ElemName \"select\")\n\nselect_ :: forall w i. Array (HTML w i) -> HTML w i\nselect_ = select []\n\nsmall :: forall w i. Node I.HTMLsmall w i\nsmall = element (ElemName \"small\")\n\nsmall_ :: forall w i. Array (HTML w i) -> HTML w i\nsmall_ = small []\n\nsource :: forall w i. Leaf I.HTMLsource w i\nsource props = element (ElemName \"source\") props []\n\nspan :: forall w i. Node I.HTMLspan w i\nspan = element (ElemName \"span\")\n\nspan_ :: forall w i. Array (HTML w i) -> HTML w i\nspan_ = span []\n\nstrong :: forall w i. Node I.HTMLstrong w i\nstrong = element (ElemName \"strong\")\n\nstrong_ :: forall w i. Array (HTML w i) -> HTML w i\nstrong_ = strong []\n\nstyle :: forall w i. Node I.HTMLstyle w i\nstyle = element (ElemName \"style\")\n\nstyle_ :: forall w i. Array (HTML w i) -> HTML w i\nstyle_ = style []\n\nsub :: forall w i. Node I.HTMLsub w i\nsub = element (ElemName \"sub\")\n\nsub_ :: forall w i. Array (HTML w i) -> HTML w i\nsub_ = sub []\n\nsummary :: forall w i. Node I.HTMLsummary w i\nsummary = element (ElemName \"summary\")\n\nsummary_ :: forall w i. Array (HTML w i) -> HTML w i\nsummary_ = summary []\n\nsup :: forall w i. Node I.HTMLsup w i\nsup = element (ElemName \"sup\")\n\nsup_ :: forall w i. Array (HTML w i) -> HTML w i\nsup_ = sup []\n\ntable :: forall w i. Node I.HTMLtable w i\ntable = element (ElemName \"table\")\n\ntable_ :: forall w i. Array (HTML w i) -> HTML w i\ntable_ = table []\n\ntbody :: forall w i. Node I.HTMLtbody w i\ntbody = element (ElemName \"tbody\")\n\ntbody_ :: forall w i. Array (HTML w i) -> HTML w i\ntbody_ = tbody []\n\ntd :: forall w i. Node I.HTMLtd w i\ntd = element (ElemName \"td\")\n\ntd_ :: forall w i. Array (HTML w i) -> HTML w i\ntd_ = td []\n\ntextarea :: forall w i. Leaf I.HTMLtextarea w i\ntextarea es = element (ElemName \"textarea\") es []\n\ntfoot :: forall w i. Node I.HTMLtfoot w i\ntfoot = element (ElemName \"tfoot\")\n\ntfoot_ :: forall w i. Array (HTML w i) -> HTML w i\ntfoot_ = tfoot []\n\nth :: forall w i. Node I.HTMLth w i\nth = element (ElemName \"th\")\n\nth_ :: forall w i. Array (HTML w i) -> HTML w i\nth_ = th []\n\nthead :: forall w i. Node I.HTMLthead w i\nthead = element (ElemName \"thead\")\n\nthead_ :: forall w i. Array (HTML w i) -> HTML w i\nthead_ = thead []\n\ntime :: forall w i. Node I.HTMLtime w i\ntime = element (ElemName \"time\")\n\ntime_ :: forall w i. Array (HTML w i) -> HTML w i\ntime_ = time []\n\ntitle :: forall w i. Node I.HTMLtitle w i\ntitle = element (ElemName \"title\")\n\ntitle_ :: forall w i. Array (HTML w i) -> HTML w i\ntitle_ = title []\n\ntr :: forall w i. Node I.HTMLtr w i\ntr = element (ElemName \"tr\")\n\ntr_ :: forall w i. Array (HTML w i) -> HTML w i\ntr_ = tr []\n\ntrack :: forall w i. Leaf I.HTMLtrack w i\ntrack props = element (ElemName \"track\") props []\n\nu :: forall w i. Node I.HTMLu w i\nu = element (ElemName \"u\")\n\nu_ :: forall w i. Array (HTML w i) -> HTML w i\nu_ = u []\n\nul :: forall w i. Node I.HTMLul w i\nul = element (ElemName \"ul\")\n\nul_ :: forall w i. Array (HTML w i) -> HTML w i\nul_ = ul []\n\nvar :: forall w i. Node I.HTMLvar w i\nvar = element (ElemName \"var\")\n\nvar_ :: forall w i. Array (HTML w i) -> HTML w i\nvar_ = var []\n\nvideo :: forall w i. Node I.HTMLvideo w i\nvideo = element (ElemName \"video\")\n\nvideo_ :: forall w i. Array (HTML w i) -> HTML w i\nvideo_ = video []\n\nwbr :: forall w i. Leaf I.HTMLwbr w i\nwbr props = element (ElemName \"wbr\") props []\n", "-- | A closed signature of type-indexed (refined) HTML properties; these can be\n-- | used to ensure correctness by construction, and then erased into the\n-- | standard unrefined versions.\nmodule Halogen.HTML.Properties\n  ( IProp(..)\n  , prop\n  , attr\n  , attrNS\n  , ref\n  , expand\n\n  , alt\n  , charset\n  , class_\n  , classes\n  , cols\n  , rows\n  , colSpan\n  , rowSpan\n  , for\n  , height\n  , width\n  , href\n  , id\n  , name\n  , rel\n  , src\n  , srcDoc\n  , style\n  , scope\n  , target\n  , title\n  , download\n\n  , method\n  , action\n  , enctype\n  , noValidate\n\n  , type_\n  , value\n  , min\n  , max\n  , step\n  , disabled\n  , enabled\n  , required\n  , readOnly\n  , spellcheck\n  , checked\n  , selected\n  , selectedIndex\n  , placeholder\n  , autocomplete\n  , list\n  , autofocus\n  , multiple\n  , pattern\n  , accept\n\n  , autoplay\n  , controls\n  , loop\n  , muted\n  , poster\n  , preload\n\n  , draggable\n  , tabIndex\n\n  , module I\n  ) where\n\nimport Prelude\n\nimport DOM.HTML.Indexed (CSSPixel) as I\nimport DOM.HTML.Indexed.AutocompleteType (AutocompleteType(..)) as I\nimport DOM.HTML.Indexed.ButtonType (ButtonType(..)) as I\nimport DOM.HTML.Indexed.FormMethod (FormMethod(..)) as I\nimport DOM.HTML.Indexed.InputAcceptType (InputAcceptType(..)) as I\nimport DOM.HTML.Indexed.InputType (InputType(..)) as I\nimport DOM.HTML.Indexed.MenuType (MenuType(..)) as I\nimport DOM.HTML.Indexed.MenuitemType (MenuitemType(..)) as I\nimport DOM.HTML.Indexed.OrderedListType (OrderedListType(..)) as I\nimport DOM.HTML.Indexed.PreloadValue (PreloadValue(..)) as I\nimport DOM.HTML.Indexed.ScopeValue (ScopeValue(..)) as I\nimport DOM.HTML.Indexed.StepValue (StepValue(..)) as I\nimport Data.Maybe (Maybe(..))\nimport Data.MediaType (MediaType)\nimport Data.Newtype (class Newtype, unwrap)\nimport Data.String (joinWith)\nimport Halogen.HTML.Core (class IsProp, AttrName(..), ClassName, Namespace, PropName(..), Prop)\nimport Halogen.HTML.Core as Core\nimport Halogen.Query.Input (Input(..), RefLabel)\nimport Prim.Row as Row\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Element (Element)\n\n-- | The phantom row `r` can be thought of as a context which is synthesized in\n-- | the course of constructing a refined HTML expression.\nnewtype IProp (r :: Row Type) i = IProp (Prop (Input i))\n\nderive instance newtypeIProp :: Newtype (IProp r i) _\nderive instance functorIProp :: Functor (IProp r)\n\n-- | Creates an indexed HTML property.\nprop\n  :: forall value r i\n   . IsProp value\n  => PropName value\n  -> value\n  -> IProp r i\nprop = (unsafeCoerce :: (PropName value -> value -> Prop (Input i)) -> PropName value -> value -> IProp r i) Core.prop\n\n-- | Creates an indexed HTML attribute.\nattr :: forall r i. AttrName -> String -> IProp r i\nattr =\n  Core.attr Nothing #\n    ( unsafeCoerce\n        :: (AttrName -> String -> Prop (Input i))\n        -> AttrName\n        -> String\n        -> IProp r i\n    )\n\n-- | Creates an indexed HTML attribute.\nattrNS :: forall r i. Namespace -> AttrName -> String -> IProp r i\nattrNS =\n  pure >>> Core.attr >>>\n    ( unsafeCoerce\n        :: (AttrName -> String -> Prop (Input i))\n        -> AttrName\n        -> String\n        -> IProp r i\n    )\n\n-- | The `ref` property allows an input to be raised once a `HTMLElement` has\n-- | been created or destroyed in the DOM for the element that the property is\n-- | attached to.\nref :: forall r i. RefLabel -> IProp r i\nref = (unsafeCoerce :: ((Maybe Element -> Maybe (Input i)) -> Prop (Input i)) -> (Maybe Element -> Maybe (Input i)) -> IProp r i) Core.ref <<< go\n  where\n  go :: RefLabel -> Maybe Element -> Maybe (Input i)\n  go p mel = Just (RefUpdate p mel)\n\n-- | Every `IProp lt i` can be cast to some `IProp gt i` as long as `lt` is a\n-- | subset of `gt`.\nexpand :: forall lt gt a i. Row.Union lt a gt => IProp lt i -> IProp gt i\nexpand = unsafeCoerce\n\nalt :: forall r i. String -> IProp (alt :: String | r) i\nalt = prop (PropName \"alt\")\n\ncharset :: forall r i. String -> IProp (charset :: String | r) i\ncharset = prop (PropName \"charset\")\n\nclass_ :: forall r i. ClassName -> IProp (class :: String | r) i\nclass_ = prop (PropName \"className\") <<< unwrap\n\nclasses :: forall r i. Array ClassName -> IProp (class :: String | r) i\nclasses = prop (PropName \"className\") <<< joinWith \" \" <<< map unwrap\n\ncols :: forall r i. Int -> IProp (cols :: Int | r) i\ncols = prop (PropName \"cols\")\n\nrows :: forall r i. Int -> IProp (rows :: Int | r) i\nrows = prop (PropName \"rows\")\n\ncolSpan :: forall r i. Int -> IProp (colSpan :: Int | r) i\ncolSpan = prop (PropName \"colSpan\")\n\nrowSpan :: forall r i. Int -> IProp (rowSpan :: Int | r) i\nrowSpan = prop (PropName \"rowSpan\")\n\nfor :: forall r i. String -> IProp (for :: String | r) i\nfor = prop (PropName \"htmlFor\")\n\nheight :: forall r i. I.CSSPixel -> IProp (height :: I.CSSPixel | r) i\nheight = prop (PropName \"height\")\n\nwidth :: forall r i. I.CSSPixel -> IProp (width :: I.CSSPixel | r) i\nwidth = prop (PropName \"width\")\n\nhref :: forall r i. String -> IProp (href :: String | r) i\nhref = prop (PropName \"href\")\n\nid :: forall r i. String -> IProp (id :: String | r) i\nid = prop (PropName \"id\")\n\nname :: forall r i. String -> IProp (name :: String | r) i\nname = prop (PropName \"name\")\n\nrel :: forall r i. String -> IProp (rel :: String | r) i\nrel = prop (PropName \"rel\")\n\nsrc :: forall r i. String -> IProp (src :: String | r) i\nsrc = prop (PropName \"src\")\n\nsrcDoc :: forall r i. String -> IProp (srcDoc :: String | r) i\nsrcDoc = prop (PropName \"srcdoc\")\n\n-- | Sets the `style` attribute to the specified string.\n-- |\n-- | ```purs\n-- | ... [ style \"height: 50px;\" ]\n-- | ```\n-- |\n-- | If you prefer to use typed CSS for this attribute, you can use the purescript-halogen-css library:\n-- | https://github.com/purescript-halogen/purescript-halogen-css\nstyle :: forall r i. String -> IProp (style :: String | r) i\nstyle = attr (AttrName \"style\")\n\nscope :: forall r i. I.ScopeValue -> IProp (scope :: I.ScopeValue | r) i\nscope = prop (PropName \"scope\")\n\ntarget :: forall r i. String -> IProp (target :: String | r) i\ntarget = prop (PropName \"target\")\n\ntitle :: forall r i. String -> IProp (title :: String | r) i\ntitle = prop (PropName \"title\")\n\ndownload :: forall r i. String -> IProp (download :: String | r) i\ndownload = prop (PropName \"download\")\n\nmethod :: forall r i. I.FormMethod -> IProp (method :: I.FormMethod | r) i\nmethod = prop (PropName \"method\")\n\naction :: forall r i. String -> IProp (action :: String | r) i\naction = prop (PropName \"action\")\n\nenctype :: forall r i. MediaType -> IProp (enctype :: MediaType | r) i\nenctype = prop (PropName \"enctype\")\n\nnoValidate :: forall r i. Boolean -> IProp (noValidate :: Boolean | r) i\nnoValidate = prop (PropName \"noValidate\")\n\ntype_ :: forall r i value. IsProp value => value -> IProp (type :: value | r) i\ntype_ = prop (PropName \"type\")\n\nvalue :: forall r i value. IsProp value => value -> IProp (value :: value | r) i\nvalue = prop (PropName \"value\")\n\nmin :: forall r i. Number -> IProp (min :: Number | r) i\nmin = prop (PropName \"min\")\n\nmax :: forall r i. Number -> IProp (max :: Number | r) i\nmax = prop (PropName \"max\")\n\nstep :: forall r i. I.StepValue -> IProp (step :: I.StepValue | r) i\nstep = prop (PropName \"step\")\n\nenabled :: forall r i. Boolean -> IProp (disabled :: Boolean | r) i\nenabled = disabled <<< not\n\ndisabled :: forall r i. Boolean -> IProp (disabled :: Boolean | r) i\ndisabled = prop (PropName \"disabled\")\n\nrequired :: forall r i. Boolean -> IProp (required :: Boolean | r) i\nrequired = prop (PropName \"required\")\n\nreadOnly :: forall r i. Boolean -> IProp (readOnly :: Boolean | r) i\nreadOnly = prop (PropName \"readOnly\")\n\nspellcheck :: forall r i. Boolean -> IProp (spellcheck :: Boolean | r) i\nspellcheck = prop (PropName \"spellcheck\")\n\nchecked :: forall r i. Boolean -> IProp (checked :: Boolean | r) i\nchecked = prop (PropName \"checked\")\n\nselected :: forall r i. Boolean -> IProp (selected :: Boolean | r) i\nselected = prop (PropName \"selected\")\n\nselectedIndex :: forall r i. Int -> IProp (selectedIndex :: Int | r) i\nselectedIndex = prop (PropName \"selectedIndex\")\n\nplaceholder :: forall r i. String -> IProp (placeholder :: String | r) i\nplaceholder = prop (PropName \"placeholder\")\n\nautocomplete :: forall r i. I.AutocompleteType -> IProp (autocomplete :: I.AutocompleteType | r) i\nautocomplete = prop (PropName \"autocomplete\")\n\nlist :: forall r i. String -> IProp (list :: String | r) i\nlist = attr (AttrName \"list\")\n\nautofocus :: forall r i. Boolean -> IProp (autofocus :: Boolean | r) i\nautofocus = prop (PropName \"autofocus\")\n\nmultiple :: forall r i. Boolean -> IProp (multiple :: Boolean | r) i\nmultiple = prop (PropName \"multiple\")\n\naccept :: forall r i. I.InputAcceptType -> IProp (accept :: I.InputAcceptType | r) i\naccept = prop (PropName \"accept\")\n\npattern :: forall r i. String -> IProp (pattern :: String | r) i\npattern = prop (PropName \"pattern\")\n\nautoplay :: forall r i. Boolean -> IProp (autoplay :: Boolean | r) i\nautoplay = prop (PropName \"autoplay\")\n\ncontrols :: forall r i. Boolean -> IProp (controls :: Boolean | r) i\ncontrols = prop (PropName \"controls\")\n\nloop :: forall r i. Boolean -> IProp (loop :: Boolean | r) i\nloop = prop (PropName \"loop\")\n\nmuted :: forall r i. Boolean -> IProp (muted :: Boolean | r) i\nmuted = prop (PropName \"muted\")\n\nposter :: forall r i. String -> IProp (poster :: String | r) i\nposter = prop (PropName \"poster\")\n\npreload :: forall r i. I.PreloadValue -> IProp (preload :: I.PreloadValue | r) i\npreload = prop (PropName \"preload\")\n\ndraggable :: forall r i. Boolean -> IProp (draggable :: Boolean | r) i\ndraggable = prop (PropName \"draggable\")\n\ntabIndex :: forall r i. Int -> IProp (tabIndex :: Int | r) i\ntabIndex = prop (PropName \"tabIndex\")\n", "-- | This module re-exports the types for the `HTML` DSL, and values for all\n-- | supported HTML elements.\nmodule Halogen.HTML\n  ( ComponentHTML\n  , PlainHTML\n  , fromPlainHTML\n  , slot\n  , slot_\n  , memoized\n  , lazy\n  , lazy2\n  , lazy3\n  , module Halogen.HTML.Core\n  , module Halogen.HTML.Elements\n  , module Halogen.HTML.Properties\n  ) where\n\nimport Halogen.HTML.Elements\n\nimport Data.Function (const)\nimport Data.Function.Uncurried as Fn\nimport Data.Maybe (Maybe(..))\nimport Data.Symbol (class IsSymbol)\nimport Halogen.Component (Component, ComponentSlot(..), componentSlot)\nimport Halogen.Data.Slot (Slot)\nimport Halogen.HTML.Core (class IsProp, AttrName(..), ClassName(..), HTML(..), Namespace(..), PropName(..), ElemName(..), text, handler)\nimport Halogen.HTML.Core as Core\nimport Halogen.HTML.Properties (IProp, attr, attrNS, prop)\nimport Halogen.VDom.Thunk (thunk1, thunk2, thunk3, thunked)\nimport Prelude (class Ord, Void, (<<<), (<$>))\nimport Prim.Row as Row\nimport Type.Proxy (Proxy)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | A convenience synonym for the output type of a `render` function for a\n-- | component that renders HTML.\n-- |\n-- | - `action` is the type of actions, events internal to the component that can\n-- |   be evaluated with the `handleAction` function\n-- | - `slots` is the set of child component types that can be used in the HTML\n-- | - `m` is the monad used by the child component during evaluation\ntype ComponentHTML action slots m = HTML (ComponentSlot slots m action) action\n\n-- | A type useful for a chunk of HTML with no slot-embedding or query-raising.\n-- |\n-- | Often a polymorphic usage of `HTML` is good enough for this, but sometimes\n-- | it's useful to have a type like this (and accompanying coercion) when doing\n-- | things like creating components that accept a chunk of HTML as part of\n-- | their configuration.\ntype PlainHTML = HTML Void Void\n\n-- | Relaxes the type of `PlainHTML` to make it compatible with all `HTML`.\nfromPlainHTML :: forall w i. PlainHTML -> HTML w i\nfromPlainHTML = unsafeCoerce -- \u2245 bimap absurd absurd\n\n-- | Defines a slot for a child component. Takes:\n-- | - the slot address label\n-- | - the slot address index\n-- | - the component for the slot\n-- | - the input value to pass to the component\n-- | - a function mapping outputs from the component to a query in the parent\nslot\n  :: forall query action input output slots m label slot _1\n   . Row.Cons label (Slot query output slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> slot\n  -> Component query input output m\n  -> input\n  -> (output -> action)\n  -> ComponentHTML action slots m\nslot label p component input outputQuery =\n  Core.widget (ComponentSlot (componentSlot label p component input (Just <<< outputQuery)))\n\n-- | Defines a slot for a child component, ignoring its output.\n-- |\n-- | This variant may be used when the component produces output, but it is not\n-- | needed in the current context, or instead of passing `absurd` to `slot`\n-- | when the output type is `Void`.\n-- |\n-- | Takes:\n-- | - the slot address label\n-- | - the slot address index\n-- | - the component for the slot\n-- | - the input value to pass to the component\nslot_\n  :: forall query action input output slots m label slot _1\n   . Row.Cons label (Slot query output slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> slot\n  -> Component query input output m\n  -> input\n  -> ComponentHTML action slots m\nslot_ label p component input =\n  Core.widget (ComponentSlot (componentSlot label p component input (const Nothing)))\n\n-- | Optimizes rendering of a subtree given an equality predicate. If an argument\n-- | is deemed equivalent to the previous value, rendering and diffing will be\n-- | skipped. You should not use this function fully saturated, but instead\n-- | partially apply it for use within a Component's scope. For example, to skip\n-- | rendering for equal states, just wrap your `render` function.\n-- |\n-- | ```purescript\n-- | myComponent = component\n-- |  { render: memoized eq render\n-- |  , ...\n-- |  }\n-- | ```\nmemoized\n  :: forall a action slots m\n   . (a -> a -> Boolean)\n  -> (a -> ComponentHTML action slots m)\n  -> a\n  -> ComponentHTML action slots m\nmemoized eqFn f =\n  -- Note: This implementation must not be eta-expanded, as it relies on\n  -- partial application to work.\n  Core.widget <<< ThunkSlot <$> thunked eqFn f\n\n-- | Skips rendering for referentially equal arguments. You should not use this\n-- | function fully saturated, but instead partially apply it for use within a\n-- | Component's scope.\nlazy\n  :: forall a action slots m\n   . (a -> ComponentHTML action slots m)\n  -> a\n  -> ComponentHTML action slots m\nlazy f a = Core.widget (ThunkSlot (Fn.runFn2 thunk1 f a))\n\n-- | Like `lazy`, but for a rendering function which takes 2 arguments.\nlazy2\n  :: forall a b action slots m\n   . (a -> b -> ComponentHTML action slots m)\n  -> a\n  -> b\n  -> ComponentHTML action slots m\nlazy2 f a b = Core.widget (ThunkSlot (Fn.runFn3 thunk2 f a b))\n\n-- | Like `lazy`, but for a rendering function which takes 3 arguments.\nlazy3\n  :: forall a b c action slots m\n   . (a -> b -> c -> ComponentHTML action slots m)\n  -> a\n  -> b\n  -> c\n  -> ComponentHTML action slots m\nlazy3 f a b c = Core.widget (ThunkSlot (Fn.runFn4 thunk3 f a b c))\n", "-- | Functions and types used to describe the `HalogenF` algebra used in a\n-- | component's `eval` function.\nmodule Halogen.Query\n  ( Tell\n  , mkTell\n  , tell\n  , tellAll\n  , Request\n  , mkRequest\n  , request\n  , requestAll\n  , getHTMLElementRef\n  , module Exports\n  , module Halogen.Query.Input\n  , module Halogen.Query.HalogenM\n  , module Halogen.Query.HalogenQ\n  ) where\n\nimport Prelude hiding (join)\n\nimport Control.Monad.State.Class (get, gets, modify, modify_, put) as Exports\nimport Control.Monad.Trans.Class (lift) as Exports\nimport Data.Map (Map)\nimport Data.Maybe (Maybe)\nimport Data.Symbol (class IsSymbol)\nimport Effect.Aff.Class (liftAff) as Exports\nimport Effect.Class (liftEffect) as Exports\nimport Halogen.Data.Slot (Slot)\nimport Halogen.Query.HalogenM (ForkId, HalogenF(..), HalogenM(..), SubscriptionId, fork, getRef, join, kill, query, queryAll, raise, subscribe, subscribe', unsubscribe)\nimport Halogen.Query.HalogenQ (HalogenQ(..))\nimport Halogen.Query.Input (RefLabel(..))\nimport Prim.Row as Row\nimport Type.Proxy (Proxy)\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLElement as HTMLElement\n\n-- | Type synonym for a \"tell-style\" query - queries that only cause effects,\n-- | but that cannot receive a return value.\n-- |\n-- | In a query algebra, a tell constructor carries the algebra's type variable\n-- | as its last argument. For example:\n-- |\n-- | ``` purescript\n-- | data Query a\n-- |   = SomeTell a\n-- |   | SomeOtherTell String a\n-- |   | NotATell (Boolean -> a)\n-- | ```\n-- |\n-- | Both `SomeTell` and `SomeOtherTell` carry a plain `a` as a value, whereas\n-- | `NotATell` has `a` as the result of a function so is considered to be a\n-- | \"request\" ([see below](#Request)).\ntype Tell f = Unit -> f Unit\n\n-- | Takes a data constructor of query algebra `f` and creates a tell query.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | data Query a = Tick a\n-- |\n-- | sendTick :: forall o. H.HalogenIO Query o Aff -> Aff (Maybe Unit)\n-- | sendTick app = app.query (H.mkTell Tick)\n-- | ```\nmkTell :: forall f. Tell f -> f Unit\nmkTell act = act unit\n\ntell\n  :: forall state action output m label slots query output' slot _1\n   . Row.Cons label (Slot query output' slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> slot\n  -> Tell query\n  -> HalogenM state action slots output m Unit\ntell slot label req = void $ query slot label (req unit)\n\ntellAll\n  :: forall state action output m label slots query output' slot _1\n   . Row.Cons label (Slot query output' slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> Tell query\n  -> HalogenM state action slots output m Unit\ntellAll label req = void $ queryAll label (req unit)\n\n-- | Type synonym for an \"request-style\" query - queries that can cause effects\n-- | as well as fetching some information from a component.\n-- |\n-- | In a query algebra, a request constructor carries the algebra's type\n-- | variable as the return value of a function as its last argument. For\n-- | example:\n-- |\n-- | ``` purescript\n-- | data Query a = SomeRequest (Boolean -> a)\n-- | ```\ntype Request f a = (a -> a) -> f a\n\n-- | Takes a data constructor of query algebra `f` and creates a request query.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | data Query a = GetTickCount (Int -> a)\n-- |\n-- | getTickCount :: forall o. H.HalogenIO Query o Aff -> Aff (Maybe Int)\n-- | getTickCount app = app.query (H.mkRequest GetTickCount)\n-- | ```\nmkRequest :: forall f a. Request f a -> f a\nmkRequest req = req identity\n\nrequest\n  :: forall state action output m label slots query output' slot a _1\n   . Row.Cons label (Slot query output' slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> slot\n  -> Request query a\n  -> HalogenM state action slots output m (Maybe a)\nrequest slot label req = query slot label (req identity)\n\nrequestAll\n  :: forall state action output m label slots query output' slot a _1\n   . Row.Cons label (Slot query output' slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> Request query a\n  -> HalogenM state action slots output m (Map slot a)\nrequestAll label req = queryAll label (req identity)\n\n-- | Retrieves a `HTMLElement` value that is associated with a `Ref` in the\n-- | rendered output of a component. If there is no currently rendered value (or\n-- | it is not an `HTMLElement`) for the request will return `Nothing`.\ngetHTMLElementRef\n  :: forall state action slots output m\n   . RefLabel\n  -> HalogenM state action slots output m (Maybe HTMLElement)\ngetHTMLElementRef = map (HTMLElement.fromElement =<< _) <<< getRef\n", "module Halogen.Aff.Driver.State\n  ( LifecycleHandlers\n  , DriverState(..)\n  , mapDriverState\n  , DriverStateRef(..)\n  , DriverStateRec\n  , DriverStateX\n  , unDriverStateX\n  , mkDriverStateXRef\n  , RenderStateX\n  , renderStateX\n  , renderStateX_\n  , unRenderStateX\n  , initDriverState\n  ) where\n\nimport Prelude\n\nimport Data.List (List(..))\nimport Data.Map as M\nimport Data.Maybe (Maybe(..))\nimport Data.Traversable (traverse_)\nimport Effect (Effect)\nimport Effect.Aff (Aff, Fiber)\nimport Effect.Ref (Ref)\nimport Effect.Ref as Ref\nimport Halogen.Component (ComponentSpec)\nimport Halogen.Data.Slot (SlotStorage)\nimport Halogen.Data.Slot as SlotStorage\nimport Halogen.Query.HalogenM (ForkId, SubscriptionId)\nimport Halogen.Subscription as HS\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (Element)\n\ntype LifecycleHandlers =\n  { initializers :: List (Aff Unit)\n  , finalizers :: List (Aff Unit)\n  }\n\nnewtype DriverState r s f act ps i o = DriverState (DriverStateRec r s f act ps i o)\n\ntype DriverStateRec r s f act ps i o =\n  { component :: ComponentSpec s f act ps i o Aff\n  , state :: s\n  , refs :: M.Map String Element\n  , children :: SlotStorage ps (DriverStateRef r)\n  , childrenIn :: Ref (SlotStorage ps (DriverStateRef r))\n  , childrenOut :: Ref (SlotStorage ps (DriverStateRef r))\n  , selfRef :: Ref (DriverState r s f act ps i o)\n  , handlerRef :: Ref (o -> Aff Unit)\n  , pendingQueries :: Ref (Maybe (List (Aff Unit)))\n  , pendingOuts :: Ref (Maybe (List (Aff Unit)))\n  , pendingHandlers :: Ref (Maybe (List (Aff Unit)))\n  , rendering :: Maybe (r s act ps o)\n  , fresh :: Ref Int\n  , subscriptions :: Ref (Maybe (M.Map SubscriptionId HS.Subscription))\n  , forks :: Ref (M.Map ForkId (Fiber Unit))\n  , lifecycleHandlers :: Ref LifecycleHandlers\n  }\n\nmapDriverState\n  :: forall r s f act ps i o\n   . (DriverStateRec r s f act ps i o -> DriverStateRec r s f act ps i o)\n  -> DriverState r s f act ps i o\n  -> DriverState r s f act ps i o\nmapDriverState f (DriverState ds) = DriverState (f ds)\n\nnewtype DriverStateRef r f o = DriverStateRef (Ref (DriverStateX r f o))\n\n-- | A version of `DriverState` with the aspects relating to child components\n-- | existentially hidden.\ndata DriverStateX\n  (r :: Type -> Type -> Row Type -> Type -> Type)\n  (f :: Type -> Type)\n  (o :: Type)\n\nmkDriverStateXRef\n  :: forall r s f act ps i o\n   . Ref (DriverState r s f act ps i o)\n  -> Ref (DriverStateX r f o)\nmkDriverStateXRef = unsafeCoerce\n\nunDriverStateX\n  :: forall r f i o x\n   . (forall s act ps. DriverStateRec r s f act ps i o -> x)\n  -> DriverStateX r f o\n  -> x\nunDriverStateX = unsafeCoerce\n\n-- | A wrapper of `r` from `DriverState` with the aspects relating to child\n-- | components existentially hidden.\ndata RenderStateX (r :: Type -> Type -> Row Type -> Type -> Type)\n\nmkRenderStateX\n  :: forall r s f ps o m\n   . m (r s f ps o)\n  -> m (RenderStateX r)\nmkRenderStateX = unsafeCoerce\n\nunRenderStateX\n  :: forall r x\n   . (forall s f ps o. r s f ps o -> x)\n  -> RenderStateX r\n  -> x\nunRenderStateX = unsafeCoerce\n\nrenderStateX\n  :: forall m r f o\n   . Functor m\n  => (forall s act ps. Maybe (r s act ps o) -> m (r s act ps o))\n  -> DriverStateX r f o\n  -> m (RenderStateX r)\nrenderStateX f = unDriverStateX \\st ->\n  mkRenderStateX (f st.rendering)\n\nrenderStateX_\n  :: forall m r f o\n   . Applicative m\n  => (forall s act ps. r s act ps o -> m Unit)\n  -> DriverStateX r f o\n  -> m Unit\nrenderStateX_ f = unDriverStateX \\st -> traverse_ f st.rendering\n\ninitDriverState\n  :: forall r s f act ps i o\n   . ComponentSpec s f act ps i o Aff\n  -> i\n  -> (o -> Aff Unit)\n  -> Ref LifecycleHandlers\n  -> Effect (Ref (DriverStateX r f o))\ninitDriverState component input handler lchs = do\n  selfRef <- Ref.new (unsafeCoerce {})\n  childrenIn <- Ref.new SlotStorage.empty\n  childrenOut <- Ref.new SlotStorage.empty\n  handlerRef <- Ref.new handler\n  pendingQueries <- Ref.new (Just Nil)\n  pendingOuts <- Ref.new (Just Nil)\n  pendingHandlers <- Ref.new Nothing\n  fresh <- Ref.new 1\n  subscriptions <- Ref.new (Just M.empty)\n  forks <- Ref.new M.empty\n  let\n    ds :: DriverStateRec r s f act ps i o\n    ds =\n      { component\n      , state: component.initialState input\n      , refs: M.empty\n      , children: SlotStorage.empty\n      , childrenIn\n      , childrenOut\n      , selfRef\n      , handlerRef\n      , pendingQueries\n      , pendingOuts\n      , pendingHandlers\n      , rendering: Nothing\n      , fresh\n      , subscriptions\n      , forks\n      , lifecycleHandlers: lchs\n      }\n  Ref.write (DriverState ds) selfRef\n  pure $ mkDriverStateXRef selfRef\n", "module Halogen.Aff.Driver.Eval\n  ( Renderer\n  , evalF\n  , evalQ\n  , evalM\n  , handleLifecycle\n  , queueOrRun\n  , handleAff\n  ) where\n\nimport Prelude\n\nimport Control.Applicative.Free (hoistFreeAp, retractFreeAp)\nimport Control.Monad.Fork.Class (fork)\nimport Control.Monad.Free (foldFree)\nimport Control.Parallel (parSequence_, parallel, sequential)\nimport Data.Coyoneda (liftCoyoneda)\nimport Data.Either (either)\nimport Data.Foldable (traverse_)\nimport Data.List (List, (:))\nimport Data.List as L\nimport Data.Map as M\nimport Data.Maybe (Maybe(..))\nimport Data.Tuple (Tuple(..))\nimport Effect (Effect)\nimport Effect.Aff (Aff, error, finally, joinFiber, killFiber, runAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Exception (throwException)\nimport Effect.Ref (Ref)\nimport Effect.Ref as Ref\nimport Halogen.Aff.Driver.State (DriverState(..), DriverStateRef(..), LifecycleHandlers, mapDriverState, unDriverStateX)\nimport Halogen.Query.ChildQuery as CQ\nimport Halogen.Query.HalogenM (ForkId(..), HalogenAp(..), HalogenF(..), HalogenM(..), SubscriptionId(..))\nimport Halogen.Query.HalogenQ as HQ\nimport Halogen.Query.Input (Input)\nimport Halogen.Query.Input as Input\nimport Halogen.Subscription as HS\nimport Unsafe.Reference (unsafeRefEq)\n\ntype Renderer r =\n  forall s f act ps i o\n   . Ref LifecycleHandlers\n  -> Ref (DriverState r s f act ps i o)\n  -> Effect Unit\n\nevalF\n  :: forall r s f act ps i o\n   . Renderer r\n  -> Ref (DriverState r s f act ps i o)\n  -> Input act\n  -> Aff Unit\nevalF render ref = case _ of\n  Input.RefUpdate (Input.RefLabel p) el -> do\n    liftEffect $ flip Ref.modify_ ref $ mapDriverState \\st ->\n      st { refs = M.alter (const el) p st.refs }\n  Input.Action act -> do\n    DriverState st <- liftEffect (Ref.read ref)\n    evalM render ref (st.component.eval (HQ.Action act unit))\n\nevalQ\n  :: forall r s f act ps i o a\n   . Renderer r\n  -> Ref (DriverState r s f act ps i o)\n  -> f a\n  -> Aff (Maybe a)\nevalQ render ref q = do\n  DriverState st <- liftEffect (Ref.read ref)\n  evalM render ref (st.component.eval (HQ.Query (Just <$> liftCoyoneda q) (const Nothing)))\n\nevalM\n  :: forall r s f act ps i o a\n   . Renderer r\n  -> Ref (DriverState r s f act ps i o)\n  -> HalogenM s act ps o Aff a\n  -> Aff a\nevalM render initRef (HalogenM hm) = foldFree (go initRef) hm\n  where\n  go\n    :: forall s' f' act' ps' i' o' a'\n     . Ref (DriverState r s' f' act' ps' i' o')\n    -> HalogenF s' act' ps' o' Aff a'\n    -> Aff a'\n  go ref = case _ of\n    State f -> do\n      DriverState (st@{ state, lifecycleHandlers }) <- liftEffect (Ref.read ref)\n      case f state of\n        Tuple a state'\n          | unsafeRefEq state state' -> pure a\n          | otherwise -> do\n              liftEffect $ Ref.write (DriverState (st { state = state' })) ref\n              handleLifecycle lifecycleHandlers (render lifecycleHandlers ref)\n              pure a\n    Subscribe fes k -> do\n      sid <- fresh SubscriptionId ref\n      finalize <- liftEffect $ HS.subscribe (fes sid) \\act ->\n        handleAff $ evalF render ref (Input.Action act)\n      DriverState ({ subscriptions }) <- liftEffect (Ref.read ref)\n      liftEffect $ Ref.modify_ (map (M.insert sid finalize)) subscriptions\n      pure (k sid)\n    Unsubscribe sid next -> do\n      liftEffect $ unsubscribe sid ref\n      pure next\n    Lift aff ->\n      aff\n    ChildQuery cq ->\n      evalChildQuery ref cq\n    Raise o a -> do\n      DriverState { handlerRef, pendingOuts } <- liftEffect (Ref.read ref)\n      handler <- liftEffect (Ref.read handlerRef)\n      queueOrRun pendingOuts (handler o)\n      pure a\n    Par (HalogenAp p) ->\n      sequential $ retractFreeAp $ hoistFreeAp (parallel <<< evalM render ref) p\n    Fork hmu k -> do\n      fid <- fresh ForkId ref\n      DriverState ({ forks }) <- liftEffect (Ref.read ref)\n      doneRef <- liftEffect (Ref.new false)\n      fiber <- fork $ finally\n        ( liftEffect do\n            Ref.modify_ (M.delete fid) forks\n            Ref.write true doneRef\n        )\n        (evalM render ref hmu)\n      liftEffect $ unlessM (Ref.read doneRef) do\n        Ref.modify_ (M.insert fid fiber) forks\n      pure (k fid)\n    Join fid a -> do\n      DriverState { forks } <- liftEffect (Ref.read ref)\n      forkMap <- liftEffect (Ref.read forks)\n      traverse_ joinFiber (M.lookup fid forkMap)\n      pure a\n    Kill fid a -> do\n      DriverState ({ forks }) <- liftEffect (Ref.read ref)\n      forkMap <- liftEffect (Ref.read forks)\n      traverse_ (killFiber (error \"Cancelled\")) (M.lookup fid forkMap)\n      pure a\n    GetRef (Input.RefLabel p) k -> do\n      DriverState { refs } <- liftEffect (Ref.read ref)\n      pure $ k $ M.lookup p refs\n\n  evalChildQuery\n    :: forall s' f' act' ps' i' o' a'\n     . Ref (DriverState r s' f' act' ps' i' o')\n    -> CQ.ChildQueryBox ps' a'\n    -> Aff a'\n  evalChildQuery ref cqb = do\n    DriverState st <- liftEffect (Ref.read ref)\n    cqb # CQ.unChildQueryBox \\(CQ.ChildQuery unpack query reply) -> do\n      let\n        evalChild (DriverStateRef var) = parallel do\n          dsx <- liftEffect (Ref.read var)\n          unDriverStateX (\\ds -> evalQ render ds.selfRef query) dsx\n      reply <$> sequential (unpack evalChild st.children)\n\nunsubscribe\n  :: forall r s' f' act' ps' i' o'\n   . SubscriptionId\n  -> Ref (DriverState r s' f' act' ps' i' o')\n  -> Effect Unit\nunsubscribe sid ref = do\n  DriverState ({ subscriptions }) <- Ref.read ref\n  subs <- Ref.read subscriptions\n  traverse_ HS.unsubscribe (M.lookup sid =<< subs)\n\nhandleLifecycle :: Ref LifecycleHandlers -> Effect ~> Aff\nhandleLifecycle lchs f = do\n  liftEffect $ Ref.write { initializers: L.Nil, finalizers: L.Nil } lchs\n  result <- liftEffect f\n  { initializers, finalizers } <- liftEffect $ Ref.read lchs\n  traverse_ fork finalizers\n  parSequence_ initializers\n  pure result\n\nfresh\n  :: forall r s f act ps i o a\n   . (Int -> a)\n  -> Ref (DriverState r s f act ps i o)\n  -> Aff a\nfresh f ref = do\n  DriverState st <- liftEffect (Ref.read ref)\n  liftEffect $ Ref.modify' (\\i -> { state: i + 1, value: f i }) st.fresh\n\nqueueOrRun\n  :: Ref (Maybe (List (Aff Unit)))\n  -> Aff Unit\n  -> Aff Unit\nqueueOrRun ref au =\n  liftEffect (Ref.read ref) >>= case _ of\n    Nothing -> au\n    Just p -> liftEffect $ Ref.write (Just (au : p)) ref\n\n-- We could perhaps do something more intelligent now this isn't baked into\n-- the virtual-dom rendering. It hasn't really been a problem so far though.\nhandleAff :: forall a. Aff a -> Effect Unit\nhandleAff = runAff_ (either throwException (const (pure unit)))\n", "module Halogen.Aff.Driver\n  ( RenderSpec\n  , runUI\n  , module Halogen\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Fork.Class (fork)\nimport Control.Monad.Rec.Class (Step(..), tailRecM)\nimport Control.Parallel (parSequence_)\nimport Data.List ((:))\nimport Data.List as L\nimport Data.Map as M\nimport Data.Maybe (Maybe(..), maybe, isJust, isNothing)\nimport Data.Traversable (for_, traverse_)\nimport Data.Tuple (Tuple(..))\nimport Effect (Effect)\nimport Effect.Aff (Aff, killFiber)\nimport Effect.Class (liftEffect)\nimport Effect.Console (warn)\nimport Effect.Exception (error, throw)\nimport Effect.Ref (Ref)\nimport Effect.Ref as Ref\nimport Halogen (HalogenIO)\nimport Halogen.Aff.Driver.Eval as Eval\nimport Halogen.Aff.Driver.State (DriverState(..), DriverStateRef(..), DriverStateX, LifecycleHandlers, RenderStateX, initDriverState, mapDriverState, renderStateX, renderStateX_, unDriverStateX)\nimport Halogen.Component (Component, ComponentSlot, ComponentSlotBox, unComponent, unComponentSlot)\nimport Halogen.Data.Slot as Slot\nimport Halogen.HTML.Core as HC\nimport Halogen.Query.HalogenQ as HQ\nimport Halogen.Query.Input (Input)\nimport Halogen.Query.Input as Input\nimport Halogen.Subscription as HS\n\n-- | `RenderSpec` allows for alternative driver implementations without the need\n-- | to provide all of the driver machinery again, focusing just on the code\n-- | needed to render components.\n-- |\n-- | The type variables are as follows:\n-- | - `h` is the type of value being rendered (`Halogen.HTML.Core.HTML`, for\n-- |   example).\n-- | - `r` is the type for the \"render state\" for the driver. This is a value\n-- |   that is stored for each component, that allows the driver to persist\n-- |   state between each rendering of a component. This will differ entirely\n-- |   for each driver. `r` accepts a number of parameters that will be\n-- |   explained below.\n-- |\n-- | The \"inner\" type variables, used by `r` and the other functions are as\n-- | follows:\n-- | - `s` is the state type for the component.\n-- | - `act` is the action type for the component\n-- | - `ps` is the set of slots for addressing child components\n-- | - `o` is the output message type for the component\n-- |\n-- | Note that none of these variables can escape `RenderSpec`'s functions. They\n-- | need to be instantiated with each function call, as the same `RenderSpec`\n-- | is used to deal with all components in the hierarchy.\n-- |\n-- | The `render` function is the main part of the spec, it accepts:\n-- | - A \"handler\" function, for evaluating component queries. This is used to\n-- |   implement event handlers in HTML-based drivers.\n-- | - A \"child\" function for dealing with the rendering of children, returning\n-- |   the render state for the child component in an existentially hidden\n-- |   package. This return value would commonly be used to extract the rendered\n-- |   subtree for the child to graft it in place of the child slot. The\n-- |   existential package can be unwrapped with `Halogen.Aff.Driver.State.unRenderStateX`.\n-- | - The `h` value to render, parameterised by the slot type for the\n-- |   component's children. This slot type is what the \"child\" function\n-- |   accepts.\n-- | - The previous render state for the component. If the component has not\n-- |   previously been initalized, this will be `Nothing`.\n-- |\n-- | The render function then returns the updated (or initial) render state for\n-- | the component, which will be fed back into `render` the next time the\n-- | component needs to update.\n-- |\n-- | The `renderChild` function's behaviour will be highly dependant on the\n-- | particular driver implementing `RenderSpec`. Its purpose is to take a\n-- | driver render state for a component and produce a new one that may remap\n-- | the rendered value to be something more suitable for grafting during\n-- | `render` of the parent. For the built-in `halogen-vdom` driver this is\n-- | just `identity`. For the `virtual-dom` driver it wraps the rendered HTML\n-- | in a widget, to prevent the `virtual-dom` algorithm from re-diffing\n-- | values that we know are unchanged.\n-- |\n-- | The `removeChild` function is for drivers that need to perform some special\n-- | cleanup when removing a component from the hierarchy. In the `halogen-vdom`\n-- | driver this actually performs the `removeChild` from the DOM. For the\n-- | `virtual-dom` driver nothing needs to happen here, so it is\n-- | `const (pure unit)`.\n-- |\n-- | The `dispose` function is called when the top level component is disposed of\n-- | via `HalogenIO`.\ntype RenderSpec r =\n  { render ::\n      forall s act ps o\n       . (Input act -> Effect Unit)\n      -> (ComponentSlotBox ps Aff act -> Effect (RenderStateX r))\n      -> HC.HTML (ComponentSlot ps Aff act) act\n      -> Maybe (r s act ps o)\n      -> Effect (r s act ps o)\n  , renderChild :: forall s act ps o. r s act ps o -> r s act ps o\n  , removeChild :: forall s act ps o. r s act ps o -> Effect Unit\n  , dispose :: forall s act ps o. r s act ps o -> Effect Unit\n  }\n\nrunUI\n  :: forall r f i o\n   . RenderSpec r\n  -> Component f i o Aff\n  -> i\n  -> Aff (HalogenIO f o Aff)\nrunUI renderSpec component i = do\n  lchs <- liftEffect newLifecycleHandlers\n  disposed <- liftEffect $ Ref.new false\n  Eval.handleLifecycle lchs do\n    sio <- HS.create\n    dsx <- Ref.read =<< runComponent lchs (liftEffect <<< HS.notify sio.listener) i component\n    dsx # unDriverStateX \\st -> pure\n      { query: evalDriver disposed st.selfRef\n      , messages: sio.emitter\n      , dispose: dispose disposed lchs dsx\n      }\n  where\n  evalDriver\n    :: forall s f' act ps i' o'\n     . Ref Boolean\n    -> Ref (DriverState r s f' act ps i' o')\n    -> (forall a. f' a -> Aff (Maybe a))\n  evalDriver disposed ref q =\n    liftEffect (Ref.read disposed) >>=\n      if _ then pure Nothing\n      else Eval.evalQ render ref q\n\n  runComponent\n    :: forall f' i' o'\n     . Ref LifecycleHandlers\n    -> (o' -> Aff Unit)\n    -> i'\n    -> Component f' i' o' Aff\n    -> Effect (Ref (DriverStateX r f' o'))\n  runComponent lchs handler j = unComponent \\c -> do\n    lchs' <- newLifecycleHandlers\n    var <- initDriverState c j handler lchs'\n    pre <- Ref.read lchs\n    Ref.write { initializers: L.Nil, finalizers: pre.finalizers } lchs\n    unDriverStateX (render lchs <<< _.selfRef) =<< Ref.read var\n    squashChildInitializers lchs pre.initializers =<< Ref.read var\n    pure var\n\n  render\n    :: forall s f' act ps i' o'\n     . Ref LifecycleHandlers\n    -> Ref (DriverState r s f' act ps i' o')\n    -> Effect Unit\n  render lchs var = Ref.read var >>= \\(DriverState ds) -> do\n    shouldProcessHandlers <- isNothing <$> Ref.read ds.pendingHandlers\n    when shouldProcessHandlers $ Ref.write (Just L.Nil) ds.pendingHandlers\n    Ref.write Slot.empty ds.childrenOut\n    Ref.write ds.children ds.childrenIn\n\n    let\n      -- The following 3 defs are working around a capture bug, see #586\n      pendingHandlers = identity ds.pendingHandlers\n      pendingQueries = identity ds.pendingQueries\n      selfRef = identity ds.selfRef\n\n      handler :: Input act -> Aff Unit\n      handler = Eval.queueOrRun pendingHandlers <<< void <<< Eval.evalF render selfRef\n\n      childHandler :: act -> Aff Unit\n      childHandler = Eval.queueOrRun pendingQueries <<< handler <<< Input.Action\n\n    rendering <-\n      renderSpec.render\n        (Eval.handleAff <<< handler)\n        (renderChild lchs childHandler ds.childrenIn ds.childrenOut)\n        (ds.component.render ds.state)\n        ds.rendering\n\n    children <- Ref.read ds.childrenOut\n    childrenIn <- Ref.read ds.childrenIn\n\n    Slot.foreachSlot childrenIn \\(DriverStateRef childVar) -> do\n      childDS <- Ref.read childVar\n      renderStateX_ renderSpec.removeChild childDS\n      finalize lchs childDS\n\n    flip Ref.modify_ ds.selfRef $ mapDriverState \\ds' ->\n      ds' { rendering = Just rendering, children = children }\n\n    when shouldProcessHandlers do\n      flip tailRecM unit \\_ -> do\n        handlers <- Ref.read pendingHandlers\n        Ref.write (Just L.Nil) pendingHandlers\n        traverse_ (Eval.handleAff <<< traverse_ fork <<< L.reverse) handlers\n        mmore <- Ref.read pendingHandlers\n        if maybe false L.null mmore then Ref.write Nothing pendingHandlers $> Done unit\n        else pure $ Loop unit\n\n  renderChild\n    :: forall ps act\n     . Ref LifecycleHandlers\n    -> (act -> Aff Unit)\n    -> Ref (Slot.SlotStorage ps (DriverStateRef r))\n    -> Ref (Slot.SlotStorage ps (DriverStateRef r))\n    -> ComponentSlotBox ps Aff act\n    -> Effect (RenderStateX r)\n  renderChild lchs handler childrenInRef childrenOutRef =\n    unComponentSlot \\slot -> do\n      childrenIn <- slot.pop <$> Ref.read childrenInRef\n      var <- case childrenIn of\n        Just (Tuple (DriverStateRef existing) childrenIn') -> do\n          Ref.write childrenIn' childrenInRef\n          dsx <- Ref.read existing\n          dsx # unDriverStateX \\st -> do\n            flip Ref.write st.handlerRef $ maybe (pure unit) handler <<< slot.output\n            Eval.handleAff $ Eval.evalM render st.selfRef (st.component.eval (HQ.Receive slot.input unit))\n          pure existing\n        Nothing ->\n          runComponent lchs (maybe (pure unit) handler <<< slot.output) slot.input slot.component\n      isDuplicate <- isJust <<< slot.get <$> Ref.read childrenOutRef\n      when isDuplicate\n        $ warn \"Halogen: Duplicate slot address was detected during rendering, unexpected results may occur\"\n      Ref.modify_ (slot.set $ DriverStateRef var) childrenOutRef\n      Ref.read var >>= renderStateX case _ of\n        Nothing -> throw \"Halogen internal error: child was not initialized in renderChild\"\n        Just r -> pure (renderSpec.renderChild r)\n\n  squashChildInitializers\n    :: forall f' o'\n     . Ref LifecycleHandlers\n    -> L.List (Aff Unit)\n    -> DriverStateX r f' o'\n    -> Effect Unit\n  squashChildInitializers lchs preInits =\n    unDriverStateX \\st -> do\n      let parentInitializer = Eval.evalM render st.selfRef (st.component.eval (HQ.Initialize unit))\n      lchs # Ref.modify_ \\handlers ->\n        { initializers:\n            ( do\n                parSequence_ (L.reverse handlers.initializers)\n                parentInitializer\n                liftEffect do\n                  handlePending st.pendingQueries\n                  handlePending st.pendingOuts\n            ) : preInits\n        , finalizers: handlers.finalizers\n        }\n\n  finalize\n    :: forall f' o'\n     . Ref LifecycleHandlers\n    -> DriverStateX r f' o'\n    -> Effect Unit\n  finalize lchs = do\n    unDriverStateX \\st -> do\n      cleanupSubscriptionsAndForks (DriverState st)\n      let f = Eval.evalM render st.selfRef (st.component.eval (HQ.Finalize unit))\n      lchs # Ref.modify_ \\handlers ->\n        { initializers: handlers.initializers\n        , finalizers: f : handlers.finalizers\n        }\n      Slot.foreachSlot st.children \\(DriverStateRef ref) -> do\n        dsx <- Ref.read ref\n        finalize lchs dsx\n\n  dispose\n    :: forall f' o'\n     . Ref Boolean\n    -> Ref LifecycleHandlers\n    -> DriverStateX r f' o'\n    -> Aff Unit\n  dispose disposed lchs dsx = Eval.handleLifecycle lchs do\n    Ref.read disposed >>=\n      if _ then\n        pure unit\n      else do\n        Ref.write true disposed\n        finalize lchs dsx\n        dsx # unDriverStateX \\{ selfRef } -> do\n          (DriverState ds) <- liftEffect $ Ref.read selfRef\n          for_ ds.rendering renderSpec.dispose\n\nnewLifecycleHandlers :: Effect (Ref LifecycleHandlers)\nnewLifecycleHandlers = Ref.new { initializers: L.Nil, finalizers: L.Nil }\n\nhandlePending :: Ref (Maybe (L.List (Aff Unit))) -> Effect Unit\nhandlePending ref = do\n  queue <- Ref.read ref\n  Ref.write Nothing ref\n  for_ queue (Eval.handleAff <<< traverse_ fork <<< L.reverse)\n\ncleanupSubscriptionsAndForks\n  :: forall r s f act ps i o\n   . DriverState r s f act ps i o\n  -> Effect Unit\ncleanupSubscriptionsAndForks (DriverState ds) = do\n  traverse_ (traverse_ HS.unsubscribe) =<< Ref.read ds.subscriptions\n  Ref.write Nothing ds.subscriptions\n  traverse_ (Eval.handleAff <<< killFiber (error \"finalized\")) =<< Ref.read ds.forks\n  Ref.write M.empty ds.forks\n", "var getEffProp = function (name) {\n  return function (node) {\n    return function () {\n      return node[name];\n    };\n  };\n};\n\nexport function nodeTypeIndex(node) {\n  return node.nodeType;\n}\n\nexport function nodeName(node) {\n  return node.nodeName;\n}\n\nexport const baseURI = getEffProp(\"baseURI\");\nexport const _ownerDocument = getEffProp(\"ownerDocument\");\nexport const _parentNode = getEffProp(\"parentNode\");\nexport const _parentElement = getEffProp(\"parentElement\");\n\nexport function hasChildNodes(node) {\n  return function () {\n    return node.hasChildNodes();\n  };\n}\n\nexport const childNodes = getEffProp(\"childNodes\");\nexport const _firstChild = getEffProp(\"firstChild\");\nexport const _lastChild = getEffProp(\"lastChild\");\nexport const _previousSibling = getEffProp(\"previousSibling\");\nexport const _nextSibling = getEffProp(\"nextSibling\");\nexport const _nodeValue = getEffProp(\"nodeValue\");\n\nexport function setNodeValue(value) {\n  return function (node) {\n    return function () {\n      node.nodeValue = value;\n    };\n  };\n}\n\nexport const textContent = getEffProp(\"textContent\");\n\nexport function setTextContent(value) {\n  return function (node) {\n    return function () {\n      node.textContent = value;\n    };\n  };\n}\n\nexport function normalize(node) {\n  return function () {\n    node.normalize();\n  };\n}\n\nexport function clone(node) {\n  return function () {\n    return node.cloneNode(false);\n  };\n}\n\nexport function deepClone(node) {\n  return function () {\n    return node.cloneNode(true);\n  };\n}\n\nexport function isEqualNode(node1) {\n  return function (node2) {\n    return function () {\n      return node1.isEqualNode(node2);\n    };\n  };\n}\n\nexport function compareDocumentPositionBits(node1) {\n  return function (node2) {\n    return function () {\n      return node1.compareDocumentPosition(node2);\n    };\n  };\n}\n\nexport function contains(node1) {\n  return function (node2) {\n    return function () {\n      return node1.contains(node2);\n    };\n  };\n}\n\nexport function _lookupPrefix(prefix) {\n  return function (node) {\n    return function () {\n      return node.lookupPrefix(prefix);\n    };\n  };\n}\n\nexport function _lookupNamespaceURI(ns) {\n  return function (node) {\n    return function () {\n      return node.lookupNamespaceURI(ns);\n    };\n  };\n}\n\nexport function isDefaultNamespace(ns) {\n  return function (node) {\n    return function () {\n      return node.isDefaultNamespace(ns);\n    };\n  };\n}\n\nexport function insertBefore(node1) {\n  return function (node2) {\n    return function (parent) {\n      return function () {\n        parent.insertBefore(node1, node2);\n      };\n    };\n  };\n}\n\nexport function appendChild(node) {\n  return function (parent) {\n    return function () {\n      parent.appendChild(node);\n    };\n  };\n}\n\nexport function replaceChild(newChild) {\n  return function (oldChild) {\n    return function (parent) {\n      return function () {\n        parent.replaceChild(newChild, oldChild);\n      };\n    };\n  };\n}\n\nexport function removeChild(node) {\n  return function (parent) {\n    return function () {\n      parent.removeChild(node);\n    };\n  };\n}\n", "module Web.DOM.Node\n  ( module Exports\n  , fromEventTarget\n  , toEventTarget\n  , nodeType\n  , nodeTypeIndex\n  , nodeName\n  , baseURI\n  , ownerDocument\n  , parentNode\n  , parentElement\n  , hasChildNodes\n  , childNodes\n  , firstChild\n  , lastChild\n  , previousSibling\n  , nextSibling\n  , nodeValue\n  , setNodeValue\n  , textContent\n  , setTextContent\n  , normalize\n  , clone\n  , deepClone\n  , isEqualNode\n  , compareDocumentPositionBits\n  , contains\n  , lookupPrefix\n  , lookupNamespaceURI\n  , isDefaultNamespace\n  , insertBefore\n  , appendChild\n  , replaceChild\n  , removeChild\n  ) where\n\nimport Prelude\n\nimport Data.Enum (toEnum)\nimport Data.Maybe (Maybe, fromJust)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Document (Document)\nimport Web.DOM.Element (Element)\nimport Web.DOM.Internal.Types (Node) as Exports\nimport Web.DOM.Internal.Types (Node, NodeList)\nimport Web.DOM.NodeType (NodeType)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nfromEventTarget :: EventTarget -> Maybe Node\nfromEventTarget = unsafeReadProtoTagged \"Node\"\n\ntoEventTarget :: Node -> EventTarget\ntoEventTarget = unsafeCoerce\n\n-- | The type of a node.\nnodeType :: Partial => Node -> NodeType\nnodeType = fromJust <<< toEnum <<< nodeTypeIndex\n\n-- | The numeric value for the type of a node.\nforeign import nodeTypeIndex :: Node -> Int\n\n-- | For elements this is the tag name, for document types this is the doctype\n-- | name, for processing instructions this is the target, for all other nodes\n-- | it is a string like `\"#text\"`, `\"#comment\", etc. depending on the node\n-- | type.\nforeign import nodeName :: Node -> String\n\n-- | The node's base URL.\nforeign import baseURI :: Node -> Effect String\n\n-- | The document the node belongs to, unless the node is a document in which\n-- | case the value is Nothing.\nownerDocument :: Node -> Effect (Maybe Document)\nownerDocument = map toMaybe <<< _ownerDocument\n\nforeign import _ownerDocument :: Node -> Effect (Nullable Document)\n\n-- | The parent node of the node.\nparentNode :: Node -> Effect (Maybe Node)\nparentNode = map toMaybe <<< _parentNode\n\nforeign import _parentNode :: Node -> Effect (Nullable Node)\n\n-- | The parent element of the node.\nparentElement :: Node -> Effect (Maybe Element)\nparentElement = map toMaybe <<< _parentElement\n\nforeign import _parentElement :: Node -> Effect (Nullable Element)\n\n-- | Indicates whether the node has any child nodes.\nforeign import hasChildNodes :: Node -> Effect Boolean\n\n-- | The children of the node.\nforeign import childNodes :: Node -> Effect NodeList\n\n-- | The first child of the node, or Nothing if the node has no children.\nfirstChild :: Node -> Effect (Maybe Node)\nfirstChild = map toMaybe <<< _firstChild\n\nforeign import _firstChild :: Node -> Effect (Nullable Node)\n\n\n-- | The last child of the node, or Nothing if the node has no children.\nlastChild :: Node -> Effect (Maybe Node)\nlastChild = map toMaybe <<< _lastChild\n\nforeign import _lastChild :: Node -> Effect (Nullable Node)\n\n-- | The previous sibling node, or Nothing if there is no previous sibling.\npreviousSibling :: Node -> Effect (Maybe Node)\npreviousSibling = map toMaybe <<< _previousSibling\n\nforeign import _previousSibling :: Node -> Effect (Nullable Node)\n\n-- | The next sibling node, or Nothing if there is no next sibling.\nnextSibling :: Node -> Effect (Maybe Node)\nnextSibling = map toMaybe <<< _nextSibling\n\nforeign import _nextSibling :: Node -> Effect (Nullable Node)\n\n-- | If the node type is text, comment, or processing instruction this is\n-- | `Just` the node's data, or `Nothing` in all other cases.\nnodeValue :: Node -> Effect (Maybe String)\nnodeValue = map toMaybe <<< _nodeValue\n\nforeign import _nodeValue :: Node -> Effect (Nullable String)\n\n-- | If the node type is text, comment, or processing instruction this allows\n-- | the node's data to be changed, or has no effect in all other cases.\nforeign import setNodeValue :: String -> Node -> Effect Unit\n\n-- | If the node type is document fragment, element, text, processing\n-- | instruction, or comment this is the node's data, or null in all other\n-- | cases.\nforeign import textContent :: Node -> Effect String\n\n-- | If the node type is document fragment, element, text, processing\n-- | instruction, or comment this allows the node's data to be changed, or has\n-- | no effect in all other cases.\nforeign import setTextContent :: String -> Node -> Effect Unit\n\n-- | Removes empty text nodes and then combines any remaining text nodes that\n-- | are contiguous.\nforeign import normalize :: Node -> Effect Unit\n\n-- | Clones the node without cloning the node's descendants.\nforeign import clone :: Node -> Effect Node\n\n-- | Clones the node and its descendants.\nforeign import deepClone :: Node -> Effect Node\n\n-- | Checks whether two nodes are equivalent.\nforeign import isEqualNode :: Node -> Node -> Effect Boolean\n\n-- TODO: compareDocumentPosition that returns a semigroup or something instead of the bitmask value\n\n-- | Compares the position of two nodes in the document.\nforeign import compareDocumentPositionBits :: Node -> Node -> Effect Int\n\n-- | Checks whether the second node is contained within the first\nforeign import contains :: Node -> Node -> Effect Boolean\n\nlookupPrefix :: String -> Node -> Effect (Maybe String)\nlookupPrefix p = map toMaybe <<< _lookupPrefix p\n\nforeign import _lookupPrefix :: String -> Node -> Effect (Nullable String)\n\nlookupNamespaceURI :: String -> Node -> Effect (Maybe String)\nlookupNamespaceURI ns = map toMaybe <<< _lookupNamespaceURI ns\n\nforeign import _lookupNamespaceURI :: String -> Node -> Effect (Nullable String)\n\nforeign import isDefaultNamespace :: String -> Node -> Effect Boolean\n\n-- | Inserts the first node before the second as a child of the third node.\nforeign import insertBefore :: Node -> Node -> Node -> Effect Unit\n\n-- | Appends the first node to the child node list of the second node.\nforeign import appendChild :: Node -> Node -> Effect Unit\n\n-- | Uses the first node as a replacement for the second node in the children\n-- | of the third node.\nforeign import replaceChild :: Node -> Node -> Node -> Effect Unit\n\n-- | Removes the first node from the children of the second node.\nforeign import removeChild :: Node -> Node -> Effect Unit\n", "module Halogen.VDom.Driver\n  ( runUI\n  , module Halogen.Aff.Driver\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (traverse_)\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (unwrap)\nimport Effect (Effect)\nimport Effect.Aff (Aff)\nimport Effect.Class (liftEffect)\nimport Effect.Ref (Ref)\nimport Effect.Ref as Ref\nimport Effect.Uncurried as EFn\nimport Halogen.Aff.Driver (HalogenIO)\nimport Halogen.Aff.Driver as AD\nimport Halogen.Aff.Driver.State (RenderStateX, unRenderStateX)\nimport Halogen.Component (Component, ComponentSlot(..), ComponentSlotBox)\nimport Halogen.HTML.Core (HTML(..), Prop)\nimport Halogen.Query.Input (Input)\nimport Halogen.VDom as V\nimport Halogen.VDom.DOM.Prop as VP\nimport Halogen.VDom.Thunk (Thunk)\nimport Halogen.VDom.Thunk as Thunk\nimport Unsafe.Reference (unsafeRefEq)\nimport Web.DOM.Document (Document) as DOM\nimport Web.DOM.Element (Element) as DOM\nimport Web.DOM.Node (Node, appendChild, removeChild, parentNode, nextSibling, insertBefore) as DOM\nimport Web.HTML (window) as DOM\nimport Web.HTML.HTMLDocument as HTMLDocument\nimport Web.HTML.HTMLElement (HTMLElement) as DOM\nimport Web.HTML.HTMLElement as HTMLElement\nimport Web.HTML.Window (document) as DOM\n\ntype VHTML action slots =\n  V.VDom (Array (Prop (Input action))) (ComponentSlot slots Aff action)\n\ntype ChildRenderer action slots = ComponentSlotBox slots Aff action -> Effect (RenderStateX RenderState)\n\nnewtype RenderState state action slots output =\n  RenderState\n    { node :: DOM.Node\n    , machine :: V.Step (VHTML action slots) DOM.Node\n    , renderChildRef :: Ref (ChildRenderer action slots)\n    }\n\ntype HTMLThunk slots action =\n  Thunk (HTML (ComponentSlot slots Aff action)) action\n\ntype WidgetState slots action =\n  Maybe (V.Step (HTMLThunk slots action) DOM.Node)\n\nmkSpec\n  :: forall action slots\n   . (Input action -> Effect Unit)\n  -> Ref (ChildRenderer action slots)\n  -> DOM.Document\n  -> V.VDomSpec\n       (Array (VP.Prop (Input action)))\n       (ComponentSlot slots Aff action)\nmkSpec handler renderChildRef document =\n  V.VDomSpec { buildWidget, buildAttributes, document }\n  where\n\n  buildAttributes\n    :: DOM.Element\n    -> V.Machine (Array (VP.Prop (Input action))) Unit\n  buildAttributes = VP.buildProp handler\n\n  buildWidget\n    :: V.VDomSpec\n         (Array (VP.Prop (Input action)))\n         (ComponentSlot slots Aff action)\n    -> V.Machine\n         (ComponentSlot slots Aff action)\n         DOM.Node\n  buildWidget spec = render\n    where\n\n    render :: V.Machine (ComponentSlot slots Aff action) DOM.Node\n    render = EFn.mkEffectFn1 \\slot ->\n      case slot of\n        ComponentSlot cs ->\n          EFn.runEffectFn1 renderComponentSlot cs\n        ThunkSlot t -> do\n          step <- EFn.runEffectFn1 buildThunk t\n          pure $ V.mkStep $ V.Step (V.extract step) (Just step) patch done\n\n    patch\n      :: EFn.EffectFn2 (WidgetState slots action)\n           (ComponentSlot slots Aff action)\n           (V.Step (ComponentSlot slots Aff action) DOM.Node)\n    patch = EFn.mkEffectFn2 \\st slot ->\n      case st of\n        Just step -> case slot of\n          ComponentSlot cs -> do\n            EFn.runEffectFn1 V.halt step\n            EFn.runEffectFn1 renderComponentSlot cs\n          ThunkSlot t -> do\n            step' <- EFn.runEffectFn2 V.step step t\n            pure $ V.mkStep $ V.Step (V.extract step') (Just step') patch done\n        _ -> EFn.runEffectFn1 render slot\n\n    buildThunk :: V.Machine (HTMLThunk slots action) DOM.Node\n    buildThunk = Thunk.buildThunk unwrap spec\n\n    renderComponentSlot\n      :: EFn.EffectFn1\n           (ComponentSlotBox slots Aff action)\n           (V.Step (ComponentSlot slots Aff action) DOM.Node)\n    renderComponentSlot = EFn.mkEffectFn1 \\cs -> do\n      renderChild <- Ref.read renderChildRef\n      rsx <- renderChild cs\n      let node = getNode rsx\n      pure $ V.mkStep $ V.Step node Nothing patch done\n\n  done :: EFn.EffectFn1 (WidgetState slots action) Unit\n  done = EFn.mkEffectFn1 \\st ->\n    case st of\n      Just step -> EFn.runEffectFn1 V.halt step\n      _ -> pure unit\n\n  getNode :: RenderStateX RenderState -> DOM.Node\n  getNode = unRenderStateX (\\(RenderState { node }) -> node)\n\nrunUI\n  :: forall query input output\n   . Component query input output Aff\n  -> input\n  -> DOM.HTMLElement\n  -> Aff (HalogenIO query output Aff)\nrunUI component i element = do\n  document <- liftEffect $ HTMLDocument.toDocument <$> (DOM.document =<< DOM.window)\n  AD.runUI (renderSpec document element) component i\n\nrenderSpec\n  :: DOM.Document\n  -> DOM.HTMLElement\n  -> AD.RenderSpec RenderState\nrenderSpec document container =\n  { render\n  , renderChild: identity\n  , removeChild\n  , dispose: removeChild\n  }\n  where\n  render\n    :: forall state action slots output\n     . (Input action -> Effect Unit)\n    -> (ComponentSlotBox slots Aff action -> Effect (RenderStateX RenderState))\n    -> HTML (ComponentSlot slots Aff action) action\n    -> Maybe (RenderState state action slots output)\n    -> Effect (RenderState state action slots output)\n  render handler child (HTML vdom) =\n    case _ of\n      Nothing -> do\n        renderChildRef <- Ref.new child\n        let spec = mkSpec handler renderChildRef document\n        machine <- EFn.runEffectFn1 (V.buildVDom spec) vdom\n        let node = V.extract machine\n        void $ DOM.appendChild node (HTMLElement.toNode container)\n        pure $ RenderState { machine, node, renderChildRef }\n      Just (RenderState { machine, node, renderChildRef }) -> do\n        Ref.write child renderChildRef\n        parent <- DOM.parentNode node\n        nextSib <- DOM.nextSibling node\n        machine' <- EFn.runEffectFn2 V.step machine vdom\n        let newNode = V.extract machine'\n        when (not unsafeRefEq node newNode) do\n          substInParent newNode nextSib parent\n        pure $ RenderState { machine: machine', node: newNode, renderChildRef }\n\nremoveChild :: forall state action slots output. RenderState state action slots output -> Effect Unit\nremoveChild (RenderState { node }) = do\n  npn <- DOM.parentNode node\n  traverse_ (\\pn -> DOM.removeChild node pn) npn\n\nsubstInParent :: DOM.Node -> Maybe DOM.Node -> Maybe DOM.Node -> Effect Unit\nsubstInParent newNode (Just sib) (Just pn) = void $ DOM.insertBefore newNode sib pn\nsubstInParent newNode Nothing (Just pn) = void $ DOM.appendChild newNode pn\nsubstInParent _ _ _ = pure unit\n", "module ViewRendered where\n\nimport Prelude\n\nimport Data.Foldable (traverse_)\nimport Effect.Aff (Aff)\nimport Effect.Class (liftEffect)\nimport Halogen.Aff as HA\nimport Web.DOM.Element (setAttribute)\nimport Web.DOM.ParentNode (QuerySelector(..))\nimport Web.HTML.HTMLElement (toElement)\n\nviewRendered :: Aff Unit\nviewRendered = HA.selectElement (QuerySelector \"#content\") >>= traverse_ \\el ->\n  liftEffect $ setAttribute \"view-rendered\" \"\" (toElement el) \n", "/* global Symbol */\n\nvar hasArrayFrom = typeof Array.from === \"function\";\nvar hasStringIterator =\n  typeof Symbol !== \"undefined\" &&\n  Symbol != null &&\n  typeof Symbol.iterator !== \"undefined\" &&\n  typeof String.prototype[Symbol.iterator] === \"function\";\nvar hasFromCodePoint = typeof String.prototype.fromCodePoint === \"function\";\nvar hasCodePointAt = typeof String.prototype.codePointAt === \"function\";\n\nexport const _unsafeCodePointAt0 = function (fallback) {\n  return hasCodePointAt\n    ? function (str) { return str.codePointAt(0); }\n    : fallback;\n};\n\nexport const _codePointAt = function (fallback) {\n  return function (Just) {\n    return function (Nothing) {\n      return function (unsafeCodePointAt0) {\n        return function (index) {\n          return function (str) {\n            var length = str.length;\n            if (index < 0 || index >= length) return Nothing;\n            if (hasStringIterator) {\n              var iter = str[Symbol.iterator]();\n              for (var i = index;; --i) {\n                var o = iter.next();\n                if (o.done) return Nothing;\n                if (i === 0) return Just(unsafeCodePointAt0(o.value));\n              }\n            }\n            return fallback(index)(str);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const _countPrefix = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasStringIterator) {\n      return function (pred) {\n        return function (str) {\n          var iter = str[Symbol.iterator]();\n          for (var cpCount = 0; ; ++cpCount) {\n            var o = iter.next();\n            if (o.done) return cpCount;\n            var cp = unsafeCodePointAt0(o.value);\n            if (!pred(cp)) return cpCount;\n          }\n        };\n      };\n    }\n    return fallback;\n  };\n};\n\nexport const _fromCodePointArray = function (singleton) {\n  return hasFromCodePoint\n    ? function (cps) {\n      // Function.prototype.apply will fail for very large second parameters,\n      // so we don't use it for arrays with 10,000 or more entries.\n      if (cps.length < 10e3) {\n        return String.fromCodePoint.apply(String, cps);\n      }\n      return cps.map(singleton).join(\"\");\n    }\n    : function (cps) {\n      return cps.map(singleton).join(\"\");\n    };\n};\n\nexport const _singleton = function (fallback) {\n  return hasFromCodePoint ? String.fromCodePoint : fallback;\n};\n\nexport const _take = function (fallback) {\n  return function (n) {\n    if (hasStringIterator) {\n      return function (str) {\n        var accum = \"\";\n        var iter = str[Symbol.iterator]();\n        for (var i = 0; i < n; ++i) {\n          var o = iter.next();\n          if (o.done) return accum;\n          accum += o.value;\n        }\n        return accum;\n      };\n    }\n    return fallback(n);\n  };\n};\n\nexport const _toCodePointArray = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasArrayFrom) {\n      return function (str) {\n        return Array.from(str, unsafeCodePointAt0);\n      };\n    }\n    return fallback;\n  };\n};\n", "-- | These functions allow PureScript strings to be treated as if they were\n-- | sequences of Unicode code points instead of their true underlying\n-- | implementation (sequences of UTF-16 code units). For nearly all uses of\n-- | strings, these functions should be preferred over the ones in\n-- | `Data.String.CodeUnits`.\nmodule Data.String.CodePoints\n  ( module Exports\n  , CodePoint\n  , codePointFromChar\n  , singleton\n  , fromCodePointArray\n  , toCodePointArray\n  , codePointAt\n  , uncons\n  , length\n  , countPrefix\n  , indexOf\n  , indexOf'\n  , lastIndexOf\n  , lastIndexOf'\n  , take\n  -- , takeRight\n  , takeWhile\n  , drop\n  -- , dropRight\n  , dropWhile\n  -- , slice\n  , splitAt\n  ) where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Enum (class BoundedEnum, class Enum, Cardinality(..), defaultPred, defaultSucc, fromEnum, toEnum, toEnumWithDefaults)\nimport Data.Int (hexadecimal, toStringAs)\nimport Data.Maybe (Maybe(..))\nimport Data.String.CodeUnits (contains, stripPrefix, stripSuffix) as Exports\nimport Data.String.CodeUnits as CU\nimport Data.String.Common (toUpper)\nimport Data.String.Pattern (Pattern)\nimport Data.String.Unsafe as Unsafe\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (unfoldr)\n\n-- | CodePoint is an `Int` bounded between `0` and `0x10FFFF`, corresponding to\n-- | Unicode code points.\nnewtype CodePoint = CodePoint Int\n\nderive instance eqCodePoint :: Eq CodePoint\nderive instance ordCodePoint :: Ord CodePoint\n\ninstance showCodePoint :: Show CodePoint where\n  show (CodePoint i) = \"(CodePoint 0x\" <> toUpper (toStringAs hexadecimal i) <> \")\"\n\ninstance boundedCodePoint :: Bounded CodePoint where\n  bottom = CodePoint 0\n  top = CodePoint 0x10FFFF\n\ninstance enumCodePoint :: Enum CodePoint where\n  succ = defaultSucc toEnum fromEnum\n  pred = defaultPred toEnum fromEnum\n\ninstance boundedEnumCodePoint :: BoundedEnum CodePoint where\n  cardinality = Cardinality (0x10FFFF + 1)\n  fromEnum (CodePoint n) = n\n  toEnum n\n    | n >= 0 && n <= 0x10FFFF = Just (CodePoint n)\n    | otherwise = Nothing\n\n-- | Creates a `CodePoint` from a given `Char`.\n-- |\n-- | ```purescript\n-- | >>> codePointFromChar 'B'\n-- | CodePoint 0x42 -- represents 'B'\n-- | ```\n-- |\ncodePointFromChar :: Char -> CodePoint\ncodePointFromChar = fromEnum >>> CodePoint\n\n-- | Creates a string containing just the given code point. Operates in\n-- | constant space and time.\n-- |\n-- | ```purescript\n-- | >>> map singleton (toEnum 0x1D400)\n-- | Just \"\uD835\uDC00\"\n-- | ```\n-- |\nsingleton :: CodePoint -> String\nsingleton = _singleton singletonFallback\n\nforeign import _singleton\n  :: (CodePoint -> String)\n  -> CodePoint\n  -> String\n\nsingletonFallback :: CodePoint -> String\nsingletonFallback (CodePoint cp) | cp <= 0xFFFF = fromCharCode cp\nsingletonFallback (CodePoint cp) =\n  let lead = ((cp - 0x10000) / 0x400) + 0xD800 in\n  let trail = (cp - 0x10000) `mod` 0x400 + 0xDC00 in\n  fromCharCode lead <> fromCharCode trail\n\n-- | Creates a string from an array of code points. Operates in space and time\n-- | linear to the length of the array.\n-- |\n-- | ```purescript\n-- | >>> codePointArray = toCodePointArray \"c \uD835\uDC00\"\n-- | >>> codePointArray\n-- | [CodePoint 0x63, CodePoint 0x20, CodePoint 0x1D400]\n-- | >>> fromCodePointArray codePointArray\n-- | \"c \uD835\uDC00\"\n-- | ```\n-- |\nfromCodePointArray :: Array CodePoint -> String\nfromCodePointArray = _fromCodePointArray singletonFallback\n\nforeign import _fromCodePointArray\n  :: (CodePoint -> String)\n  -> Array CodePoint\n  -> String\n\n-- | Creates an array of code points from a string. Operates in space and time\n-- | linear to the length of the string.\n-- |\n-- | ```purescript\n-- | >>> codePointArray = toCodePointArray \"b \uD835\uDC00\uD835\uDC00\"\n-- | >>> codePointArray\n-- | [CodePoint 0x62, CodePoint 0x20, CodePoint 0x1D400, CodePoint 0x1D400]\n-- | >>> map singleton codePointArray\n-- | [\"b\", \" \", \"\uD835\uDC00\", \"\uD835\uDC00\"]\n-- | ```\n-- |\ntoCodePointArray :: String -> Array CodePoint\ntoCodePointArray = _toCodePointArray toCodePointArrayFallback unsafeCodePointAt0\n\nforeign import _toCodePointArray\n  :: (String -> Array CodePoint)\n  -> (String -> CodePoint)\n  -> String\n  -> Array CodePoint\n\ntoCodePointArrayFallback :: String -> Array CodePoint\ntoCodePointArrayFallback s = unfoldr unconsButWithTuple s\n\nunconsButWithTuple :: String -> Maybe (Tuple CodePoint String)\nunconsButWithTuple s = (\\{ head, tail } -> Tuple head tail) <$> uncons s\n\n-- | Returns the first code point of the string after dropping the given number\n-- | of code points from the beginning, if there is such a code point. Operates\n-- | in constant space and in time linear to the given index.\n-- |\n-- | ```purescript\n-- | >>> codePointAt 1 \"\uD835\uDC00\uD835\uDC00\uD835\uDC00\uD835\uDC00\"\n-- | Just (CodePoint 0x1D400) -- represents \"\uD835\uDC00\"\n-- | -- compare to Data.String:\n-- | >>> charAt 1 \"\uD835\uDC00\uD835\uDC00\uD835\uDC00\uD835\uDC00\"\n-- | Just '\uFFFD'\n-- | ```\n-- |\ncodePointAt :: Int -> String -> Maybe CodePoint\ncodePointAt n _ | n < 0 = Nothing\ncodePointAt 0 \"\" = Nothing\ncodePointAt 0 s = Just (unsafeCodePointAt0 s)\ncodePointAt n s = _codePointAt codePointAtFallback Just Nothing unsafeCodePointAt0 n s\n\nforeign import _codePointAt\n  :: (Int -> String -> Maybe CodePoint)\n  -> (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> (String -> CodePoint)\n  -> Int\n  -> String\n  -> Maybe CodePoint\n\ncodePointAtFallback :: Int -> String -> Maybe CodePoint\ncodePointAtFallback n s = case uncons s of\n  Just { head, tail } -> if n == 0 then Just head else codePointAtFallback (n - 1) tail\n  _ -> Nothing\n\n-- | Returns a record with the first code point and the remaining code points\n-- | of the string. Returns `Nothing` if the string is empty. Operates in\n-- | constant space and time.\n-- |\n-- | ```purescript\n-- | >>> uncons \"\uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Just { head: CodePoint 0x1D400, tail: \"\uD835\uDC00 c \uD835\uDC00\" }\n-- | >>> uncons \"\"\n-- | Nothing\n-- | ```\n-- |\nuncons :: String -> Maybe { head :: CodePoint, tail :: String }\nuncons s = case CU.length s of\n  0 -> Nothing\n  1 -> Just { head: CodePoint (fromEnum (Unsafe.charAt 0 s)), tail: \"\" }\n  _ ->\n    let\n      cu0 = fromEnum (Unsafe.charAt 0 s)\n      cu1 = fromEnum (Unsafe.charAt 1 s)\n    in\n      if isLead cu0 && isTrail cu1\n        then Just { head: unsurrogate cu0 cu1, tail: CU.drop 2 s }\n        else Just { head: CodePoint cu0, tail: CU.drop 1 s }\n\n-- | Returns the number of code points in the string. Operates in constant\n-- | space and in time linear to the length of the string.\n-- |\n-- | ```purescript\n-- | >>> length \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | 8\n-- | -- compare to Data.String:\n-- | >>> length \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | 11\n-- | ```\n-- |\nlength :: String -> Int\nlength = Array.length <<< toCodePointArray\n\n-- | Returns the number of code points in the leading sequence of code points\n-- | which all match the given predicate. Operates in constant space and in\n-- | time linear to the length of the string.\n-- |\n-- | ```purescript\n-- | >>> countPrefix (\\c -> fromEnum c == 0x1D400) \"\uD835\uDC00\uD835\uDC00 b c \uD835\uDC00\"\n-- | 2\n-- | ```\n-- |\ncountPrefix :: (CodePoint -> Boolean) -> String -> Int\ncountPrefix = _countPrefix countFallback unsafeCodePointAt0\n\nforeign import _countPrefix\n  :: ((CodePoint -> Boolean) -> String -> Int)\n  -> (String -> CodePoint)\n  -> (CodePoint -> Boolean)\n  -> String\n  -> Int\n\ncountFallback :: (CodePoint -> Boolean) -> String -> Int\ncountFallback p s = countTail p s 0\n\ncountTail :: (CodePoint -> Boolean) -> String -> Int -> Int\ncountTail p s accum = case uncons s of\n  Just { head, tail } -> if p head then countTail p tail (accum + 1) else accum\n  _ -> accum\n\n-- | Returns the number of code points preceding the first match of the given\n-- | pattern in the string. Returns `Nothing` when no matches are found.\n-- |\n-- | ```purescript\n-- | >>> indexOf (Pattern \"\uD835\uDC00\") \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Just 2\n-- | >>> indexOf (Pattern \"o\") \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Nothing\n-- | ```\n-- |\nindexOf :: Pattern -> String -> Maybe Int\nindexOf p s = (\\i -> length (CU.take i s)) <$> CU.indexOf p s\n\n-- | Returns the number of code points preceding the first match of the given\n-- | pattern in the string. Pattern matches preceding the given index will be\n-- | ignored. Returns `Nothing` when no matches are found.\n-- |\n-- | ```purescript\n-- | >>> indexOf' (Pattern \"\uD835\uDC00\") 4 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Just 7\n-- | >>> indexOf' (Pattern \"o\") 4 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Nothing\n-- | ```\n-- |\nindexOf' :: Pattern -> Int -> String -> Maybe Int\nindexOf' p i s =\n  let s' = drop i s in\n  (\\k -> i + length (CU.take k s')) <$> CU.indexOf p s'\n\n-- | Returns the number of code points preceding the last match of the given\n-- | pattern in the string. Returns `Nothing` when no matches are found.\n-- |\n-- | ```purescript\n-- | >>> lastIndexOf (Pattern \"\uD835\uDC00\") \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Just 7\n-- | >>> lastIndexOf (Pattern \"o\") \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Nothing\n-- | ```\n-- |\nlastIndexOf :: Pattern -> String -> Maybe Int\nlastIndexOf p s = (\\i -> length (CU.take i s)) <$> CU.lastIndexOf p s\n\n-- | Returns the number of code points preceding the first match of the given\n-- | pattern in the string. Pattern matches following the given index will be\n-- | ignored.\n-- |\n-- | Giving a negative index is equivalent to giving 0 and giving an index\n-- | greater than the number of code points in the string is equivalent to\n-- | searching in the whole string.\n-- |\n-- | Returns `Nothing` when no matches are found.\n-- |\n-- | ```purescript\n-- | >>> lastIndexOf' (Pattern \"\uD835\uDC00\") (-1) \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Nothing\n-- | >>> lastIndexOf' (Pattern \"\uD835\uDC00\") 0 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Nothing\n-- | >>> lastIndexOf' (Pattern \"\uD835\uDC00\") 5 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Just 3\n-- | >>> lastIndexOf' (Pattern \"\uD835\uDC00\") 8 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Just 7\n-- | >>> lastIndexOf' (Pattern \"o\") 5 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | Nothing\n-- | ```\n-- |\nlastIndexOf' :: Pattern -> Int -> String -> Maybe Int\nlastIndexOf' p i s =\n  let i' = CU.length (take i s) in\n  (\\k -> length (CU.take k s)) <$> CU.lastIndexOf' p i' s\n\n-- | Returns a string containing the given number of code points from the\n-- | beginning of the given string. If the string does not have that many code\n-- | points, returns the empty string. Operates in constant space and in time\n-- | linear to the given number.\n-- |\n-- | ```purescript\n-- | >>> take 3 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | \"b \uD835\uDC00\"\n-- | -- compare to Data.String:\n-- | >>> take 3 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | \"b \uFFFD\"\n-- | ```\n-- |\ntake :: Int -> String -> String\ntake = _take takeFallback\n\nforeign import _take :: (Int -> String -> String) -> Int -> String -> String\n\ntakeFallback :: Int -> String -> String\ntakeFallback n _ | n < 1 = \"\"\ntakeFallback n s = case uncons s of\n  Just { head, tail } -> singleton head <> takeFallback (n - 1) tail\n  _ -> s\n\n-- | Returns a string containing the leading sequence of code points which all\n-- | match the given predicate from the string. Operates in constant space and\n-- | in time linear to the length of the string.\n-- |\n-- | ```purescript\n-- | >>> takeWhile (\\c -> fromEnum c == 0x1D400) \"\uD835\uDC00\uD835\uDC00 b c \uD835\uDC00\"\n-- | \"\uD835\uDC00\uD835\uDC00\"\n-- | ```\n-- |\ntakeWhile :: (CodePoint -> Boolean) -> String -> String\ntakeWhile p s = take (countPrefix p s) s\n\n-- | Drops the given number of code points from the beginning of the string. If\n-- | the string does not have that many code points, returns the empty string.\n-- | Operates in constant space and in time linear to the given number.\n-- |\n-- | ```purescript\n-- | >>> drop 5 \"\uD835\uDC00\uD835\uDC00 b c\"\n-- | \"c\"\n-- | -- compared to Data.String:\n-- | >>> drop 5 \"\uD835\uDC00\uD835\uDC00 b c\"\n-- | \"b c\" -- because \"\uD835\uDC00\" occupies 2 code units\n-- | ```\n-- |\ndrop :: Int -> String -> String\ndrop n s = CU.drop (CU.length (take n s)) s\n\n-- | Drops the leading sequence of code points which all match the given\n-- | predicate from the string. Operates in constant space and in time linear\n-- | to the length of the string.\n-- |\n-- | ```purescript\n-- | >>> dropWhile (\\c -> fromEnum c == 0x1D400) \"\uD835\uDC00\uD835\uDC00 b c \uD835\uDC00\"\n-- | \" b c \uD835\uDC00\"\n-- | ```\n-- |\ndropWhile :: (CodePoint -> Boolean) -> String -> String\ndropWhile p s = drop (countPrefix p s) s\n\n-- | Splits a string into two substrings, where `before` contains the code\n-- | points up to (but not including) the given index, and `after` contains the\n-- | rest of the string, from that index on.\n-- |\n-- | ```purescript\n-- | >>> splitAt 3 \"b \uD835\uDC00\uD835\uDC00 c \uD835\uDC00\"\n-- | { before: \"b \uD835\uDC00\", after: \"\uD835\uDC00 c \uD835\uDC00\" }\n-- | ```\n-- |\n-- | Thus the length of `(splitAt i s).before` will equal either `i` or\n-- | `length s`, if that is shorter. (Or if `i` is negative the length will be\n-- | 0.)\n-- |\n-- | In code:\n-- | ```purescript\n-- | length (splitAt i s).before == min (max i 0) (length s)\n-- | (splitAt i s).before <> (splitAt i s).after == s\n-- | splitAt i s == {before: take i s, after: drop i s}\n-- | ```\nsplitAt :: Int -> String -> { before :: String, after :: String }\nsplitAt i s =\n  let before = take i s in\n  { before\n  -- inline drop i s to reuse the result of take i s\n  , after: CU.drop (CU.length before) s\n  }\n\nunsurrogate :: Int -> Int -> CodePoint\nunsurrogate lead trail = CodePoint ((lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000)\n\nisLead :: Int -> Boolean\nisLead cu = 0xD800 <= cu && cu <= 0xDBFF\n\nisTrail :: Int -> Boolean\nisTrail cu = 0xDC00 <= cu && cu <= 0xDFFF\n\nfromCharCode :: Int -> String\nfromCharCode = CU.singleton <<< toEnumWithDefaults bottom top\n\n-- WARN: this function expects the String parameter to be non-empty\nunsafeCodePointAt0 :: String -> CodePoint\nunsafeCodePointAt0 = _unsafeCodePointAt0 unsafeCodePointAt0Fallback\n\nforeign import _unsafeCodePointAt0\n  :: (String -> CodePoint)\n  -> String\n  -> CodePoint\n\nunsafeCodePointAt0Fallback :: String -> CodePoint\nunsafeCodePointAt0Fallback s =\n  let\n    cu0 = fromEnum (Unsafe.charAt 0 s)\n  in\n    if isLead cu0 && CU.length s > 1\n       then\n         let cu1 = fromEnum (Unsafe.charAt 1 s) in\n         if isTrail cu1 then unsurrogate cu0 cu1 else CodePoint cu0\n       else\n         CodePoint cu0\n", "var getEffProp = function (name) {\n  return function (doc) {\n    return function () {\n      return doc[name];\n    };\n  };\n};\n\nexport const url = getEffProp(\"URL\");\nexport const documentURI = getEffProp(\"documentURI\");\nexport const origin = getEffProp(\"origin\");\nexport const compatMode = getEffProp(\"compatMode\");\nexport const characterSet = getEffProp(\"characterSet\");\nexport const contentType = getEffProp(\"contentType\");\nexport function _doctype(doc) {\n  return doc[\"doctype\"];\n}\nexport const _documentElement = getEffProp(\"documentElement\");\n\nexport function getElementsByTagName(localName) {\n  return function (doc) {\n    return function () {\n      return doc.getElementsByTagName(localName);\n    };\n  };\n}\n\nexport function _getElementsByTagNameNS(ns) {\n  return function (localName) {\n    return function (doc) {\n      return function () {\n        return doc.getElementsByTagNameNS(ns, localName);\n      };\n    };\n  };\n}\n\nexport function getElementsByClassName(classNames) {\n  return function (doc) {\n    return function () {\n      return doc.getElementsByClassName(classNames);\n    };\n  };\n}\n\nexport function createElement(localName) {\n  return function (doc) {\n    return function () {\n      return doc.createElement(localName);\n    };\n  };\n}\n\nexport function _createElementNS(ns) {\n  return function (qualifiedName) {\n    return function (doc) {\n      return function () {\n        return doc.createElementNS(ns, qualifiedName);\n      };\n    };\n  };\n}\n\nexport function createDocumentFragment(doc) {\n  return function () {\n    return doc.createDocumentFragment();\n  };\n}\n\nexport function createTextNode(data) {\n  return function (doc) {\n    return function () {\n      return doc.createTextNode(data);\n    };\n  };\n}\n\nexport function createComment(data) {\n  return function (doc) {\n    return function () {\n      return doc.createComment(data);\n    };\n  };\n}\n\nexport function createProcessingInstruction(target) {\n  return function (data) {\n    return function (doc) {\n      return function () {\n        return doc.createProcessingInstruction(target, data);\n      };\n    };\n  };\n}\n\nexport function importNode(node) {\n  return function (deep) {\n    return function (doc) {\n      return function () {\n        return doc.importNode(node, deep);\n      };\n    };\n  };\n}\n\nexport function adoptNode(node) {\n  return function (doc) {\n    return function () {\n      return doc.adoptNode(node);\n    };\n  };\n}\n", "module Util where\n\nimport Prelude\n\nimport Control.Monad.Maybe.Trans (MaybeT(..))\nimport Data.Array (filter, find, mapMaybe)\nimport Data.Foldable (for_)\nimport Data.Maybe (Maybe(..), fromJust, fromMaybe, maybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Data.String (Pattern(..), Replacement(..), drop, replaceAll, split, take)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Effect (Effect)\nimport Halogen (ClassName(..))\nimport Halogen.HTML as HH\nimport Halogen.HTML.Properties as HP\nimport JSURI (decodeURIComponent, encodeURIComponent)\nimport Partial.Unsafe (unsafePartial)\nimport Web.DOM (Element, Node)\nimport Web.DOM.Document (toNonElementParentNode)\nimport Web.DOM.Element (fromNode, toParentNode)\nimport Web.DOM.NodeList (toArray)\nimport Web.DOM.NonElementParentNode (getElementById)\nimport Web.DOM.ParentNode (QuerySelector(..), querySelector, querySelectorAll)\nimport Web.HTML (HTMLDocument, Location, window)\nimport Web.HTML.HTMLDocument (body) as HD\nimport Web.HTML.HTMLDocument (toDocument)\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLElement (fromElement) as HE\nimport Web.HTML.Location (search)\nimport Web.HTML.Window (document, location)\n\nunsafeDecode :: String -> String\nunsafeDecode str = unsafePartial $ fromJust $ decodeURIComponent str\n  \n-- Halogen\n\nclass_ :: forall r i. String -> HP.IProp ( \"class\" :: String | r) i\nclass_ = HP.class_ <<< HH.ClassName\n\nattr :: forall r i. String -> String -> HP.IProp r i\nattr a = HP.attr (HH.AttrName a)\n\n-- Util\n\n_queryBoth :: forall a. Tuple String Element -> Tuple String Element -> (Element -> Element -> Effect a) -> Effect Unit\n_queryBoth (Tuple qa ea) (Tuple qb eb) f = do\n   ma <- _querySelector qa ea\n   mb <- _querySelector qb eb\n   for_ ma \\a -> \n     for_ mb \\b ->\n       f a b\n\n_queryBoth' :: forall a. Tuple String Element -> Tuple String Element -> (Element -> Array Node -> Effect a) -> Effect Unit\n_queryBoth' (Tuple qa ea) (Tuple qb eb) f = do\n   ma <- _querySelector qa ea\n   bs <- _querySelectorAll qb eb\n   for_ ma \\a -> \n     f a bs\n\n_queryBoth'' :: forall a. Tuple String Element -> Tuple String Element -> (Array Node -> Array Node -> Effect a) -> Effect a\n_queryBoth'' (Tuple qa ea) (Tuple qb eb) f = do\n   as <- _querySelectorAll qa ea\n   bs <- _querySelectorAll qb eb\n   f as bs\n\n_querySelector :: String -> Element -> Effect (Maybe Element)\n_querySelector s n = querySelector (QuerySelector s) (toParentNode n)\n\n_querySelectorAll :: String -> Element -> Effect (Array Node)\n_querySelectorAll s n = toArray =<< querySelectorAll (QuerySelector s) (toParentNode n)\n\n_fromNode :: Node -> Element\n_fromNode e = unsafePartial $ fromJust (fromNode e)\n\n_fromElement :: Element -> HTMLElement\n_fromElement e = unsafePartial $ fromJust (HE.fromElement e)\n\n_getElementById :: String -> HTMLDocument -> Effect (Maybe Element)\n_getElementById s = getElementById s <<< toNonElementParentNode <<< toDocument\n\n_doc :: Effect HTMLDocument\n_doc = document =<< window \n\n_loc :: Effect Location\n_loc = location =<< window \n\ntype QueryStringArray = Array (Tuple String (Maybe String))\n\n_curQuerystring :: Effect QueryStringArray\n_curQuerystring = do\n  loc <- _loc\n  srh <- search loc\n  pure $ _parseQueryString srh\n\n_parseQueryString :: String -> QueryStringArray\n_parseQueryString srh = do\n  let qs = let srh' = take 1 srh in if (srh' == \"#\" || srh' == \"?\") then drop 1 srh else srh\n  mapMaybe go $ (filter (_ /= \"\") <<< split (Pattern \"&\")) qs\n  where\n    decode = unsafeDecode <<< replaceAll (Pattern \"+\") (Replacement \" \")\n    go kv =\n      case split (Pattern \"=\") kv of\n        [k] -> Just (Tuple (decode k) Nothing)\n        [k, v] -> Just (Tuple (decode k) (Just (decode v)))\n        _ -> Nothing\n\n_lookupQueryStringValue :: QueryStringArray -> String -> Maybe String\n_lookupQueryStringValue qs k = do\n  join $ map snd $ find ((_ == k) <<< fst) qs\n\n_body :: Effect HTMLElement\n_body = unsafePartial $ pure <<< fromJust =<< HD.body =<< _doc\n\n_mt :: forall a. Effect (Maybe a) -> MaybeT Effect a\n_mt = MaybeT\n\n_mt_pure :: forall a. Maybe a -> MaybeT Effect a\n_mt_pure = MaybeT <<< pure\n\nencodeTag :: String -> String\nencodeTag = fromMaybe \"\" <<< encodeURIComponent <<< replaceAll (Pattern \"+\") (Replacement \"%2B\")\n\ndummyAttr :: forall r i. HP.IProp r i\ndummyAttr = HP.attr (HH.AttrName \"data-dummy\") \"\"\n\nwhenP :: forall r i. Boolean -> HP.IProp r i -> HP.IProp r i\nwhenP b p = if b then p else dummyAttr\n\nmaybeP :: forall a r i. Maybe a -> (a -> HP.IProp r i) -> HP.IProp r i\nmaybeP m p = maybe dummyAttr p m\n  \nwhenC :: Boolean -> ClassName -> ClassName\nwhenC b c = if b then c else ClassName \"\"\n\nwhenH :: forall p i. Boolean -> (Unit -> HH.HTML p i) -> HH.HTML p i\nwhenH b k = if b then k unit else HH.text \"\"\n\nwhenA :: forall t. Boolean -> (Unit -> Array t) -> Array t\nwhenA b k = if b then k unit else []\n\nifElseH :: forall p i. Boolean -> (Unit -> HH.HTML p i) -> (Unit -> HH.HTML p i) -> HH.HTML p i\nifElseH b f k = if b then f unit else k unit\n\nifElseA :: forall t. Boolean -> (Unit -> Array t) -> (Unit -> Array t) -> Array t\nifElseA b f k = if b then f unit else k unit\n\nmaybeH :: forall a p i. Maybe a -> (a -> HH.HTML p i) -> HH.HTML p i\nmaybeH m k = maybe (HH.text \"\") k m\n\nfromNullableStr :: Nullable String -> String\nfromNullableStr = fromMaybe \"\" <<< toMaybe\n\nmonthNames :: Array String\nmonthNames = [\"january\", \"february\", \"march\", \"april\", \"may\", \"june\", \"july\", \"august\", \"september\", \"october\", \"november\", \"december\"]\n", "module Data.Lens.Internal.Forget where\n\nimport Prelude\n\nimport Data.Const (Const(..))\nimport Data.Either (Either(..), either)\nimport Data.Lens.Internal.Wander (class Wander)\nimport Data.Newtype (class Newtype, alaF)\nimport Data.Profunctor (class Profunctor)\nimport Data.Profunctor.Choice (class Choice)\nimport Data.Profunctor.Cochoice (class Cochoice)\nimport Data.Profunctor.Strong (class Strong)\nimport Data.Tuple (fst, snd)\n\n-- | Profunctor that forgets the `b` value and returns (and accumulates) a\n-- | value of type `r`.\n-- |\n-- | `Forget r` is isomorphic to `Star (Const r)`, but can be given a `Cochoice`\n-- | instance.\nnewtype Forget :: forall k. Type -> Type -> k -> Type\nnewtype Forget r a b = Forget (a -> r)\n\nderive instance newtypeForget :: Newtype (Forget r a b) _\n\nderive newtype instance semigroupForget :: Semigroup r => Semigroup (Forget r a b)\n\nderive newtype instance monoidForget :: Monoid r => Monoid (Forget r a b)\n\ninstance profunctorForget :: Profunctor (Forget r) where\n  dimap f _ (Forget z) = Forget (z <<< f)\n\ninstance choiceForget :: Monoid r => Choice (Forget r) where\n  left (Forget z) = Forget (either z mempty)\n  right (Forget z) = Forget (either mempty z)\n\ninstance strongForget :: Strong (Forget r) where\n  first (Forget z) = Forget (z <<< fst)\n  second (Forget z) = Forget (z <<< snd)\n\ninstance cochoiceForget :: Cochoice (Forget r) where\n  unleft (Forget z) = Forget (z <<< Left)\n  unright (Forget z) = Forget (z <<< Right)\n\ninstance wanderForget :: Monoid r => Wander (Forget r) where\n  wander f (Forget r) = Forget (alaF Const f r)\n", "module Data.Profunctor.Strong where\n\nimport Prelude\n\nimport Data.Profunctor (class Profunctor, dimap)\nimport Data.Tuple (Tuple(..))\n\n-- | The `Strong` class extends `Profunctor` with combinators for working with\n-- | product types.\n-- |\n-- | `first` and `second` lift values in a `Profunctor` to act on the first and\n-- | second components of a `Tuple`, respectively.\n-- |\n-- | Another way to think about Strong is to piggyback on the intuition of\n-- | inputs and outputs.  Rewriting the type signature in this light then yields:\n-- | ```\n-- | first ::  forall input output a. p input output -> p (Tuple input a) (Tuple output a)\n-- | second :: forall input output a. p input output -> p (Tuple a input) (Tuple a output)\n-- | ```\n-- | If we specialize the profunctor p to the function arrow, we get the following type\n-- | signatures, which may look a bit more familiar:\n-- | ```\n-- | first ::  forall input output a. (input -> output) -> (Tuple input a) -> (Tuple output a)\n-- | second :: forall input output a. (input -> output) -> (Tuple a input) -> (Tuple a output)\n-- | ```\n-- | So, when the `profunctor` is `Function` application, `first` essentially applies your function\n-- | to the first element of a `Tuple`, and `second` applies it to the second element (same as `map` would do).\nclass Profunctor p <= Strong p where\n  first :: forall a b c. p a b -> p (Tuple a c) (Tuple b c)\n  second :: forall a b c. p b c -> p (Tuple a b) (Tuple a c)\n\ninstance strongFn :: Strong (->) where\n  first a2b (Tuple a c) = Tuple (a2b a) c\n  second = (<$>)\n\n-- | Compose a value acting on a `Tuple` from two values, each acting on one of\n-- | the components of the `Tuple`.\n-- |\n-- | Specializing `(***)` to function application would look like this:\n-- | ```\n-- | (***) :: forall a b c d. (a -> b) -> (c -> d) -> (Tuple a c) -> (Tuple b d)\n-- | ```\n-- | We take two functions, `f` and `g`, and we transform them into a single function which\n-- | takes a `Tuple` and maps `f` over the first element and `g` over the second.  Just like `bi-map`\n-- | would do for the `bi-functor` instance of `Tuple`.\nsplitStrong\n  :: forall p a b c d\n   . Category p\n  => Strong p\n  => p a b\n  -> p c d\n  -> p (Tuple a c) (Tuple b d)\nsplitStrong l r = first l >>> second r\n\ninfixr 3 splitStrong as ***\n\n-- | Compose a value which introduces a `Tuple` from two values, each introducing\n-- | one side of the `Tuple`.\n-- |\n-- | This combinator is useful when assembling values from smaller components,\n-- | because it provides a way to support two different types of output.\n-- |\n-- | Specializing `(&&&)` to function application would look like this:\n-- | ```\n-- | (&&&) :: forall a b c. (a -> b) -> (a -> c) -> (a -> (Tuple b c))\n-- | ```\n-- | We take two functions, `f` and `g`, with the same parameter type and we transform them into a\n-- | single function which takes one parameter and returns a `Tuple` of the results of running\n-- | `f` and `g` on the parameter, respectively.  This allows us to run two parallel computations\n-- | on the same input and return both results in a `Tuple`.\nfanout\n  :: forall p a b c\n   . Category p\n  => Strong p\n  => p a b\n  -> p a c\n  -> p a (Tuple b c)\nfanout l r = split >>> (l *** r)\n  where\n  split :: p a (Tuple a a)\n  split = dimap identity (\\a -> Tuple a a) identity\n\ninfixr 3 fanout as &&&\n", "-- | This module defines functions for working with getters.\nmodule Data.Lens.Getter\n  ( (^.)\n  , viewOn\n  , view\n  , to\n  , takeBoth\n  , use\n  , iview\n  , iuse\n  , cloneGetter\n  , module Data.Lens.Types\n  ) where\n\nimport Prelude\n\nimport Control.Monad.State.Class (class MonadState, gets)\nimport Data.Lens.Internal.Forget (Forget(..))\nimport Data.Lens.Types (AGetter, Fold, Getter, Indexed(..), IndexedFold, IndexedGetter, Optic)\nimport Data.Newtype (unwrap)\nimport Data.Profunctor.Strong ((&&&))\nimport Data.Tuple (Tuple)\n\ninfixl 8 viewOn as ^.\n\n-- | View the focus of a `Getter`.\nview :: forall s t a b. AGetter s t a b -> s -> a\nview l = unwrap (l (Forget identity))\n\n-- | View the focus of a `Getter` and its index.\niview :: forall i s t a b. IndexedFold (Tuple i a) i s t a b -> s -> Tuple i a\niview l = unwrap (l (Indexed $ Forget identity))\n\n-- | Synonym for `view`, flipped.\nviewOn :: forall s t a b. s -> AGetter s t a b -> a\nviewOn s l = view l s\n\n-- | Convert a function into a getter.\nto :: forall s t a b. (s -> a) -> Getter s t a b\nto f p = Forget (unwrap p <<< f)\n\ncloneGetter :: forall s t a b. AGetter s t a b -> Getter s t a b\ncloneGetter g = to (view g)\n\n-- | Combine two getters.\ntakeBoth :: forall s t a b c d. AGetter s t a b -> AGetter s t c d -> Getter s t (Tuple a c) (Tuple b d)\ntakeBoth l r = to (view l &&& view r)\n\n-- | View the focus of a `Getter` in the state of a monad.\nuse :: forall s t a b m. MonadState s m => Getter s t a b -> m a\nuse p = gets (_ ^. p)\n\n-- | View the focus of a `Getter` and its index in the state of a monad.\niuse\n  :: forall i s t a b m\n   . MonadState s m\n  => IndexedFold (Tuple i a) i s t a b\n  -> m (Tuple i a)\niuse p = gets (iview p)\n", "-- | This module defines functions for working with lenses.\nmodule Data.Lens.Lens\n  ( lens\n  , lens'\n  , withLens\n  , cloneLens\n  , ilens\n  , ilens'\n  , withIndexedLens\n  , cloneIndexedLens\n  , lensStore\n  , module Data.Lens.Types\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Data.Lens.Internal.Indexed (Indexed(..))\nimport Data.Lens.Internal.Shop (Shop(..))\nimport Data.Lens.Types\n  ( ALens\n  , ALens'\n  , AnIndexedLens\n  , AnIndexedLens'\n  , IndexedLens\n  , IndexedLens'\n  , Lens\n  , Lens'\n  )\nimport Data.Newtype (un)\nimport Data.Profunctor (dimap)\nimport Data.Profunctor.Strong (first)\nimport Data.Tuple (Tuple(..))\n\n-- | Create a `Lens` from a getter/setter pair.\n-- |\n-- | ```purescript\n-- | > species = lens _.species $ _ {species = _}\n-- | > view species {species : \"bovine\"}\n-- | \"bovine\"\n-- |\n-- | > _2 = lens Tuple.snd $ \\(Tuple keep _) new -> Tuple keep new\n-- | ```\n-- |\n-- | Note: `_2` is predefined in `Data.Lens.Tuple`.\n\nlens :: forall s t a b. (s -> a) -> (s -> b -> t) -> Lens s t a b\nlens get set = lens' \\s -> Tuple (get s) \\b -> set s b\n\nlens' :: forall s t a b. (s -> Tuple a (b -> t)) -> Lens s t a b\nlens' to pab = dimap to (\\(Tuple b f) -> f b) (first pab)\n\nwithLens :: forall s t a b r. ALens s t a b -> ((s -> a) -> (s -> b -> t) -> r) -> r\nwithLens l f = case l (Shop identity \\_ b -> b) of Shop x y -> f x y\n\ncloneLens :: forall s t a b. ALens s t a b -> Lens s t a b\ncloneLens l = withLens l \\x y p -> lens x y p\n\nilens'\n  :: forall i s t a b\n   . (s -> Tuple (Tuple i a) (b -> t))\n  -> IndexedLens i s t a b\nilens' to pab = dimap to (\\(Tuple b f) -> f b) (first ((un Indexed) pab))\n\n-- create an `IndexedLens` from a getter/setter pair.\nilens\n  :: forall i s t a b\n   . (s -> Tuple i a)\n  -> (s -> b -> t)\n  -> IndexedLens i s t a b\nilens get set = ilens' \\s -> Tuple (get s) \\b -> set s b\n\nwithIndexedLens\n  :: forall i s t a b r\n   . (AnIndexedLens i s t a b)\n  -> ((s -> (Tuple i a)) -> (s -> b -> t) -> r)\n  -> r\nwithIndexedLens l f = case l (Indexed (Shop identity \\_ b -> b)) of Shop x y -> f x y\n\ncloneIndexedLens :: forall i s t a b. AnIndexedLens i s t a b -> IndexedLens i s t a b\ncloneIndexedLens l = withIndexedLens l \\x y p -> ilens x y p\n\n-- | Converts a lens into the form that `lens'` accepts.\n-- |\n-- | Can be useful when defining a lens where the focus appears under multiple\n-- | constructors of an algebraic data type.  This function would be called for\n-- | each case of the data type.\n-- |\n-- | For example:\n-- |\n-- | ```\n-- | data LensStoreExample = LensStoreA Int | LensStoreB (Tuple Boolean Int)\n-- |\n-- | lensStoreExampleInt :: Lens' LensStoreExample Int\n-- | lensStoreExampleInt = lens' case _ of\n-- |   LensStoreA i -> map LensStoreA <$> lensStore identity i\n-- |   LensStoreB i -> map LensStoreB <$> lensStore _2 i\n-- | ```\nlensStore :: forall s t a b. ALens s t a b -> s -> Tuple a (b -> t)\nlensStore l = withLens l (lift2 Tuple)\n\n", "-- | This module defines functions for working with setters.\nmodule Data.Lens.Setter\n  ( (%~)\n  , over\n  , iover\n  , (.~)\n  , set\n  , (+~)\n  , addOver\n  , (-~)\n  , subOver\n  , (*~)\n  , mulOver\n  , (//~)\n  , divOver\n  , (||~)\n  , disjOver\n  , (&&~)\n  , conjOver\n  , (<>~)\n  , appendOver\n  , (?~)\n  , setJust\n  , (.=)\n  , assign\n  , (%=)\n  , modifying\n  , (+=)\n  , addModifying\n  , (*=)\n  , mulModifying\n  , (-=)\n  , subModifying\n  , (//=)\n  , divModifying\n  , (||=)\n  , disjModifying\n  , (&&=)\n  , conjModifying\n  , (<>=)\n  , appendModifying\n  , (?=)\n  , assignJust\n  , module Data.Lens.Types\n  ) where\n\nimport Prelude\n\nimport Control.Monad.State.Class (class MonadState, modify)\nimport Data.Lens.Types (Indexed(..), IndexedSetter, Setter, Setter')\nimport Data.Maybe (Maybe(..))\nimport Data.Tuple (uncurry)\n\ninfixr 4 over as %~\ninfixr 4 set as .~\ninfixr 4 addOver as +~\ninfixr 4 subOver as -~\ninfixr 4 mulOver as *~\ninfixr 4 divOver as //~\ninfixr 4 disjOver as ||~\ninfixr 4 conjOver as &&~\ninfixr 4 appendOver as <>~\ninfixr 4 setJust as ?~\n\ninfix 4 assign as .=\ninfix 4 modifying as %=\ninfix 4 addModifying as +=\ninfix 4 mulModifying as *=\ninfix 4 subModifying as -=\ninfix 4 divModifying as //=\ninfix 4 disjModifying as ||=\ninfix 4 conjModifying as &&=\ninfix 4 appendModifying as <>=\ninfix 4 assignJust as ?=\n\n-- | Apply a function to the foci of a `Setter`.\nover :: forall s t a b. Setter s t a b -> (a -> b) -> s -> t\nover l = l\n\n-- | Apply a function to the foci of a `Setter` that may vary with the index.\niover :: forall i s t a b. IndexedSetter i s t a b -> (i -> a -> b) -> s -> t\niover l f = l (Indexed $ uncurry f)\n\n-- | Set the foci of a `Setter` to a constant value.\nset :: forall s t a b. Setter s t a b -> b -> s -> t\nset l b = over l (const b)\n\naddOver :: forall s t a. Semiring a => Setter s t a a -> a -> s -> t\naddOver p = over p <<< add\n\nmulOver :: forall s t a. Semiring a => Setter s t a a -> a -> s -> t\nmulOver p = over p <<< flip mul\n\nsubOver :: forall s t a. Ring a => Setter s t a a -> a -> s -> t\nsubOver p = over p <<< flip sub\n\ndivOver :: forall s t a. EuclideanRing a => Setter s t a a -> a -> s -> t\ndivOver p = over p <<< flip div\n\ndisjOver :: forall s t a. HeytingAlgebra a => Setter s t a a -> a -> s -> t\ndisjOver p = over p <<< flip disj\n\nconjOver :: forall s t a. HeytingAlgebra a => Setter s t a a -> a -> s -> t\nconjOver p = over p <<< flip conj\n\nappendOver :: forall s t a. Semigroup a => Setter s t a a -> a -> s -> t\nappendOver p = over p <<< flip append\n\nsetJust :: forall s t a b. Setter s t a (Maybe b) -> b -> s -> t\nsetJust p = set p <<< Just\n\n-- Stateful\n\n-- | Set the foci of a `Setter` in a monadic state to a constant value.\nassign :: forall s a b m. MonadState s m => Setter s s a b -> b -> m Unit\nassign p b = void (modify (set p b))\n\n-- | Modify the foci of a `Setter` in a monadic state.\nmodifying :: forall s a b m. MonadState s m => Setter s s a b -> (a -> b) -> m Unit\nmodifying p f = void (modify (over p f))\n\naddModifying :: forall s a m. MonadState s m => Semiring a => Setter' s a -> a -> m Unit\naddModifying p = modifying p <<< add\n\nmulModifying :: forall s a m. MonadState s m => Semiring a => Setter' s a -> a -> m Unit\nmulModifying p = modifying p <<< flip mul\n\nsubModifying :: forall s a m. MonadState s m => Ring a => Setter' s a -> a -> m Unit\nsubModifying p = modifying p <<< flip sub\n\ndivModifying :: forall s a m. MonadState s m => EuclideanRing a => Setter' s a -> a -> m Unit\ndivModifying p = modifying p <<< flip div\n\ndisjModifying :: forall s a m. MonadState s m => HeytingAlgebra a => Setter' s a -> a -> m Unit\ndisjModifying p = modifying p <<< flip disj\n\nconjModifying :: forall s a m. MonadState s m => HeytingAlgebra a => Setter' s a -> a -> m Unit\nconjModifying p = modifying p <<< flip conj\n\nappendModifying :: forall s a m. MonadState s m => Semigroup a => Setter' s a -> a -> m Unit\nappendModifying p = modifying p <<< flip append\n\nassignJust :: forall s a b m. MonadState s m => Setter s s a (Maybe b) -> b -> m Unit\nassignJust p = assign p <<< Just\n", "module Web.UIEvent.MouseEvent.EventTypes where\n\nimport Web.Event.Event (EventType(..))\n\nauxclick :: EventType\nauxclick = EventType \"auxclick\"\n\nclick :: EventType\nclick = EventType \"click\"\n\ndblclick :: EventType\ndblclick = EventType \"dblclick\"\n\nmousedown :: EventType\nmousedown = EventType \"mousedown\"\n\nmouseenter :: EventType\nmouseenter = EventType \"mouseenter\"\n\nmouseleave :: EventType\nmouseleave = EventType \"mouseleave\"\n\nmousemove :: EventType\nmousemove = EventType \"mousemove\"\n\nmouseout :: EventType\nmouseout = EventType \"mouseout\"\n\nmouseover :: EventType\nmouseover = EventType \"mouseover\"\n\nmouseup :: EventType\nmouseup = EventType \"mouseup\"\n", "module Halogen.HTML.Events\n  ( handler\n  , handler'\n  , onAbort\n  , onError\n  , onLoad\n  , onScroll\n  , onChange\n  , onFileUpload\n  , onInput\n  , onInvalid\n  , onReset\n  , onSelect\n  , onSubmit\n  , onTransitionEnd\n  , onCopy\n  , onPaste\n  , onCut\n  , onAuxClick\n  , onClick\n  -- , onContextMenu\n  , onDoubleClick\n  , onMouseDown\n  , onMouseEnter\n  , onMouseLeave\n  , onMouseMove\n  , onMouseOver\n  , onMouseOut\n  , onMouseUp\n  , onWheel\n  , onKeyDown\n  -- , onKeyPress\n  , onKeyUp\n  , onBlur\n  , onFocus\n  , onFocusIn\n  , onFocusOut\n  , onDrag\n  , onDragEnd\n  , onDragExit\n  , onDragEnter\n  , onDragLeave\n  , onDragOver\n  , onDragStart\n  , onDrop\n  , onTouchCancel\n  , onTouchEnd\n  , onTouchEnter\n  , onTouchLeave\n  , onTouchMove\n  , onTouchStart\n  , onResize\n  , onValueChange\n  , onValueInput\n  , onSelectedIndexChange\n  , onChecked\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Except (runExcept)\nimport Data.Either (either)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Unfoldable (class Unfoldable, none)\nimport Foreign (F, Foreign, readBoolean, readInt, readString, unsafeToForeign)\nimport Foreign.Index (readProp)\nimport Halogen.HTML.Core (Prop)\nimport Halogen.HTML.Core as Core\nimport Halogen.HTML.Properties (IProp)\nimport Halogen.Query.Input (Input(..))\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.Clipboard.ClipboardEvent (ClipboardEvent)\nimport Web.Clipboard.ClipboardEvent.EventTypes as CET\nimport Web.Event.Event (Event, EventType(..))\nimport Web.Event.Event as EE\nimport Web.Event.Event as Event\nimport Web.File.File (File)\nimport Web.File.FileList (items)\nimport Web.HTML.Event.DragEvent (DragEvent)\nimport Web.HTML.Event.DragEvent.EventTypes as DET\nimport Web.HTML.Event.EventTypes as ET\nimport Web.HTML.HTMLInputElement as HTMLInputElement\nimport Web.TouchEvent.TouchEvent (TouchEvent)\nimport Web.UIEvent.FocusEvent (FocusEvent)\nimport Web.UIEvent.FocusEvent.EventTypes as FET\nimport Web.UIEvent.KeyboardEvent (KeyboardEvent)\nimport Web.UIEvent.KeyboardEvent.EventTypes as KET\nimport Web.UIEvent.MouseEvent (MouseEvent)\nimport Web.UIEvent.MouseEvent.EventTypes as MET\nimport Web.UIEvent.WheelEvent (WheelEvent)\nimport Web.UIEvent.WheelEvent.EventTypes as WET\nimport Effect.Unsafe (unsafePerformEffect)\n\nhandler :: forall r i. EventType -> (Event -> i) -> IProp r i\nhandler et f =\n  (unsafeCoerce :: (EventType -> (Event -> Maybe i) -> Prop i) -> EventType -> (Event -> Maybe (Input i)) -> IProp r i)\n    Core.handler\n    et\n    \\ev -> Just (Action (f ev))\n\nhandler' :: forall r i. EventType -> (Event -> Maybe i) -> IProp r i\nhandler' et f =\n  (unsafeCoerce :: (EventType -> (Event -> Maybe i) -> Prop i) -> EventType -> (Event -> Maybe (Input i)) -> IProp r i)\n    Core.handler\n    et\n    \\ev -> Action <$> f ev\n\nonAbort :: forall r i. (Event -> i) -> IProp (onAbort :: Event | r) i\nonAbort = handler (EventType \"abort\")\n\nonError :: forall r i. (Event -> i) -> IProp (onError :: Event | r) i\nonError = handler ET.error\n\nonLoad :: forall r i. (Event -> i) -> IProp (onLoad :: Event | r) i\nonLoad = handler ET.load\n\nonScroll :: forall r i. (Event -> i) -> IProp (onScroll :: Event | r) i\nonScroll = handler (EventType \"scroll\")\n\nonChange :: forall r i. (Event -> i) -> IProp (onChange :: Event | r) i\nonChange = handler ET.change\n\nonFileUpload\n  :: forall r i t\n   . Unfoldable t\n  => (t File -> i)\n  -> IProp (onChange :: Event | r) i\nonFileUpload f = handler ET.change $\n  ( Event.target\n      >=> HTMLInputElement.fromEventTarget\n      >=>\n        HTMLInputElement.files >>> unsafePerformEffect\n  )\n    >>> maybe none items\n    >>> f\n\nonInput :: forall r i. (Event -> i) -> IProp (onInput :: Event | r) i\nonInput = handler ET.input\n\nonInvalid :: forall r i. (Event -> i) -> IProp (onInvalid :: Event | r) i\nonInvalid = handler ET.invalid\n\nonReset :: forall r i. (Event -> i) -> IProp (onReset :: Event | r) i\nonReset = handler (EventType \"reset\")\n\nonSelect :: forall r i. (Event -> i) -> IProp (onSelect :: Event | r) i\nonSelect = handler ET.select\n\nonSubmit :: forall r i. (Event -> i) -> IProp (onSubmit :: Event | r) i\nonSubmit = handler (EventType \"submit\")\n\nonTransitionEnd :: forall r i. (Event -> i) -> IProp (onTransitionEnd :: Event | r) i\nonTransitionEnd = handler (EventType \"transitionend\")\n\nonCopy :: forall r i. (ClipboardEvent -> i) -> IProp (onCopy :: ClipboardEvent | r) i\nonCopy = handler CET.copy <<< clipboardHandler\n\nonPaste :: forall r i. (ClipboardEvent -> i) -> IProp (onPaste :: ClipboardEvent | r) i\nonPaste = handler CET.paste <<< clipboardHandler\n\nonCut :: forall r i. (ClipboardEvent -> i) -> IProp (onCut :: ClipboardEvent | r) i\nonCut = handler CET.cut <<< clipboardHandler\n\nonAuxClick :: forall r i. (MouseEvent -> i) -> IProp (onAuxClick :: MouseEvent | r) i\nonAuxClick = handler MET.auxclick <<< mouseHandler\n\nonClick :: forall r i. (MouseEvent -> i) -> IProp (onClick :: MouseEvent | r) i\nonClick = handler MET.click <<< mouseHandler\n\n-- onContextMenu :: forall r i. (MouseEvent -> i) -> IProp (onContextMenu :: MouseEvent | r) i\n-- onContextMenu = handler ET.contextmenu <<< mouseHandler\n\nonDoubleClick :: forall r i. (MouseEvent -> i) -> IProp (onDoubleClick :: MouseEvent | r) i\nonDoubleClick = handler MET.dblclick <<< mouseHandler\n\nonMouseDown :: forall r i. (MouseEvent -> i) -> IProp (onMouseDown :: MouseEvent | r) i\nonMouseDown = handler MET.mousedown <<< mouseHandler\n\nonMouseEnter :: forall r i. (MouseEvent -> i) -> IProp (onMouseEnter :: MouseEvent | r) i\nonMouseEnter = handler MET.mouseenter <<< mouseHandler\n\nonMouseLeave :: forall r i. (MouseEvent -> i) -> IProp (onMouseLeave :: MouseEvent | r) i\nonMouseLeave = handler MET.mouseleave <<< mouseHandler\n\nonMouseMove :: forall r i. (MouseEvent -> i) -> IProp (onMouseMove :: MouseEvent | r) i\nonMouseMove = handler MET.mousemove <<< mouseHandler\n\nonMouseOver :: forall r i. (MouseEvent -> i) -> IProp (onMouseOver :: MouseEvent | r) i\nonMouseOver = handler MET.mouseover <<< mouseHandler\n\nonMouseOut :: forall r i. (MouseEvent -> i) -> IProp (onMouseOut :: MouseEvent | r) i\nonMouseOut = handler MET.mouseout <<< mouseHandler\n\nonMouseUp :: forall r i. (MouseEvent -> i) -> IProp (onMouseUp :: MouseEvent | r) i\nonMouseUp = handler MET.mouseup <<< mouseHandler\n\nonWheel :: forall r i. (WheelEvent -> i) -> IProp (onWheel :: WheelEvent | r) i\nonWheel = handler WET.wheel <<< wheelHandler\n\nonKeyDown :: forall r i. (KeyboardEvent -> i) -> IProp (onKeyDown :: KeyboardEvent | r) i\nonKeyDown = handler KET.keydown <<< keyHandler\n\n-- onKeyPress :: forall r i. (KeyboardEvent -> i) -> IProp (onKeyPress :: KeyboardEvent | r) i\n-- onKeyPress = handler KET.keypress <<< keyHandler\n\nonKeyUp :: forall r i. (KeyboardEvent -> i) -> IProp (onKeyUp :: KeyboardEvent | r) i\nonKeyUp = handler KET.keyup <<< keyHandler\n\nonBlur :: forall r i. (FocusEvent -> i) -> IProp (onBlur :: FocusEvent | r) i\nonBlur = handler ET.blur <<< focusHandler\n\nonFocus :: forall r i. (FocusEvent -> i) -> IProp (onFocus :: FocusEvent | r) i\nonFocus = handler FET.focus <<< focusHandler\n\nonFocusIn :: forall r i. (FocusEvent -> i) -> IProp (onFocusIn :: FocusEvent | r) i\nonFocusIn = handler FET.focusin <<< focusHandler\n\nonFocusOut :: forall r i. (FocusEvent -> i) -> IProp (onFocusOut :: FocusEvent | r) i\nonFocusOut = handler FET.focusout <<< focusHandler\n\nonDrag :: forall r i. (DragEvent -> i) -> IProp (onDrag :: DragEvent | r) i\nonDrag = handler DET.drag <<< dragHandler\n\nonDragEnd :: forall r i. (DragEvent -> i) -> IProp (onDragEnd :: DragEvent | r) i\nonDragEnd = handler DET.dragend <<< dragHandler\n\nonDragExit :: forall r i. (DragEvent -> i) -> IProp (onDragExit :: DragEvent | r) i\nonDragExit = handler DET.dragexit <<< dragHandler\n\nonDragEnter :: forall r i. (DragEvent -> i) -> IProp (onDragEnter :: DragEvent | r) i\nonDragEnter = handler DET.dragenter <<< dragHandler\n\nonDragLeave :: forall r i. (DragEvent -> i) -> IProp (onDragLeave :: DragEvent | r) i\nonDragLeave = handler DET.dragleave <<< dragHandler\n\nonDragOver :: forall r i. (DragEvent -> i) -> IProp (onDragOver :: DragEvent | r) i\nonDragOver = handler DET.dragover <<< dragHandler\n\nonDragStart :: forall r i. (DragEvent -> i) -> IProp (onDragStart :: DragEvent | r) i\nonDragStart = handler DET.dragstart <<< dragHandler\n\nonDrop :: forall r i. (DragEvent -> i) -> IProp (onDrop :: DragEvent | r) i\nonDrop = handler DET.drop <<< dragHandler\n\nonTouchCancel :: forall r i. (TouchEvent -> i) -> IProp (onTouchCancel :: TouchEvent | r) i\nonTouchCancel = handler (EventType \"touchcancel\") <<< touchHandler\n\nonTouchEnd :: forall r i. (TouchEvent -> i) -> IProp (onTouchEnd :: TouchEvent | r) i\nonTouchEnd = handler (EventType \"touchend\") <<< touchHandler\n\nonTouchEnter :: forall r i. (TouchEvent -> i) -> IProp (onTouchEnter :: TouchEvent | r) i\nonTouchEnter = handler (EventType \"touchenter\") <<< touchHandler\n\nonTouchLeave :: forall r i. (TouchEvent -> i) -> IProp (onTouchEnter :: TouchEvent | r) i\nonTouchLeave = handler (EventType \"touchleave\") <<< touchHandler\n\nonTouchMove :: forall r i. (TouchEvent -> i) -> IProp (onTouchMove :: TouchEvent | r) i\nonTouchMove = handler (EventType \"touchmove\") <<< touchHandler\n\nonTouchStart :: forall r i. (TouchEvent -> i) -> IProp (onTouchStart :: TouchEvent | r) i\nonTouchStart = handler (EventType \"touchstart\") <<< touchHandler\n\nonResize :: forall r i. (Event -> i) -> IProp (onResize :: Event | r) i\nonResize = handler (EventType \"resize\")\n\nkeyHandler :: forall i. (KeyboardEvent -> i) -> Event -> i\nkeyHandler = unsafeCoerce\n\nmouseHandler :: forall i. (MouseEvent -> i) -> Event -> i\nmouseHandler = unsafeCoerce\n\nwheelHandler :: forall i. (WheelEvent -> i) -> Event -> i\nwheelHandler = unsafeCoerce\n\nfocusHandler :: forall i. (FocusEvent -> i) -> Event -> i\nfocusHandler = unsafeCoerce\n\ndragHandler :: forall i. (DragEvent -> i) -> Event -> i\ndragHandler = unsafeCoerce\n\nclipboardHandler :: forall i. (ClipboardEvent -> i) -> Event -> i\nclipboardHandler = unsafeCoerce\n\ntouchHandler :: forall i. (TouchEvent -> i) -> Event -> i\ntouchHandler = unsafeCoerce\n\n-- | Attaches event handler to event `key` with getting `prop` field as an\n-- | argument of `handler`.\naddForeignPropHandler :: forall r i value. EventType -> String -> (Foreign -> F value) -> (value -> i) -> IProp r i\naddForeignPropHandler key prop reader f =\n  handler' key $ EE.currentTarget >=> \\e -> either (const Nothing) (Just <<< f) $ runExcept $ go e\n  where\n  go a = reader <=< readProp prop $ unsafeToForeign a\n\n-- | Attaches an event handler which will produce an input when the value of an\n-- | input field changes.\nonValueChange :: forall r i. (String -> i) -> IProp (value :: String, onChange :: Event | r) i\nonValueChange = addForeignPropHandler ET.change \"value\" readString\n\n-- | Attaches an event handler which will produce an input when the seleced index of a\n-- | `select` element changes.\nonSelectedIndexChange :: forall r i. (Int -> i) -> IProp (selectedIndex :: Int, onChange :: Event | r) i\nonSelectedIndexChange = addForeignPropHandler ET.change \"selectedIndex\" readInt\n\n-- | Attaches an event handler which will fire on input.\nonValueInput :: forall r i. (String -> i) -> IProp (value :: String, onInput :: Event | r) i\nonValueInput = addForeignPropHandler ET.input \"value\" readString\n\n-- | Attaches an event handler which will fire when a checkbox is checked or\n-- | unchecked.\nonChecked :: forall r i. (Boolean -> i) -> IProp (checked :: Boolean, onChange :: Event | r) i\nonChecked = addForeignPropHandler ET.change \"checked\" readBoolean\n"],
  "mappings": "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",
  "names": ["getEffProp", "name", "node", "children", "_firstElementChild", "_lastElementChild", "childElementCount", "_querySelector", "selector", "querySelector", "qs", "$2", "map", "toMaybe", "$3", "_querySelector", "$4", "eventListener", "fn", "event", "change", "selectElement", "query", "$16", "querySelector", "$17", "toParentNode", "mel", "runHalogenAff", "runAff_", "either", "throwException", "$$const", "pure1", "monadForkAff", "fork", "dict", "Leaf", "Node", "Split", "SplitLast", "unsafeNode", "k", "v", "l", "r", "Leaf", "Node", "$277", "singleton", "k", "v", "Leaf", "unsafeBalancedNode", "height", "Node", "rotateLeft", "l", "rk", "rv", "rl", "rr", "unsafeNode", "rotateRight", "lk", "lv", "ll", "lr", "r", "comp", "m", "LT", "v1", "$lazy_unsafeSplit", "Split", "GT", "EQ", "unsafeSplit", "$lazy_unsafeSplitLast", "SplitLast", "unsafeSplitLast", "unsafeJoinNodes", "v2", "pop", "dictOrd", "k", "m", "v", "unsafeSplit", "compare", "map", "a", "unsafeJoinNodes", "lookup", "dictOrd", "k", "go", "$copy_v", "v", "Leaf", "Node", "v1", "compare", "LT", "GT", "EQ", "insert", "dictOrd", "k", "v", "go", "v1", "Leaf", "singleton", "Node", "v2", "compare", "LT", "unsafeBalancedNode", "GT", "EQ", "foldableMap", "f", "z", "m$prime", "z$prime", "Leaf", "Node", "$lazy_go", "go", "m", "dictMonoid", "v", "append1", "empty", "$$delete", "dictOrd", "k", "go", "v", "Leaf", "Node", "v1", "compare", "LT", "unsafeBalancedNode", "GT", "EQ", "unsafeJoinNodes", "alter", "dictOrd", "f", "k", "m", "v", "unsafeSplit", "compare", "v2", "Nothing", "unsafeJoinNodes", "Just", "unsafeBalancedNode", "log", "s", "warn", "runExists", "unsafeCoerce", "mkExists", "CoyonedaF", "unCoyoneda", "f", "v", "runExists", "v1", "coyoneda", "k", "fi", "functorCoyoneda", "f", "v", "runExists", "v1", "$180", "liftCoyoneda", "coyoneda", "identity", "categoryFn", "OrdBox", "mkOrdBox", "dictOrd", "eqOrdBox", "v", "v1", "ordOrdBox", "pop", "dictIsSymbol", "dictOrd", "sym", "key", "v", "pop1", "Tuple", "reflectSymbol", "mkOrdBox", "lookup", "lookup1", "insert", "val", "insert1", "foreachSlot", "dictApplicative", "k", "traverse_", "$54", "empty", "AutocompleteOff", "AutocompleteOn", "AutocompleteName", "AutocompleteHonorificPrefix", "AutocompleteGivenName", "AutocompleteAdditionalName", "AutocompleteFamilyName", "AutocompleteHonorificSuffix", "AutocompleteNickname", "AutocompleteEmail", "AutocompleteUsername", "AutocompleteNewPassword", "AutocompleteCurrentPassword", "AutocompleteOneTimeCode", "AutocompleteOrganizationTitle", "AutocompleteOrganization", "AutocompleteStreetAddress", "AutocompleteAddressLine1", "AutocompleteAddressLine2", "AutocompleteAddressLine3", "AutocompleteAddressLevel1", "AutocompleteAddressLevel2", "AutocompleteAddressLevel3", "AutocompleteAddressLevel4", "AutocompleteCountry", "AutocompleteCountryName", "AutocompletePostalCode", "AutocompleteCreditCardName", "AutocompleteCreditCardGivenName", "AutocompleteCreditCardAdditionalName", "AutocompleteCreditCardFamilyName", "AutocompleteCreditCardNumber", "AutocompleteCreditCardExpiration", "AutocompleteCreditCardExpirationMonth", "AutocompleteCreditCardExpirationYear", "AutocompleteCreditCardSecurityCode", "AutocompleteCreditCardType", "AutocompleteTransactionCurrency", "AutocompleteTransactionAmount", "AutocompleteLanguage", "AutocompleteBirthday", "AutocompleteBirthdayDay", "AutocompleteBirthdayMonth", "AutocompleteBirthdayYear", "AutocompleteSex", "AutocompleteTelephone", "AutocompleteTelephoneCountryCode", "AutocompleteTelephoneNational", "AutocompleteTelephoneAreaCode", "AutocompleteTelephoneLocal", "AutocompleteTelephoneLocalPrefix", "AutocompleteTelephoneLocalSuffix", "AutocompleteTelephoneExtension", "AutocompleteIMPP", "AutocompleteURL", "AutocompletePhoto", "renderAutocompleteType", "v", "ButtonButton", "ButtonSubmit", "ButtonReset", "renderButtonType", "v", "InputButton", "InputCheckbox", "InputColor", "InputDate", "InputDatetimeLocal", "InputEmail", "InputFile", "InputHidden", "InputImage", "InputMonth", "InputNumber", "InputPassword", "InputRadio", "InputRange", "InputReset", "InputSearch", "InputSubmit", "InputTel", "InputText", "InputTime", "InputUrl", "InputWeek", "renderInputType", "v", "RefUpdate", "Action", "Step", "unStep", "unsafeCoerce", "step", "v", "a", "mkStep", "halt", "extract", "Text", "Elem", "Keyed", "Widget", "Grafted", "Graft", "unGraft", "f", "$61", "graft", "unsafeCoerce", "bifunctorGraft", "f", "g", "unGraft", "v", "graft", "Graft", "$63", "$64", "runGraft", "unGraft", "v", "go", "v2", "Text", "Elem", "map", "Keyed", "map1", "Widget", "Grafted", "bimap", "unsafeGetAny", "key", "obj", "unsafeHasAny", "unsafeSetAny", "val", "forE", "a", "f", "b", "i", "forEachE", "forInE", "o", "ks", "k", "diffWithIxE", "a1", "a2", "f1", "f2", "f3", "a3", "l1", "l2", "strMapWithIxE", "as", "fk", "f", "o", "i", "a", "k", "diffWithKeyAndIxE", "o1", "o2", "refEq", "b", "createTextNode", "s", "doc", "setTextContent", "n", "createElement", "ns", "name", "insertChildIx", "removeChild", "parentNode", "setAttribute", "attr", "val", "el", "removeAttribute", "hasAttribute", "addEventListener", "ev", "listener", "removeEventListener", "jsUndefined", "unsafeLookup", "unsafeGetAny", "unsafeFreeze", "unsafeCoerce", "pokeMutMap", "unsafeSetAny", "newMutMap", "newImpl", "getProp", "name", "doctype", "_namespaceURI", "_prefix", "localName", "tagName", "setAttribute", "name", "value", "element", "toNode", "unsafeCoerce", "haltWidget", "v", "state", "vdom", "Grafted", "$lazy_patchWidget", "runGraft", "Widget", "res$prime", "unStep", "mkStep", "Step", "res", "patchWidget", "haltText", "parent", "$lazy_patchText", "Text", "otherwise", "nextState", "patchText", "haltKeyed", "v1", "s", "haltElem", "eqElemSpec", "ns1", "ns2", "$63", "Just", "Nothing", "$lazy_patchElem", "Elem", "length", "attrs2", "onThis", "v2", "onThese", "ix", "extract", "onThat", "children2", "patchElem", "$lazy_patchKeyed", "Keyed", "ix$prime", "v3", "fst", "patchKeyed", "buildWidget", "build", "w", "buildText", "node", "buildKeyed", "name1", "as1", "ch1", "toNode", "el", "onChild", "attrs", "children", "buildElem", "child", "buildVDom", "spec", "$lazy_build", "Created", "Removed", "Attribute", "Property", "Handler", "Ref", "unsafeGetProperty", "unsafeGetAny", "setProperty", "unsafeSetAny", "removeProperty", "key", "el", "v", "v1", "typeOf", "jsUndefined", "propToStrKey", "Just", "propFromString", "unsafeCoerce", "propFromInt", "unsafeCoerce", "propFromBoolean", "buildProp", "emit", "el", "removeProp", "prevEvents", "v", "v1", "Attribute", "removeAttribute", "toNullable", "Property", "removeProperty", "Handler", "handler", "unsafeLookup", "fst", "Ref", "mbEmit", "Just", "haltProp", "state", "lookup", "Removed", "diffProp", "events", "v11", "v2", "$66", "v4", "refEq", "elVal", "unsafeGetProperty", "$75", "setProperty", "snd", "applyProp", "v3", "unsafeGetAny", "unsafeHasAny", "ev", "ref", "f$prime", "Tuple", "listener", "Created", "ps2", "onThis", "onThese", "onThat", "propToStrKey", "nextState", "props", "$lazy_patchProp", "patchProp", "renderProp", "ps1", "ps1$prime", "HTML", "x", "widget", "$28", "Widget", "toPropValue", "dict", "text", "$29", "Text", "ref", "f", "$30", "v", "Created", "Just", "Removed", "Nothing", "prop", "dictIsProp", "$31", "Property", "$32", "toPropValue1", "isPropString", "isPropInt", "isPropInputType", "$45", "isPropButtonType", "$50", "isPropBoolean", "isPropAutocompleteType", "$51", "handler", "element", "ns", "name", "props", "children", "attr", "ns", "v", "Attribute", "Pure", "Lift", "Ap", "mkAp", "fba", "fb", "liftFreeAp", "goLeft", "dictApplicative", "fStack", "valStack", "nat", "func", "count", "Tuple", "Cons", "cons", "goApply", "vals", "gVal", "Nil", "gRes", "apply", "$31", "Right", "NonEmpty", "functorFreeAp", "f", "x", "foldFreeAp", "z", "go", "$copy_v", "v", "v1", "goApply1", "pure", "Left", "$tco_done", "nextVals", "singleton", "retractFreeAp", "identity", "applyFreeAp", "applicativeFreeAp", "hoistFreeAp", "$54", "CatQueue", "uncons", "$copy_v", "v", "Nil", "CatQueue", "reverse", "Cons", "$tco_done", "Just", "Tuple", "snoc", "a", "$$null", "v", "Nil", "empty", "CatNil", "CatCons", "link", "v", "v1", "CatNil", "CatCons", "snoc", "foldr", "k", "b", "q", "foldl", "$copy_v", "$copy_v1", "$copy_v2", "v2", "Nil", "Cons", "$tco_var_v", "$tco_var_v1", "go", "$copy_xs", "$copy_ys", "uncons", "xs", "Nothing", "x", "i", "ys", "Just", "$tco_var_xs", "Tuple", "$66", "empty", "append", "link", "semigroupCatList", "append", "snoc", "cat", "a", "append", "CatCons", "empty", "Free", "Return", "Bind", "toView", "$copy_v", "runExpF", "v2", "concatF", "r", "append", "v", "uncons", "Nothing", "Just", "$tco_done", "a", "fromView", "f", "empty", "freeMonad", "freeFunctor", "k", "f", "$189", "pure", "freeApplicative", "$190", "freeBind", "v", "Free", "snoc", "$191", "fromView", "Return", "liftF", "f", "fromView", "Bind", "$192", "foldFree", "dictMonadRec", "k", "go", "v", "toView", "Return", "map1", "Done", "pure1", "Bind", "$199", "monadAffAff", "liftAff", "dict", "unChildQueryBox", "unsafeCoerce", "reallyUnsafeRefEq", "a", "b", "unsafeRefEq", "reallyUnsafeRefEq", "unsubscribe", "v", "subscribe", "k", "$76", "notify", "v", "a", "create", "k", "v", "subscribers", "a", "traverse_1", "SubscriptionId", "x", "ForkId", "State", "Subscribe", "Unsubscribe", "Lift", "ChildQuery", "Raise", "Par", "Fork", "Join", "Kill", "GetRef", "HalogenM", "x", "raise", "o", "ordSubscriptionId", "ordInt", "ordForkId", "monadHalogenM", "freeMonad", "monadStateHalogenM", "$181", "HalogenM", "liftF", "State", "monadEffectHalogenM", "dictMonadEffect", "$186", "liftEffect", "$187", "HalogenM", "liftF", "Lift", "monadAffHalogenM", "dictMonadAff", "$188", "liftAff", "$189", "HalogenM", "liftF", "Lift", "getRef", "p", "identity", "functorHalogenM", "freeFunctor", "bindHalogenM", "freeBind", "applicativeHalogenM", "freeApplicative", "Initialize", "Finalize", "Receive", "Action", "Query", "unsafeEqThunk", "v", "v1", "refEq", "runThunk", "v", "buildThunk", "toVDom", "haltThunk", "state", "t2", "unsafeEqThunk", "$48", "$lazy_patchThunk", "runThunk", "vdom", "patchThunk", "renderThunk", "spec", "t", "ComponentSlot", "ThunkSlot", "unComponentSlot", "unsafeCoerce", "unComponent", "mkEval", "args", "v", "Initialize", "voidLeft", "traverse_", "Finalize", "Receive", "Action", "Query", "unCoyoneda", "g", "$45", "map", "maybe", "$46", "mkComponentSlot", "mkComponent", "defaultEval", "componentSlot", "dictIsSymbol", "dictOrd", "label", "p", "comp", "input", "output", "mkComponentSlot", "element", "form", "element", "input", "props", "element", "label", "element", "p", "element", "span", "element", "table", "element", "tbody", "element", "tbody_", "td", "td_", "textarea", "es", "tr", "element", "tr_", "div", "element", "div_", "button", "element", "br", "props", "element", "br_", "a", "element", "ref", "go", "p", "mel", "$29", "prop", "dictIsProp", "isPropBoolean", "isPropString", "isPropInt", "required", "prop1", "rows", "prop3", "target", "prop2", "title", "type_", "dictIsProp", "prop", "value", "name", "prop2", "id", "prop2", "href", "$$for", "prop2", "disabled", "prop1", "class_", "$36", "prop2", "$37", "unwrap", "checked", "prop1", "autofocus", "prop1", "autocomplete", "prop", "isPropAutocompleteType", "attr", "slot", "dictIsSymbol", "dictOrd", "label", "p", "component", "input", "outputQuery", "$11", "getHTMLElementRef", "$24", "map", "functorHalogenM", "v", "$25", "getRef", "unRenderStateX", "unsafeCoerce", "unDriverStateX", "renderStateX_", "dictApplicative", "f", "st", "mkRenderStateX", "renderStateX", "dictFunctor", "mkDriverStateXRef", "mapDriverState", "v", "initDriverState", "component", "input", "handler", "lchs", "ds", "childrenIn", "childrenOut", "selfRef", "handlerRef", "pendingQueries", "pendingOuts", "pendingHandlers", "fresh", "subscriptions", "forks", "unsubscribe", "sid", "ref", "v", "subs", "queueOrRun", "au", "Nothing", "Just", "liftEffect", "write", "Cons", "handleLifecycle", "lchs", "f", "result", "discard1", "traverse_2", "fork", "handleAff", "runAff_", "either", "throwException", "$$const", "pure", "applicativeEffect", "fresh", "modify$prime", "i", "evalQ", "render", "q", "evalM", "Query", "map", "liftCoyoneda", "initRef", "evalChildQuery", "cqb", "v1", "unChildQueryBox", "v2", "evalChild", "v3", "parallel", "bind1", "read", "dsx", "ds", "go", "State", "unsafeRefEq", "otherwise", "Subscribe", "SubscriptionId", "act", "evalF", "Action", "finalize", "modify_", "map2", "insert", "Unsubscribe", "Lift", "ChildQuery", "Raise", "handler", "Par", "sequential", "retractFreeAp", "hoistFreeAp", "$119", "$120", "Fork", "ForkId", "fid", "$$new", "doneRef", "fiber", "insert1", "Join", "forkMap", "Kill", "lookup1", "GetRef", "lookup2", "RefUpdate", "flip", "mapDriverState", "st", "newLifecycleHandlers", "handlePending", "ref", "queue", "$59", "traverse_", "fork", "$60", "reverse", "cleanupSubscriptionsAndForks", "v", "$61", "killFiber", "error", "$62", "runUI", "renderSpec", "component", "i", "squashChildInitializers", "lchs", "preInits", "st", "parentInitializer", "evalM", "render", "Initialize", "handlers", "runComponent", "handler", "j", "lchs$prime", "pre", "$63", "$64", "$$var", "read", "renderChild", "childrenInRef", "childrenOutRef", "slot", "childrenIn", "Just", "$65", "maybe", "pure1", "$66", "Receive", "dsx", "Nothing", "$67", "$68", "$69", "isDuplicate", "warn", "renderStateX", "pure", "shouldProcessHandlers", "write", "Nil", "$70", "queueOrRun", "$71", "evalF", "$72", "$$void", "childHandler", "$73", "$74", "Action", "$75", "v1", "childDS", "finalize", "ds$prime", "rendering", "children", "flip", "tailRecM", "$76", "$77", "$$null", "mmore", "$52", "Loop", "f", "Finalize", "evalDriver", "disposed", "q", "evalQ", "dispose", "for_", "v2", "$78", "notify", "sio", "$79", "getEffProp", "name", "node", "baseURI", "getEffProp", "_ownerDocument", "_parentNode", "_parentElement", "childNodes", "getEffProp", "_firstChild", "_lastChild", "_previousSibling", "_nextSibling", "_nodeValue", "textContent", "getEffProp", "insertBefore", "node1", "node2", "parent", "appendChild", "node", "removeChild", "node", "parent", "parentNode", "$6", "map", "toMaybe", "$7", "_parentNode", "nextSibling", "$15", "map", "toMaybe", "$16", "_nextSibling", "substInParent", "v", "v1", "v2", "Just", "$$void", "insertBefore", "Nothing", "appendChild", "pure", "removeChild", "pn", "npn", "mkSpec", "handler", "renderChildRef", "document", "getNode", "unRenderStateX", "done", "st", "halt", "buildWidget", "spec", "buildThunk", "unwrap", "slot", "ComponentSlot", "ThunkSlot", "step$prime", "$lazy_patch", "$lazy_render", "$lazy_renderComponentSlot", "step", "cs", "renderChild", "node", "rsx", "patch", "render", "renderComponentSlot", "buildAttributes", "buildProp", "renderSpec", "container", "child", "extract", "machine", "toNode", "newNode", "machine$prime", "nextSib", "parent", "runUI", "component", "i", "element", "viewRendered", "bind", "bindAff", "selectElement", "traverse_", "applicativeAff", "foldableMaybe", "el", "toElement", "hasArrayFrom", "hasStringIterator", "hasFromCodePoint", "hasCodePointAt", "_singleton", "fallback", "hasFromCodePoint", "_take", "n", "hasStringIterator", "str", "accum", "iter", "i", "o", "unsurrogate", "lead", "trail", "isTrail", "cu", "isLead", "uncons", "s", "v", "length", "cu1", "fromEnum", "charAt", "cu0", "$43", "unsurrogate", "Just", "fromCharCode", "$75", "toEnumWithDefaults", "boundedEnumChar", "bottom", "boundedChar", "top", "$76", "singletonFallback", "v", "lead", "div", "trail", "mod", "singleton", "_singleton", "singletonFallback", "takeFallback", "v", "v1", "v2", "uncons", "Just", "take", "_take", "drop", "s", "take", "getEffProp", "name", "doc", "url", "documentURI", "origin", "compatMode", "characterSet", "contentType", "_documentElement", "getEffProp", "whenH", "b", "k", "text", "whenA", "b", "k", "unsafeDecode", "str", "ifElseH", "b", "f", "k", "ifElseA", "fromNullableStr", "$53", "fromMaybe", "$54", "toMaybe", "encodeTag", "$55", "$56", "replaceAll", "$57", "$$encodeURIComponent", "class_", "$58", "attr", "a", "_parseQueryString", "srh", "decode", "$59", "replaceAll", "$60", "unsafeDecode", "go", "kv", "v", "split", "Just", "Tuple", "Nothing", "qs", "srh$prime", "take", "$52", "filter", "_lookupQueryStringValue", "qs", "k", "$62", "v", "_loc", "bindFlipped", "location", "windowImpl", "_doc", "bindFlipped", "document", "windowImpl", "_curQuerystring", "_loc", "loc", "_parseQueryString", "srh", "profunctorForget", "f", "v", "v1", "$36", "strongForget", "$37", "fst", "$38", "snd", "strongFn", "a2b", "v", "Tuple", "first", "dict", "view", "l", "identity", "viewOn", "s", "use", "dictMonadState", "p", "v", "lens$prime", "to", "dictStrong", "pab", "v", "lens", "get", "set", "s", "b", "over", "l", "set", "b", "$$const", "modifying", "dictMonadState", "p", "f", "over", "assign", "dictMonadState", "p", "b", "set", "click", "mouseHandler", "unsafeCoerce", "handler$prime", "et", "f", "ev", "handler", "onClick", "$15", "handler", "click", "$16", "mouseHandler", "onSubmit", "handler", "addForeignPropHandler", "key", "prop", "reader", "f", "go", "a", "readProp", "unsafeToForeign", "handler$prime", "composeKleisli", "currentTarget", "e", "$85", "onChecked", "change", "readBoolean", "monadIdentity", "onValueChange", "addForeignPropHandler", "change", "readString"]
}
